<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authorr AI - Professional DAW (Mozart Style)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ========================================
           MOZART-STYLE DAW - CSS VARIABLES
           ======================================== */
        
        :root {
            /* Dark Mode Colors (Default) */
            --daw-bg-primary: #0A0A0A;
            --daw-bg-secondary: #1A1A1A;
            --daw-bg-tertiary: #2A2A2A;
            --daw-bg-header: #141414;
            --daw-bg-track: #1E1E1E;
            
            /* Track Colors */
            --track-narration: #3B82F6;      /* Blue */
            --track-narration-dim: #1E40AF;
            --track-music: #8B5CF6;           /* Purple */
            --track-music-dim: #6D28D9;
            --track-sfx: #F59E0B;             /* Gold/Amber */
            --track-sfx-dim: #D97706;
            
            /* UI Elements */
            --daw-accent: #78e3fe;            /* Cyan accent */
            --daw-accent-hover: #5dd8fc;
            --daw-text-primary: #FFFFFF;
            --daw-text-secondary: #9CA3AF;
            --daw-text-dim: #6B7280;
            --daw-border: #374151;
            --daw-border-light: #4B5563;
            
            /* LED Meters */
            --led-off: #2A2A2A;
            --led-green: #22C55E;
            --led-yellow: #EAB308;
            --led-red: #EF4444;
            
            /* Grid & Timeline */
            --grid-line: #2A2A2A;
            --grid-line-major: #3A3A3A;
            --playhead-color: #78e3fe;
            
            /* Fader Colors */
            --fader-bg: #2A2A2A;
            --fader-track: #4B5563;
            --fader-thumb: #78e3fe;
            --fader-thumb-hover: #5dd8fc;
        }
        
        /* Light Mode Colors */
        [data-theme="light"] {
            --daw-bg-primary: #FFFFFF;
            --daw-bg-secondary: #F3F4F6;
            --daw-bg-tertiary: #E5E7EB;
            --daw-bg-header: #F9FAFB;
            --daw-bg-track: #F3F4F6;
            
            --daw-text-primary: #111827;
            --daw-text-secondary: #4B5563;
            --daw-text-dim: #9CA3AF;
            --daw-border: #D1D5DB;
            --daw-border-light: #E5E7EB;
            
            --grid-line: #E5E7EB;
            --grid-line-major: #D1D5DB;
            
            --fader-bg: #E5E7EB;
            --fader-track: #9CA3AF;
            --led-off: #D1D5DB;
        }
        
        /* ========================================
           GLOBAL STYLES
           ======================================== */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--daw-bg-primary);
            color: var(--daw-text-primary);
            overflow: hidden;
        }
        
        /* ========================================
           DAW CONTAINER
           ======================================== */
        
        .daw-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: var(--daw-bg-primary);
        }
        
        /* ========================================
           HEADER / TRANSPORT CONTROLS
           ======================================== */
        
        .daw-header {
            background-color: var(--daw-bg-header);
            border-bottom: 2px solid var(--daw-border);
            padding: 12px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 70px;
            z-index: 100;
        }
        
        .daw-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--daw-accent);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .transport-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: var(--daw-bg-tertiary);
            padding: 8px 16px;
            border-radius: 12px;
            border: 1px solid var(--daw-border);
        }
        
        .transport-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background-color: var(--daw-bg-secondary);
            color: var(--daw-text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 16px;
        }
        
        .transport-btn:hover {
            background-color: var(--daw-bg-tertiary);
            transform: scale(1.05);
        }
        
        .transport-btn.play {
            background-color: #22C55E;
            color: white;
        }
        
        .transport-btn.play:hover {
            background-color: #16A34A;
        }
        
        .transport-btn.stop {
            background-color: #EF4444;
            color: white;
        }
        
        .transport-btn.stop:hover {
            background-color: #DC2626;
        }
        
        .time-display {
            display: flex;
            align-items: center;
            gap: 16px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: 600;
            color: var(--daw-accent);
            padding: 0 16px;
            border-left: 1px solid var(--daw-border);
            border-right: 1px solid var(--daw-border);
        }
        
        .bpm-display {
            font-size: 14px;
            color: var(--daw-text-secondary);
        }
        
        .header-actions {
            display: flex;
            gap: 12px;
        }
        
        .action-btn {
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid var(--daw-border);
            background-color: var(--daw-bg-secondary);
            color: var(--daw-text-primary);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .action-btn:hover {
            background-color: var(--daw-bg-tertiary);
            border-color: var(--daw-accent);
        }
        
        .action-btn.primary {
            background-color: var(--daw-accent);
            color: #000;
            border-color: var(--daw-accent);
        }
        
        .action-btn.primary:hover {
            background-color: var(--daw-accent-hover);
        }
        
        .theme-toggle {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 1px solid var(--daw-border);
            background-color: var(--daw-bg-secondary);
            color: var(--daw-text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 18px;
        }
        
        .theme-toggle:hover {
            background-color: var(--daw-bg-tertiary);
            border-color: var(--daw-accent);
        }
        
        /* ========================================
           TIMELINE AREA (TOP 70%)
           ======================================== */
        
        .timeline-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--daw-bg-primary);
            overflow: hidden;
        }
        
        .timeline-toolbar {
            background-color: var(--daw-bg-secondary);
            border-bottom: 1px solid var(--daw-border);
            padding: 12px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 50px;
        }
        
        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .toolbar-divider {
            width: 1px;
            height: 24px;
            background-color: var(--daw-border);
            margin: 0 8px;
        }
        
        .tool-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid var(--daw-border);
            background-color: var(--daw-bg-primary);
            color: var(--daw-text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .tool-btn:hover {
            background-color: var(--daw-bg-tertiary);
            color: var(--daw-text-primary);
            border-color: var(--daw-accent);
        }
        
        .tool-btn.active {
            background-color: var(--daw-accent);
            color: #000;
            border-color: var(--daw-accent);
        }
        
        .zoom-label {
            font-size: 12px;
            color: var(--daw-text-dim);
            margin-right: 4px;
        }
        
        .timeline-canvas-wrapper {
            flex: 1;
            position: relative;
            background-color: var(--daw-bg-primary);
            overflow-x: auto;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .timeline-ruler {
            height: 30px;
            background-color: var(--daw-bg-secondary);
            border-bottom: 1px solid var(--daw-border);
            position: relative;
            margin-left: 200px; /* Align with track content area */
        }
        
        .timeline-tracks {
            flex: 1;
            position: relative;
            overflow-y: visible;
            overflow-x: visible;
            /* Scrolling handled by parent wrapper */
        }
        
        .track-row {
            height: 80px;
            min-height: 80px;
            max-height: 80px;
            position: relative;
            border-bottom: 1px solid var(--daw-border);
            display: flex;
            align-items: stretch;
            overflow: visible;
            /* Allow track canvas to extend beyond viewport */
        }
        
        .track-header {
            width: 200px;
            min-width: 200px;
            max-width: 200px;
            background-color: var(--daw-bg-secondary);
            border-right: 1px solid var(--daw-border);
            padding: 12px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
            flex-shrink: 0;
        }
        
        .track-name {
            font-weight: 600;
            font-size: 14px;
            color: var(--daw-text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: text;
        }
        
        .track-name-input {
            background: transparent;
            border: 1px solid var(--daw-accent);
            border-radius: 4px;
            padding: 2px 6px;
            color: var(--daw-text-primary);
            font-size: 14px;
            font-weight: 600;
            outline: none;
        }
        
        .track-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        .track-icon.narration {
            background-color: var(--track-narration);
            color: white;
        }
        
        .track-icon.music {
            background-color: var(--track-music);
            color: white;
        }
        
        .track-icon.sfx {
            background-color: var(--track-sfx);
            color: white;
        }
        
        .track-canvas {
            position: relative;
            background-color: var(--daw-bg-track);
            height: 80px;
            min-height: 80px;
            max-height: 80px;
            transition: all 0.2s;
            overflow: visible;
            /* Width set dynamically by renderTimelineRuler() - NO flex, use explicit width */
        }
        
        .audio-clip {
            position: absolute;
            cursor: move;
            user-select: none;
        }
        
        .audio-clip:hover {
            filter: brightness(1.2);
        }
        
        .track-canvas.narration {
            background-color: var(--track-narration-dim);
            background-image: 
                repeating-linear-gradient(90deg,
                    transparent 0px,
                    transparent 49.5px,
                    rgba(255, 255, 255, 0.03) 49.5px,
                    rgba(255, 255, 255, 0.03) 50px
                );
        }
        
        .track-canvas.music {
            background-color: var(--track-music-dim);
            background-image: 
                repeating-linear-gradient(90deg,
                    transparent 0px,
                    transparent 49.5px,
                    rgba(255, 255, 255, 0.03) 49.5px,
                    rgba(255, 255, 255, 0.03) 50px
                );
        }
        
        .track-canvas.sfx {
            background-color: var(--track-sfx-dim);
            background-image: 
                repeating-linear-gradient(90deg,
                    transparent 0px,
                    transparent 49.5px,
                    rgba(255, 255, 255, 0.03) 49.5px,
                    rgba(255, 255, 255, 0.03) 50px
                );
        }
        
        #playhead {
            position: absolute;
            top: 30px; /* Start below ruler */
            left: 200px; /* Start after track headers */
            width: 2px;
            height: calc(100% - 30px);
            background-color: var(--playhead-color);
            z-index: 1000;
            pointer-events: none;
            display: none;
        }
        
        #playhead::before {
            content: '';
            position: absolute;
            top: -30px;
            left: -4px;
            width: 10px;
            height: 10px;
            background-color: var(--playhead-color);
            border-radius: 50%;
        }
        
        .audio-clip {
            transition: all 0.15s ease;
        }
        
        .audio-clip.selected {
            border: 3px solid #FFD700 !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6) !important;
            z-index: 10;
        }
        
        .audio-clip:hover {
            filter: brightness(1.2);
        }
        
        /* ========================================
           MIXER SECTION (BOTTOM 30%)
           ======================================== */
        
        .mixer-section {
            height: 340px;
            background-color: var(--daw-bg-secondary);
            border-top: 2px solid var(--daw-border);
            display: flex;
            flex-direction: column;
        }
        
        .mixer-header {
            padding: 12px 24px;
            border-bottom: 1px solid var(--daw-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .mixer-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--daw-text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .add-track-btn {
            padding: 6px 16px;
            border-radius: 6px;
            border: 1px solid var(--daw-border);
            background-color: var(--daw-bg-tertiary);
            color: var(--daw-text-primary);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .add-track-btn:hover {
            background-color: var(--daw-accent);
            color: #000;
            border-color: var(--daw-accent);
        }
        
        .mixer-channels {
            flex: 1;
            display: flex;
            padding: 16px;
            gap: 8px;
            overflow-x: auto;
            overflow-y: auto;
        }
        
        .channel-strip {
            width: 90px;
            background-color: var(--daw-bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--daw-border);
            display: flex;
            flex-direction: column;
            padding: 12px 8px;
            gap: 8px;
            flex-shrink: 0;
        }
        
        .channel-strip.master {
            background-color: var(--daw-bg-header);
            border: 2px solid var(--daw-accent);
            width: 90px;
        }
        
        .channel-label {
            font-size: 11px;
            font-weight: 600;
            text-align: center;
            color: var(--daw-text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .channel-label.narration {
            color: var(--track-narration);
        }
        
        .channel-label.music {
            color: var(--track-music);
        }
        
        .channel-label.sfx {
            color: var(--track-sfx);
        }
        
        .channel-label.master {
            color: var(--daw-accent);
        }
        
        .led-meter {
            height: 60px;
            width: 100%;
            background-color: var(--daw-bg-primary);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column-reverse;
            gap: 1px;
            padding: 2px;
        }
        
        .led-segment {
            height: 3px;
            background-color: var(--led-off);
            border-radius: 2px;
            transition: background-color 0.05s;
        }
        
        .led-segment.active.green {
            background-color: var(--led-green);
        }
        
        .led-segment.active.yellow {
            background-color: var(--led-yellow);
        }
        
        .led-segment.active.red {
            background-color: var(--led-red);
        }
        
        .fader-container {
            flex: 1;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            padding: 12px 0;
            position: relative;
            gap: 6px;
            min-height: 180px;
        }
        
        .fader-track {
            width: 6px;
            height: 100%;
            background: linear-gradient(to bottom, #2a2a2a 0%, #1a1a1a 100%);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }
        
        .fader-thumb {
            width: 24px;
            height: 32px;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            cursor: grab;
            background: linear-gradient(to bottom,
                #666 0%,
                #444 12.5%,
                #333 12.5%,
                #333 25%,
                #555 25%,
                #555 37.5%,
                #333 37.5%,
                #333 50%,
                #555 50%,
                #555 62.5%,
                #333 62.5%,
                #333 75%,
                #555 75%,
                #555 87.5%,
                #333 87.5%,
                #333 100%
            );
            border-radius: 3px;
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
            border: 1px solid #1a1a1a;
            z-index: 20;
        }
        
        .fader-thumb::before {
            content: '';
            position: absolute;
            left: 2px;
            right: 2px;
            top: 50%;
            transform: translateY(-50%);
            height: 2px;
            background-color: #00d4ff;
            box-shadow: 0 0 4px rgba(0, 212, 255, 0.8);
            border-radius: 1px;
        }
        
        .fader-thumb:hover {
            background: linear-gradient(to bottom,
                #777 0%,
                #555 12.5%,
                #444 12.5%,
                #444 25%,
                #666 25%,
                #666 37.5%,
                #444 37.5%,
                #444 50%,
                #666 50%,
                #666 62.5%,
                #444 62.5%,
                #444 75%,
                #666 75%,
                #666 87.5%,
                #444 87.5%,
                #444 100%
            );
        }
        
        .fader-thumb:active {
            cursor: grabbing;
            box-shadow: 
                0 1px 2px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
        }
        
        .fader-scale {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100%;
            font-size: 9px;
            color: var(--daw-text-primary);
            line-height: 1;
            padding: 2px 0;
            z-index: 1;
        }
        
        .fader-scale-mark {
            display: flex;
            align-items: center;
            gap: 3px;
            height: 0;
            position: relative;
        }
        
        .fader-scale-tick {
            width: 5px;
            height: 1px;
            background-color: var(--daw-text-primary);
            opacity: 0.8;
        }
        
        .fader-scale-label {
            font-size: 9px;
            font-weight: 600;
            color: var(--daw-text-primary);
            opacity: 0.9;
        }
        
        .channel-controls {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding-top: 4px;
            border-top: 1px solid var(--daw-border);
        }
        
        .ms-btn {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid var(--daw-border);
            background-color: var(--daw-bg-primary);
            color: var(--daw-text-dim);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
            transition: all 0.2s;
        }
        
        .ms-btn:hover {
            border-color: var(--daw-accent);
            color: var(--daw-text-primary);
        }
        
        .ms-btn.active {
            background-color: var(--daw-accent);
            color: #000;
            border-color: var(--daw-accent);
        }
        
        .ms-btn.mute.active {
            background-color: #EF4444;
            color: white;
            border-color: #EF4444;
        }
        
        .ms-btn.solo.active {
            background-color: #EAB308;
            color: #000;
            border-color: #EAB308;
        }
        
        .effects-btn {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid var(--daw-border);
            background-color: var(--daw-bg-primary);
            color: var(--daw-text-dim);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .effects-btn:hover {
            border-color: var(--daw-accent);
            color: var(--daw-text-primary);
        }
        
        .effects-btn.active {
            background-color: var(--track-music);
            color: white;
            border-color: var(--track-music);
        }
        
        /* ========================================
           UTILITIES
           ======================================== */
        
        .hidden {
            display: none !important;
        }
        
        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 14px;
            height: 14px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--daw-bg-primary);
            border-left: 1px solid var(--daw-border);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--daw-bg-tertiary);
            border-radius: 6px;
            border: 2px solid var(--daw-bg-primary);
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--daw-border);
        }
        
        /* Enhanced scrollbar for timeline wrapper */
        .timeline-canvas-wrapper::-webkit-scrollbar {
            width: 16px;
            height: 14px;
        }
        
        .timeline-canvas-wrapper::-webkit-scrollbar-track {
            background: var(--daw-bg-secondary);
            border-left: 2px solid var(--daw-border);
        }
        
        .timeline-canvas-wrapper::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, #555, #333);
            border-radius: 8px;
            border: 3px solid var(--daw-bg-secondary);
        }
        
        .timeline-canvas-wrapper::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, #666, #444);
        }
    </style>
</head>
<body>
    <div class="daw-container" id="dawContainer">
        <!-- ========================================
             HEADER / TRANSPORT CONTROLS
             ======================================== -->
        <div class="daw-header">
            <div class="daw-title">
                <i class="fas fa-sliders-h"></i>
                Professional Audio DAW
            </div>
            
            <div class="transport-controls">
                <button class="transport-btn" id="seekStartBtn" title="Go to Start">
                    <i class="fas fa-step-backward"></i>
                </button>
                <button class="transport-btn play" id="playBtn" title="Play (Space)">
                    <i class="fas fa-play"></i>
                </button>
                <button class="transport-btn stop" id="stopBtn" title="Stop">
                    <i class="fas fa-stop"></i>
                </button>
                <button class="transport-btn" id="loopBtn" title="Loop">
                    <i class="fas fa-repeat"></i>
                </button>
                
                <div class="time-display">
                    <span id="currentTime">00:00.0</span>
                    <span style="color: var(--daw-text-dim);">/</span>
                    <span id="totalTime">00:00.0</span>
                </div>
                
                <div class="bpm-display">
                    BPM: <span id="bpmValue">120</span>
                </div>
            </div>
            
            <div class="header-actions">
                <button class="action-btn" id="exportBtn">
                    <i class="fas fa-download"></i>
                    Export
                </button>
                <button class="action-btn" id="sendToCoverBtn">
                    <i class="fas fa-image"></i>
                    Send to Cover
                </button>
                <button class="theme-toggle" id="themeToggle" title="Toggle Dark/Light Mode">
                    <i class="fas fa-sun"></i>
                </button>
                <button class="action-btn primary" id="closeBtn">
                    <i class="fas fa-times"></i>
                    Close
                </button>
            </div>
        </div>
        
        <!-- ========================================
             TIMELINE SECTION (TOP)
             ======================================== -->
        <div class="timeline-section">
            <div class="timeline-toolbar">
                <div class="toolbar-group">
                    <span class="zoom-label">Tools:</span>
                    <button class="tool-btn active" id="selectTool" title="Select (V)">
                        <i class="fas fa-mouse-pointer"></i>
                    </button>
                    <button class="tool-btn" id="handTool" title="Hand (H)">
                        <i class="fas fa-hand-paper"></i>
                    </button>
                    <button class="tool-btn" id="cutTool" title="Cut (C)">
                        <i class="fas fa-cut"></i>
                    </button>
                </div>
                
                <div class="toolbar-divider"></div>
                
                <div class="toolbar-group">
                    <button class="tool-btn" id="copyBtn" title="Copy (Ctrl+C)">
                        <i class="fas fa-copy"></i>
                    </button>
                    <button class="tool-btn" id="pasteBtn" title="Paste (Ctrl+V)">
                        <i class="fas fa-paste"></i>
                    </button>
                    <button class="tool-btn" id="deleteBtn" title="Delete (Del)">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
                
                <div class="toolbar-divider"></div>
                
                <div class="toolbar-group">
                    <span class="zoom-label">Zoom: <span id="zoomLevel">100%</span></span>
                    <button class="tool-btn" id="zoomOutBtn" title="Zoom Out (-)">
                        <i class="fas fa-search-minus"></i>
                    </button>
                    <button class="tool-btn" id="zoomInBtn" title="Zoom In (+)">
                        <i class="fas fa-search-plus"></i>
                    </button>
                    <button class="tool-btn" id="fitToViewBtn" title="Fit to View">
                        <i class="fas fa-expand-arrows-alt"></i>
                    </button>
                </div>
            </div>
            
            <div class="timeline-canvas-wrapper">
                <div class="timeline-ruler" id="timelineRuler">
                    <!-- Time markers will be drawn here -->
                </div>
                
                <div class="timeline-tracks" id="timelineTracks">
                    <!-- Track rows will be generated dynamically -->
                </div>
                
                <div id="playhead"></div>
            </div>
        </div>
        
        <!-- ========================================
             MIXER SECTION (BOTTOM)
             ======================================== -->
        <div class="mixer-section">
            <div class="mixer-header">
                <div class="mixer-title">
                    <i class="fas fa-sliders-h"></i>
                    Mixer
                </div>
                <button class="add-track-btn" id="addTrackBtn">
                    <i class="fas fa-plus"></i>
                    Add Track
                </button>
            </div>
            
            <div class="mixer-channels" id="mixerChannels">
                <!-- Channel strips will be generated dynamically -->
            </div>
        </div>
    </div>
    
    <script>
        /* ========================================
           MOZART-STYLE DAW - JAVASCRIPT
           ======================================== */
        
        // DAW State
        const dawState = {
            theme: 'dark',
            isPlaying: false,
            currentTime: 0,
            totalDuration: 0,
            bpm: 120,
            zoom: 1.0,
            tracks: [
                { id: 'narration', name: 'Narration', type: 'narration', icon: 'üéôÔ∏è', color: 'narration', clips: [], muted: false, solo: false, volume: 1.0, effects: {} },
                { id: 'music1', name: 'Music 1', type: 'music', icon: 'üéµ', color: 'music', clips: [], muted: false, solo: false, volume: 1.0, effects: {} },
                { id: 'music2', name: 'Music 2', type: 'music', icon: 'üéµ', color: 'music', clips: [], muted: false, solo: false, volume: 1.0, effects: {} },
                { id: 'sfx1', name: 'SFX 1', type: 'sfx', icon: 'üîä', color: 'sfx', clips: [], muted: false, solo: false, volume: 1.0, effects: {} },
                { id: 'sfx2', name: 'SFX 2', type: 'sfx', icon: 'üîä', color: 'sfx', clips: [], muted: false, solo: false, volume: 1.0, effects: {} }
            ],
            selectedTool: 'select',
            selectedClips: []
        };
        
        // ========================================
        // INITIALIZATION
        // ========================================
        
        function initializeDAW() {
            console.log('üéöÔ∏è Initializing Mozart-style DAW...');
            
            // Render tracks
            renderTracks();
            
            // Render mixer channels
            renderMixerChannels();
            
            // Setup event listeners
            setupEventListeners();
            
            // Initialize LED meters animation
            startLEDMeterAnimation();
            
            console.log('‚úÖ DAW initialized successfully');
        }
        
        // ========================================
        // RENDER FUNCTIONS
        // ========================================
        
        function renderTracks() {
            const tracksContainer = document.getElementById('timelineTracks');
            tracksContainer.innerHTML = '';
            
            dawState.tracks.forEach(track => {
                const trackRow = document.createElement('div');
                trackRow.className = 'track-row';
                trackRow.dataset.trackId = track.id;
                
                trackRow.innerHTML = `
                    <div class="track-header">
                        <div class="track-name" ondblclick="editTrackName('${track.id}')">
                            <span class="track-icon ${track.color}">${track.icon}</span>
                            <span class="track-name-text">${track.name}</span>
                        </div>
                    </div>
                    <div class="track-canvas ${track.color}" data-track-id="${track.id}"
                         ondrop="handleTrackDrop(event, '${track.id}')"
                         ondragover="handleTrackDragOver(event)"
                         ondragenter="handleTrackDragEnter(event)"
                         ondragleave="handleTrackDragLeave(event)">
                        <!-- Audio clips will be rendered here -->
                    </div>
                `;
                
                tracksContainer.appendChild(trackRow);
            });
            
            // Also render timeline ruler
            renderTimelineRuler();
        }
        
        function renderTimelineRuler() {
            const ruler = document.getElementById('timelineRuler');
            ruler.innerHTML = '';
            
            // Calculate timeline width based on total duration + generous buffer
            const pixelsPerSecond = 50 * dawState.zoom;
            const bufferTime = 30; // 30 seconds of empty space after last clip
            const totalDuration = Math.max(60, dawState.totalDuration + bufferTime);
            const timelineWidth = totalDuration * pixelsPerSecond;
            
            // Set explicit width for ruler and all track canvases
            ruler.style.width = `${timelineWidth}px`;
            ruler.style.minWidth = `${timelineWidth}px`;
            
            // Set width on timeline tracks container
            const tracksContainer = document.getElementById('timelineTracks');
            if (tracksContainer) {
                tracksContainer.style.width = `${timelineWidth + 200}px`; // +200 for headers
                tracksContainer.style.minWidth = `${timelineWidth + 200}px`;
            }
            
            // Update all track rows to extend full width
            document.querySelectorAll('.track-row').forEach(row => {
                row.style.width = `${timelineWidth + 200}px`; // +200 for headers
                row.style.minWidth = `${timelineWidth + 200}px`;
            });
            
            // Update all track canvas widths
            document.querySelectorAll('.track-canvas').forEach(canvas => {
                canvas.style.width = `${timelineWidth}px`;
                canvas.style.minWidth = `${timelineWidth}px`;
            });
            
            // Add special marker at 0:00 (timeline start)
            const zeroMarker = document.createElement('div');
            zeroMarker.style.position = 'absolute';
            zeroMarker.style.left = '0px';
            zeroMarker.style.top = '0';
            zeroMarker.style.width = '2px';
            zeroMarker.style.height = '100%';
            zeroMarker.style.backgroundColor = 'var(--daw-accent)'; // Cyan to stand out
            zeroMarker.style.zIndex = '10';
            
            const zeroLabel = document.createElement('div');
            zeroLabel.style.position = 'absolute';
            zeroLabel.style.left = '6px';
            zeroLabel.style.top = '6px';
            zeroLabel.style.fontSize = '12px';
            zeroLabel.style.fontWeight = 'bold';
            zeroLabel.style.color = 'var(--daw-accent)';
            zeroLabel.style.fontFamily = 'monospace';
            zeroLabel.textContent = '0:00';
            
            ruler.appendChild(zeroMarker);
            ruler.appendChild(zeroLabel);
            
            // Determine marker interval (every 5 or 10 seconds depending on zoom)
            const markerInterval = dawState.zoom < 0.5 ? 10 : 5;
            
            for (let seconds = markerInterval; seconds <= totalDuration; seconds += markerInterval) {
                const marker = document.createElement('div');
                marker.style.position = 'absolute';
                marker.style.left = (seconds * pixelsPerSecond) + 'px';
                marker.style.top = '0';
                marker.style.width = '1px';
                marker.style.height = '100%';
                marker.style.backgroundColor = 'var(--grid-line-major)';
                
                const label = document.createElement('div');
                label.style.position = 'absolute';
                label.style.left = (seconds * pixelsPerSecond + 4) + 'px';
                label.style.top = '6px';
                label.style.fontSize = '11px';
                label.style.color = 'var(--daw-text-secondary)';
                label.style.fontFamily = 'monospace';
                label.textContent = formatTime(seconds);
                
                ruler.appendChild(marker);
                ruler.appendChild(label);
            }
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60); // Round down to whole seconds
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function renderMixerChannels() {
            const mixerContainer = document.getElementById('mixerChannels');
            mixerContainer.innerHTML = '';
            
            // Render regular tracks
            dawState.tracks.forEach(track => {
                const channelStrip = createChannelStrip(track);
                mixerContainer.appendChild(channelStrip);
            });
            
            // Render master channel
            const masterChannel = createMasterChannel();
            mixerContainer.appendChild(masterChannel);
        }
        
        function createChannelStrip(track) {
            const strip = document.createElement('div');
            strip.className = 'channel-strip';
            strip.dataset.trackId = track.id;
            
            // Create LED meter segments
            let ledSegmentsHTML = '';
            for (let i = 0; i < 15; i++) {
                const segmentClass = i < 10 ? 'green' : (i < 13 ? 'yellow' : 'red');
                ledSegmentsHTML += `<div class="led-segment ${segmentClass}" data-level="${i}"></div>`;
            }
            
            strip.innerHTML = `
                <div class="channel-label ${track.color}">${track.icon} ${track.name}</div>
                <div class="led-meter" data-track-id="${track.id}">
                    ${ledSegmentsHTML}
                </div>
                <div class="fader-container">
                    <div class="fader-track">
                        <div class="fader-thumb" data-track-id="${track.id}" style="bottom: ${track.volume * 100}%;"></div>
                    </div>
                    <div class="fader-scale">
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">0</span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">10</span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">20</span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">30</span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">40</span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">50</span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">60</span></div>
                    </div>
                </div>
                <div class="channel-controls">
                    <button class="ms-btn mute" data-track-id="${track.id}" data-action="mute" title="Mute">M</button>
                    <button class="ms-btn solo" data-track-id="${track.id}" data-action="solo" title="Solo">S</button>
                    <button class="effects-btn" data-track-id="${track.id}" title="Effects">
                        <i class="fas fa-magic"></i>
                    </button>
                </div>
            `;
            
            return strip;
        }
        
        function createMasterChannel() {
            const strip = document.createElement('div');
            strip.className = 'channel-strip master';
            
            let ledSegmentsHTML = '';
            for (let i = 0; i < 15; i++) {
                const segmentClass = i < 10 ? 'green' : (i < 13 ? 'yellow' : 'red');
                ledSegmentsHTML += `<div class="led-segment ${segmentClass}" data-level="${i}"></div>`;
            }
            
            strip.innerHTML = `
                <div class="channel-label master">üéõÔ∏è MASTER</div>
                <div class="led-meter" data-track-id="master">
                    ${ledSegmentsHTML}
                </div>
                <div class="fader-container">
                    <div class="fader-track">
                        <div class="fader-thumb" data-track-id="master" style="bottom: 100%;"></div>
                    </div>
                    <div class="fader-scale">
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">0</span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">10</span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">20</span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">30</span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">40</span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">50</span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span></div>
                        <div class="fader-scale-mark"><span class="fader-scale-tick"></span><span class="fader-scale-label">60</span></div>
                    </div>
                </div>
                <div class="channel-controls" style="visibility: hidden;">
                    <!-- Master doesn't have M/S buttons -->
                </div>
            `;
            
            return strip;
        }
        
        // ========================================
        // EVENT LISTENERS
        // ========================================
        
        function setupEventListeners() {
            // Theme toggle
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            
            // Transport controls
            document.getElementById('playBtn').addEventListener('click', togglePlay);
            document.getElementById('stopBtn').addEventListener('click', stop);
            document.getElementById('seekStartBtn').addEventListener('click', seekToStart);
            document.getElementById('loopBtn').addEventListener('click', toggleLoop);
            
            // Header actions
            document.getElementById('exportBtn').addEventListener('click', exportAudio);
            document.getElementById('sendToCoverBtn').addEventListener('click', sendToCover);
            document.getElementById('closeBtn').addEventListener('click', closeDaw);
            
            // Toolbar tools
            document.getElementById('selectTool').addEventListener('click', () => setTool('select'));
            document.getElementById('handTool').addEventListener('click', () => setTool('hand'));
            document.getElementById('cutTool').addEventListener('click', () => setTool('cut'));
            
            // Edit actions
            document.getElementById('copyBtn').addEventListener('click', copySelected);
            document.getElementById('pasteBtn').addEventListener('click', paste);
            document.getElementById('deleteBtn').addEventListener('click', deleteSelected);
            
            // Zoom controls
            document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
            document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
            document.getElementById('fitToViewBtn').addEventListener('click', fitToView);
            
            // Add track
            document.getElementById('addTrackBtn').addEventListener('click', addTrack);
            
            // Faders (delegate to parent)
            document.getElementById('mixerChannels').addEventListener('mousedown', handleFaderMouseDown);
            
            // M/S buttons (delegate to parent)
            document.getElementById('mixerChannels').addEventListener('click', handleMixerButtonClick);
            
            // Timeline click-to-seek
            const timelineRuler = document.getElementById('timelineRuler');
            timelineRuler.addEventListener('click', handleTimelineClick);
            
            document.getElementById('timelineTracks').addEventListener('click', handleTimelineClick);
            
            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboard);
        }
        
        function handleTimelineClick(e) {
            // Don't seek if clicking on a clip
            if (e.target.closest('.audio-clip')) return;
            
            const timelineWrapper = document.querySelector('.timeline-canvas-wrapper');
            const rect = timelineWrapper.getBoundingClientRect();
            const clickX = e.clientX - rect.left - 200; // Subtract track header width
            
            // Calculate time based on click position and zoom
            const pixelsPerSecond = 50 * dawState.zoom;
            const clickTime = Math.max(0, clickX / pixelsPerSecond);
            
            // Update playhead position
            dawState.currentTime = Math.max(0, Math.min(clickTime, dawState.totalDuration));
            updatePlayheadPosition(dawState.currentTime);
            document.getElementById('currentTime').textContent = formatTime(dawState.currentTime);
            
            // If playing, restart from new position
            if (dawState.isPlaying) {
                pauseTime = dawState.currentTime;
                stopAllSources();
                playAllTracks();
            } else {
                pauseTime = dawState.currentTime;
            }
            
            console.log(`‚è© Seek to: ${dawState.currentTime.toFixed(2)}s`);
        }
        
        // ========================================
        // THEME TOGGLE
        // ========================================
        
        function toggleTheme() {
            dawState.theme = dawState.theme === 'dark' ? 'light' : 'dark';
            document.getElementById('dawContainer').dataset.theme = dawState.theme;
            
            const icon = document.querySelector('#themeToggle i');
            icon.className = dawState.theme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
            
            console.log(`üé® Theme switched to: ${dawState.theme}`);
        }
        
        // ========================================
        // AUDIO ENGINE - Web Audio API
        // ========================================
        
        let audioContext = null;
        let audioSources = [];
        let startTime = 0;
        let pauseTime = 0;
        let analyserNodes = {};
        let gainNodes = {};
        let masterGainNode = null;
        let animationFrameId = null;
        
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGainNode = audioContext.createGain();
                masterGainNode.gain.value = 1.5; // 1.5x boost for master output
                masterGainNode.connect(audioContext.destination);
                console.log('üéß AudioContext initialized with boosted gain');
            }
            return audioContext;
        }
        
        async function decodeAudioClip(clip) {
            if (clip.audioBuffer) return clip.audioBuffer;
            
            try {
                const ctx = initAudioContext();
                
                // Convert data URL to ArrayBuffer
                const response = await fetch(clip.data);
                const arrayBuffer = await response.arrayBuffer();
                
                // Decode audio data
                const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
                clip.audioBuffer = audioBuffer;
                
                console.log(`üéµ Decoded: ${clip.name} (${audioBuffer.duration.toFixed(2)}s)`);
                return audioBuffer;
            } catch (error) {
                console.error(`‚ùå Error decoding ${clip.name}:`, error);
                return null;
            }
        }
        
        async function playAllTracks() {
            const ctx = initAudioContext();
            
            // Resume audio context if suspended (browser autoplay policy)
            if (ctx.state === 'suspended') {
                await ctx.resume();
            }
            
            // Stop any existing playback
            stopAllSources();
            
            // Create gain nodes and analysers for each track
            dawState.tracks.forEach(track => {
                if (!gainNodes[track.id]) {
                    const gainNode = ctx.createGain();
                    const analyser = ctx.createAnalyser();
                    analyser.fftSize = 256;
                    
                    gainNode.connect(analyser);
                    analyser.connect(masterGainNode);
                    
                    gainNodes[track.id] = gainNode;
                    analyserNodes[track.id] = analyser;
                }
                
                // Update gain based on track volume and mute/solo
                // Apply 2x boost for louder output (track.volume is 0-1, multiply by 2 for 0-2 range)
                const shouldPlay = !track.muted && (!dawState.tracks.some(t => t.solo) || track.solo);
                const boostedVolume = track.volume * 2.0; // 2x louder
                gainNodes[track.id].gain.value = shouldPlay ? boostedVolume : 0;
            });
            
            // Schedule all clips
            const currentTime = pauseTime || 0;
            startTime = ctx.currentTime - currentTime;
            
            for (const track of dawState.tracks) {
                for (const clip of track.clips) {
                    // Decode audio if not already decoded
                    const audioBuffer = await decodeAudioClip(clip);
                    if (!audioBuffer) continue;
                    
                    // Skip clips that have already finished playing
                    if (currentTime >= clip.startTime + clip.duration) continue;
                    
                    // Create buffer source
                    const source = ctx.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(gainNodes[track.id]);
                    
                    // Calculate when to start this clip
                    const clipStartTime = Math.max(0, clip.startTime - currentTime);
                    const offset = Math.max(0, currentTime - clip.startTime);
                    
                    // Start playback
                    if (offset < audioBuffer.duration) {
                        source.start(ctx.currentTime + clipStartTime, offset);
                        audioSources.push(source);
                        console.log(`‚ñ∂Ô∏è Playing: ${clip.name} on ${track.name}`);
                    }
                }
            }
            
            // Start time update loop
            updatePlaybackTime();
            updateLEDMetersWithRealAudio();
        }
        
        function stopAllSources() {
            audioSources.forEach(source => {
                try {
                    source.stop();
                } catch (e) {
                    // Source might already be stopped
                }
            });
            audioSources = [];
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        function updatePlaybackTime() {
            if (!dawState.isPlaying) return;
            
            const ctx = audioContext;
            if (ctx) {
                const elapsed = ctx.currentTime - startTime;
                dawState.currentTime = elapsed;
                document.getElementById('currentTime').textContent = formatTime(elapsed);
                
                // Update playhead position
                updatePlayheadPosition(elapsed);
                
                // Check if playback finished
                if (elapsed >= dawState.totalDuration) {
                    const loopBtn = document.getElementById('loopBtn');
                    if (loopBtn.classList.contains('active')) {
                        // Loop: restart playback
                        pauseTime = 0;
                        playAllTracks();
                    } else {
                        // Stop at end
                        stop();
                        return;
                    }
                }
            }
            
            animationFrameId = requestAnimationFrame(updatePlaybackTime);
        }
        
        function updatePlayheadPosition(currentTime) {
            const playhead = document.getElementById('playhead');
            if (!playhead) return;
            
            // Calculate playhead position based on time and zoom
            // Using 50px per second as base (same as clip rendering)
            const pixelsPerSecond = 50 * dawState.zoom;
            const position = 200 + (currentTime * pixelsPerSecond); // 200px offset for track headers
            
            playhead.style.left = `${position}px`;
            playhead.style.display = 'block';
            
            // Auto-scroll timeline to follow playhead during playback
            if (dawState.isPlaying) {
                const timelineWrapper = document.querySelector('.timeline-canvas-wrapper');
                if (timelineWrapper) {
                    const wrapperWidth = timelineWrapper.clientWidth;
                    const playheadPosition = currentTime * pixelsPerSecond; // Position relative to content
                    const currentScroll = timelineWrapper.scrollLeft;
                    
                    // Define scroll margins (keep playhead in center 60% of viewport)
                    const leftMargin = wrapperWidth * 0.2;
                    const rightMargin = wrapperWidth * 0.8;
                    
                    const playheadViewportPos = playheadPosition - currentScroll;
                    
                    // Scroll if playhead goes beyond margins
                    if (playheadViewportPos > rightMargin) {
                        timelineWrapper.scrollLeft = playheadPosition - (wrapperWidth / 2);
                    } else if (playheadViewportPos < leftMargin && currentScroll > 0) {
                        timelineWrapper.scrollLeft = playheadPosition - (wrapperWidth / 2);
                    }
                }
            }
        }
        
        function updateLEDMetersWithRealAudio() {
            if (!dawState.isPlaying) return;
            
            let masterLevel = 0;
            let activeTracks = 0;
            
            document.querySelectorAll('.led-meter').forEach(meter => {
                const trackId = meter.dataset.trackId;
                
                // Handle master track specially - combine all track signals
                if (trackId === 'master') {
                    // Calculate combined level from all tracks
                    let combinedLevel = 0;
                    let trackCount = 0;
                    
                    dawState.tracks.forEach(track => {
                        const analyser = analyserNodes[track.id];
                        if (analyser && !track.muted) {
                            const dataArray = new Uint8Array(analyser.frequencyBinCount);
                            analyser.getByteFrequencyData(dataArray);
                            
                            const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                            const rawLevel = (average / 255) * 15 * 6.0;
                            const scaledLevel = rawLevel * track.volume;
                            
                            combinedLevel += scaledLevel;
                            trackCount++;
                        }
                    });
                    
                    // Average the combined levels and apply master volume
                    if (trackCount > 0) {
                        const avgLevel = combinedLevel / trackCount;
                        masterLevel = Math.min(15, Math.floor(avgLevel * dawState.masterVolume));
                    }
                    
                    const segments = meter.querySelectorAll('.led-segment');
                    segments.forEach((segment, index) => {
                        if (index < masterLevel) {
                            segment.classList.add('active');
                        } else {
                            segment.classList.remove('active');
                        }
                    });
                } else {
                    // Regular track meters
                    const analyser = analyserNodes[trackId];
                    
                    if (analyser) {
                        const dataArray = new Uint8Array(analyser.frequencyBinCount);
                        analyser.getByteFrequencyData(dataArray);
                        
                        // Calculate average level
                        const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                        
                        // Get track volume to scale LED display
                        const track = dawState.tracks.find(t => t.id === trackId);
                        const trackVolume = track ? track.volume : 1.0;
                        
                        // Apply volume scaling with 6x boost for high visibility
                        // Higher fader = more LEDs light up
                        // With 2x volume boost, this ensures LEDs reach yellow/red zones
                        const rawLevel = (average / 255) * 15 * 6.0; // 6x boost (doubled from 3x)
                        const level = Math.min(15, Math.floor(rawLevel * trackVolume));
                        
                        const segments = meter.querySelectorAll('.led-segment');
                        segments.forEach((segment, index) => {
                            if (index < level) {
                                segment.classList.add('active');
                            } else {
                                segment.classList.remove('active');
                            }
                        });
                    }
                }
            });
            
            requestAnimationFrame(updateLEDMetersWithRealAudio);
        }
        
        // ========================================
        // TRANSPORT CONTROLS
        // ========================================
        
        let isTogglingPlay = false;
        
        function togglePlay() {
            // Prevent rapid clicking
            if (isTogglingPlay) return;
            isTogglingPlay = true;
            
            dawState.isPlaying = !dawState.isPlaying;
            const icon = document.querySelector('#playBtn i');
            if (icon) {
                icon.className = dawState.isPlaying ? 'fas fa-pause' : 'fas fa-play';
            }
            
            if (dawState.isPlaying) {
                console.log('‚ñ∂Ô∏è Playing...');
                playAllTracks().then(() => {
                    isTogglingPlay = false;
                }).catch(err => {
                    console.error('Playback error:', err);
                    isTogglingPlay = false;
                });
            } else {
                console.log('‚è∏Ô∏è Paused');
                pauseTime = dawState.currentTime;
                stopAllSources();
                isTogglingPlay = false;
            }
        }
        
        function stop() {
            // Prevent double-stopping
            if (!dawState.isPlaying && dawState.currentTime === 0 && pauseTime === 0) {
                return;
            }
            
            dawState.isPlaying = false;
            dawState.currentTime = 0;
            pauseTime = 0;
            stopAllSources();
            
            const playBtn = document.querySelector('#playBtn i');
            if (playBtn) {
                playBtn.className = 'fas fa-play';
            }
            
            const timeDisplay = document.getElementById('currentTime');
            if (timeDisplay) {
                timeDisplay.textContent = '0:00';
            }
            
            // Reset playhead position to start (with offset)
            updatePlayheadPosition(0);
            
            // Reset LED meters
            document.querySelectorAll('.led-segment').forEach(seg => seg.classList.remove('active'));
            
            console.log('‚èπÔ∏è Stopped');
        }
        
        function seekToStart() {
            const wasPlaying = dawState.isPlaying;
            
            // Stop all playback and reset position
            dawState.isPlaying = false;
            dawState.currentTime = 0;
            pauseTime = 0;
            stopAllSources();
            
            // Update UI
            const playBtn = document.querySelector('#playBtn i');
            if (playBtn && !wasPlaying) {
                playBtn.className = 'fas fa-play';
            }
            
            const timeDisplay = document.getElementById('currentTime');
            if (timeDisplay) {
                timeDisplay.textContent = '0:00';
            }
            
            updatePlayheadPosition(0);
            
            // If was playing, restart playback from beginning
            if (wasPlaying) {
                dawState.isPlaying = true;
                if (playBtn) {
                    playBtn.className = 'fas fa-pause';
                }
                // Use requestAnimationFrame for smoother restart
                requestAnimationFrame(() => {
                    playAllTracks();
                });
            }
            
            console.log('‚èÆÔ∏è Seek to start');
        }
        
        function toggleLoop() {
            const btn = document.getElementById('loopBtn');
            btn.classList.toggle('active');
            console.log('üîÅ Loop:', btn.classList.contains('active'));
        }
        
        // ========================================
        // TRACK EDITING
        // ========================================
        
        function editTrackName(trackId) {
            const track = dawState.tracks.find(t => t.id === trackId);
            if (!track) return;
            
            const trackNameEl = document.querySelector(`.track-row[data-track-id="${trackId}"] .track-name-text`);
            const currentName = trackNameEl.textContent;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'track-name-input';
            input.value = currentName;
            
            input.addEventListener('blur', () => {
                track.name = input.value || currentName;
                renderTracks();
                renderMixerChannels();
                setupEventListeners();
            });
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') input.blur();
                if (e.key === 'Escape') {
                    input.value = currentName;
                    input.blur();
                }
            });
            
            trackNameEl.replaceWith(input);
            input.focus();
            input.select();
        }
        
        function addTrack() {
            const trackCount = dawState.tracks.length;
            const newTrack = {
                id: `track_${Date.now()}`,
                name: `Track ${trackCount + 1}`,
                type: 'audio',
                icon: 'üéµ',
                color: 'music',
                clips: [],
                muted: false,
                solo: false,
                volume: 1.0,
                effects: {}
            };
            
            dawState.tracks.push(newTrack);
            renderTracks();
            renderMixerChannels();
            setupEventListeners();
            
            console.log('‚ûï Added new track:', newTrack.name);
        }
        
        // ========================================
        // MIXER CONTROLS
        // ========================================
        
        function handleFaderMouseDown(e) {
            if (!e.target.classList.contains('fader-thumb')) return;
            
            const trackId = e.target.dataset.trackId;
            const faderTrack = e.target.parentElement;
            const trackRect = faderTrack.getBoundingClientRect();
            
            function onMouseMove(moveEvent) {
                const y = moveEvent.clientY - trackRect.top;
                const height = trackRect.height;
                let volume = 1 - (y / height);
                volume = Math.max(0, Math.min(1, volume));
                
                e.target.style.bottom = `${volume * 100}%`;
                
                // Update track volume
                if (trackId === 'master') {
                    const boostedMasterVolume = volume * 2.0; // Allow 0-2x range for master
                    console.log(`üéõÔ∏è Master volume: ${(volume * 100).toFixed(0)}% (${(boostedMasterVolume * 100).toFixed(0)}% actual)`);
                    // Update master gain node
                    if (masterGainNode) {
                        masterGainNode.gain.value = boostedMasterVolume;
                    }
                } else {
                    const track = dawState.tracks.find(t => t.id === trackId);
                    if (track) {
                        track.volume = volume;
                        console.log(`üéõÔ∏è ${track.name} volume: ${(volume * 100).toFixed(0)}%`);
                        
                        // Update gain node in real-time
                        updateTrackGain(trackId);
                    }
                }
            }
            
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            e.preventDefault();
        }
        
        function handleMixerButtonClick(e) {
            const button = e.target.closest('.ms-btn') || e.target.closest('.effects-btn');
            if (!button) return;
            
            const trackId = button.dataset.trackId;
            const action = button.dataset.action;
            
            if (action === 'mute') {
                button.classList.toggle('active');
                const track = dawState.tracks.find(t => t.id === trackId);
                if (track) {
                    track.muted = !track.muted;
                    console.log(`üîá ${track.name} ${track.muted ? 'muted' : 'unmuted'}`);
                    
                    // Update gain node in real-time
                    updateTrackGain(trackId);
                }
            } else if (action === 'solo') {
                button.classList.toggle('active');
                const track = dawState.tracks.find(t => t.id === trackId);
                if (track) {
                    track.solo = !track.solo;
                    console.log(`üéß ${track.name} solo: ${track.solo}`);
                    
                    // Update all tracks when solo changes
                    dawState.tracks.forEach(t => updateTrackGain(t.id));
                }
            } else if (button.classList.contains('effects-btn')) {
                button.classList.toggle('active');
                console.log(`‚ú® Effects for track ${trackId}:`, button.classList.contains('active'));
            }
        }
        
        // Update track gain based on volume, mute, and solo
        function updateTrackGain(trackId) {
            const track = dawState.tracks.find(t => t.id === trackId);
            if (!track || !gainNodes[trackId]) return;
            
            const shouldPlay = !track.muted && (!dawState.tracks.some(t => t.solo) || track.solo);
            const boostedVolume = track.volume * 2.0; // 2x boost for louder output
            const targetGain = shouldPlay ? boostedVolume : 0;
            
            gainNodes[trackId].gain.value = targetGain;
        }
        
        // ========================================
        // LED METERS ANIMATION
        // ========================================
        
        function startLEDMeterAnimation() {
            // LED meters are now updated by updateLEDMetersWithRealAudio() during playback
            // This function kept for compatibility but does nothing
            console.log('üí° LED meters will use real audio data during playback');
        }
        
        // ========================================
        // TOOLBAR ACTIONS
        // ========================================
        
        function setTool(tool) {
            dawState.selectedTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`${tool}Tool`).classList.add('active');
            console.log(`üõ†Ô∏è Tool selected: ${tool}`);
        }
        
        // Clipboard for copy/paste
        let clipboardClips = [];
        
        function updateClipSelection() {
            document.querySelectorAll('.audio-clip').forEach(clipEl => {
                if (clipEl.classList.contains('selected')) {
                    clipEl.style.border = '3px solid #FFD700';
                    clipEl.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
                } else {
                    clipEl.style.border = '2px solid var(--daw-accent)';
                    clipEl.style.boxShadow = 'none';
                }
            });
        }
        
        function copySelected() {
            const selectedClips = document.querySelectorAll('.audio-clip.selected');
            if (selectedClips.length === 0) {
                console.log('‚ö†Ô∏è No clips selected');
                return;
            }
            
            clipboardClips = [];
            selectedClips.forEach(clipEl => {
                const clipId = clipEl.dataset.clipId;
                const clip = findClipById(clipId);
                if (clip) {
                    clipboardClips.push(JSON.parse(JSON.stringify(clip))); // Deep copy
                }
            });
            
            console.log(`üìã Copied ${clipboardClips.length} clip(s)`);
        }
        
        function paste() {
            if (clipboardClips.length === 0) {
                console.log('‚ö†Ô∏è Clipboard is empty');
                return;
            }
            
            // Paste clips at current playhead position
            clipboardClips.forEach(clipData => {
                const track = dawState.tracks[0]; // Paste to first track for now
                if (!track) return;
                
                const newClip = {
                    ...clipData,
                    id: `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    startTime: dawState.currentTime
                };
                
                track.clips.push(newClip);
                renderAudioClip(newClip, track.id);
            });
            
            console.log(`üìã Pasted ${clipboardClips.length} clip(s) at ${dawState.currentTime.toFixed(2)}s`);
        }
        
        function deleteSelected() {
            const selectedClips = document.querySelectorAll('.audio-clip.selected');
            if (selectedClips.length === 0) {
                console.log('‚ö†Ô∏è No clips selected');
                return;
            }
            
            let deletedCount = 0;
            selectedClips.forEach(clipEl => {
                const clipId = clipEl.dataset.clipId;
                
                // Find and remove from track
                dawState.tracks.forEach(track => {
                    const index = track.clips.findIndex(c => c.id === clipId);
                    if (index !== -1) {
                        track.clips.splice(index, 1);
                        deletedCount++;
                    }
                });
                
                // Remove from DOM
                clipEl.remove();
            });
            
            console.log(`üóëÔ∏è Deleted ${deletedCount} clip(s)`);
        }
        
        function findClipById(clipId) {
            for (const track of dawState.tracks) {
                const clip = track.clips.find(c => c.id === clipId);
                if (clip) return clip;
            }
            return null;
        }
        
        function zoomIn() {
            dawState.zoom = Math.min(4.0, dawState.zoom + 0.2);
            document.getElementById('zoomLevel').textContent = `${Math.round(dawState.zoom * 100)}%`;
            console.log(`üîç Zoom in: ${dawState.zoom.toFixed(1)}x`);
            
            // Re-render timeline with new zoom
            renderTimelineRuler();
            rerenderAllClips();
            updatePlayheadPosition(dawState.currentTime);
        }
        
        function zoomOut() {
            dawState.zoom = Math.max(0.2, dawState.zoom - 0.2);
            document.getElementById('zoomLevel').textContent = `${Math.round(dawState.zoom * 100)}%`;
            console.log(`üîç Zoom out: ${dawState.zoom.toFixed(1)}x`);
            
            // Re-render timeline with new zoom
            renderTimelineRuler();
            rerenderAllClips();
            updatePlayheadPosition(dawState.currentTime);
        }
        
        function fitToView() {
            dawState.zoom = 1.0;
            document.getElementById('zoomLevel').textContent = '100%';
            console.log('üîç Fit to view');
            
            // Re-render timeline with new zoom
            renderTimelineRuler();
            rerenderAllClips();
            updatePlayheadPosition(dawState.currentTime);
        }
        
        function rerenderAllClips() {
            // Re-render all audio clips with new zoom level
            dawState.tracks.forEach(track => {
                track.clips.forEach(clip => {
                    // Remove old clip element
                    const oldClip = document.querySelector(`.audio-clip[data-clip-id="${clip.id}"]`);
                    if (oldClip) {
                        oldClip.remove();
                    }
                    // Render with new zoom
                    renderAudioClip(clip, track.id);
                });
            });
        }
        
        // ========================================
        // EXPORT & ACTIONS
        // ========================================
        
        function exportAudio() {
            console.log('üíæ Exporting audio...');
            alert('Export functionality will be implemented in integration');
        }
        
        function sendToCover() {
            console.log('üì∏ Sending to cover page...');
            alert('Send to cover functionality will be implemented in integration');
        }
        
        function closeDaw() {
            if (confirm('Close DAW? Any unsaved changes will be lost.')) {
                window.close();
            }
        }
        
        // ========================================
        // DRAG AND DROP FUNCTIONALITY
        // ========================================
        
        function handleTrackDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'copy';
        }
        
        function handleTrackDragEnter(e) {
            e.preventDefault();
            e.stopPropagation();
            const trackCanvas = e.currentTarget;
            trackCanvas.style.outline = '2px dashed var(--daw-accent)';
            trackCanvas.style.backgroundColor = 'rgba(120, 227, 254, 0.1)';
        }
        
        function handleTrackDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            const trackCanvas = e.currentTarget;
            trackCanvas.style.outline = '';
            trackCanvas.style.backgroundColor = '';
        }
        
        function handleTrackDrop(e, trackId) {
            e.preventDefault();
            e.stopPropagation();
            
            const trackCanvas = e.currentTarget;
            trackCanvas.style.outline = '';
            trackCanvas.style.backgroundColor = '';
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                
                // Check if it's an audio file
                if (file.type.startsWith('audio/')) {
                    loadAudioFile(file, trackId);
                } else {
                    alert('Please drop an audio file (MP3, WAV, etc.)');
                    console.warn('‚ö†Ô∏è Invalid file type:', file.type);
                }
            }
        }
        
        function loadAudioFile(file, trackId) {
            console.log(`üéµ Loading audio file: ${file.name} to track: ${trackId}`);
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const audioData = e.target.result;
                
                // Create audio element to get duration
                const audio = new Audio(audioData);
                audio.addEventListener('loadedmetadata', function() {
                    const duration = audio.duration;
                    
                    // Create clip object at current playhead position (never before 0)
                    const clip = {
                        id: `clip_${Date.now()}`,
                        name: file.name,
                        data: audioData,
                        duration: duration,
                        startTime: Math.max(0, dawState.currentTime), // Place at playhead, min 0
                        trackId: trackId
                    };
                    
                    // Add clip to track
                    const track = dawState.tracks.find(t => t.id === trackId);
                    if (track) {
                        track.clips.push(clip);
                        console.log(`‚úÖ Audio loaded: ${file.name} (${duration.toFixed(2)}s)`);
                        
                        // Update total duration if needed
                        const endTime = clip.startTime + clip.duration;
                        if (endTime > dawState.totalDuration) {
                            dawState.totalDuration = endTime;
                            document.getElementById('totalTime').textContent = formatTime(Math.ceil(endTime));
                        }
                        
                        // Re-render tracks to show the clip
                        renderAudioClip(clip, trackId);
                        renderTimelineRuler();
                        
                        // Show notification
                        const trackName = track.name;
                        alert(`‚úÖ Audio added to ${trackName}:\n${file.name}\nDuration: ${duration.toFixed(2)}s`);
                    }
                });
                
                audio.addEventListener('error', function() {
                    console.error('‚ùå Error loading audio file');
                    alert('Error loading audio file. Please try a different file.');
                });
            };
            
            reader.onerror = function() {
                console.error('‚ùå Error reading file');
                alert('Error reading file. Please try again.');
            };
            
            reader.readAsDataURL(file);
        }
        
        function renderAudioClip(clip, trackId) {
            const trackCanvas = document.querySelector(`.track-canvas[data-track-id="${trackId}"]`);
            if (!trackCanvas) return;
            
            // Apply zoom to positioning and sizing
            const pixelsPerSecond = 50 * dawState.zoom;
            
            // Create clip container
            const clipEl = document.createElement('div');
            clipEl.className = 'audio-clip';
            clipEl.dataset.clipId = clip.id;
            clipEl.style.position = 'absolute';
            clipEl.style.left = `${clip.startTime * pixelsPerSecond}px`;
            clipEl.style.top = '10px';
            clipEl.style.width = `${clip.duration * pixelsPerSecond}px`;
            clipEl.style.height = 'calc(100% - 20px)';
            clipEl.style.backgroundColor = 'rgba(30, 30, 30, 0.8)';
            clipEl.style.border = '2px solid var(--daw-accent)';
            clipEl.style.borderRadius = '4px';
            clipEl.style.overflow = 'hidden';
            clipEl.style.cursor = 'pointer';
            clipEl.style.position = 'relative';
            
            // Add click handler for selection
            clipEl.addEventListener('click', function(e) {
                e.stopPropagation();
                
                // Toggle selection
                if (e.ctrlKey || e.metaKey) {
                    // Multi-select with Ctrl/Cmd
                    clipEl.classList.toggle('selected');
                } else {
                    // Single select
                    document.querySelectorAll('.audio-clip').forEach(c => c.classList.remove('selected'));
                    clipEl.classList.add('selected');
                }
                
                updateClipSelection();
            });
            
            // Add drag functionality
            let isDragging = false;
            let dragStartX = 0;
            let clipStartTime = clip.startTime;
            
            clipEl.addEventListener('mousedown', function(e) {
                if (e.button !== 0) return; // Only left mouse button
                
                isDragging = true;
                dragStartX = e.clientX;
                clipStartTime = clip.startTime;
                clipEl.style.cursor = 'grabbing';
                clipEl.style.zIndex = '100';
                
                e.stopPropagation();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging || !clipEl.parentElement) return;
                
                const deltaX = e.clientX - dragStartX;
                const pixelsPerSecond = 50 * dawState.zoom;
                const deltaTime = deltaX / pixelsPerSecond;
                const newStartTime = Math.max(0, clipStartTime + deltaTime);
                
                // Update clip position visually
                clipEl.style.left = `${newStartTime * pixelsPerSecond}px`;
            });
            
            document.addEventListener('mouseup', function(e) {
                if (!isDragging) return;
                
                isDragging = false;
                clipEl.style.cursor = 'pointer';
                clipEl.style.zIndex = '';
                
                // Calculate final position
                const deltaX = e.clientX - dragStartX;
                const pixelsPerSecond = 50 * dawState.zoom;
                const deltaTime = deltaX / pixelsPerSecond;
                const newStartTime = Math.max(0, clipStartTime + deltaTime);
                
                // Update clip data
                clip.startTime = newStartTime;
                
                // Recalculate total duration based on all clips
                let maxEndTime = 0;
                dawState.tracks.forEach(track => {
                    track.clips.forEach(c => {
                        const clipEnd = c.startTime + c.duration;
                        if (clipEnd > maxEndTime) maxEndTime = clipEnd;
                    });
                });
                
                dawState.totalDuration = maxEndTime;
                document.getElementById('totalTime').textContent = formatTime(Math.ceil(maxEndTime));
                
                // Re-render timeline to extend/contract as needed
                renderTimelineRuler();
                
                console.log(`üìç Clip moved to: ${newStartTime.toFixed(2)}s`);
            });
            
            // Create canvas for waveform
            const canvas = document.createElement('canvas');
            canvas.width = clip.duration * pixelsPerSecond; // Match clip width with zoom
            canvas.height = 60; // Fixed height for waveform
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            
            // Create filename label
            const label = document.createElement('div');
            label.style.position = 'absolute';
            label.style.top = '4px';
            label.style.left = '8px';
            label.style.color = 'var(--daw-text-primary)';
            label.style.fontSize = '10px';
            label.style.fontWeight = '600';
            label.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)';
            label.style.pointerEvents = 'none';
            label.style.zIndex = '10';
            label.textContent = clip.name;
            
            clipEl.appendChild(canvas);
            clipEl.appendChild(label);
            trackCanvas.appendChild(clipEl);
            
            // Draw waveform on canvas
            drawWaveform(canvas, clip);
        }
        
        function drawWaveform(canvas, clip) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Create audio context and decode audio
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Convert data URL to ArrayBuffer
            fetch(clip.data)
                .then(response => response.arrayBuffer())
                .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                .then(audioBuffer => {
                    // Get audio data
                    const rawData = audioBuffer.getChannelData(0); // Use first channel
                    const samples = width; // One sample per pixel
                    const blockSize = Math.floor(rawData.length / samples);
                    const filteredData = [];
                    
                    // Downsample the audio data
                    for (let i = 0; i < samples; i++) {
                        let blockStart = blockSize * i;
                        let sum = 0;
                        for (let j = 0; j < blockSize; j++) {
                            sum += Math.abs(rawData[blockStart + j]);
                        }
                        filteredData.push(sum / blockSize);
                    }
                    
                    // Normalize the data
                    const maxVal = Math.max(...filteredData);
                    const normalizedData = filteredData.map(n => n / maxVal);
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, width, height);
                    
                    // Draw waveform
                    ctx.fillStyle = 'rgba(120, 227, 254, 0.6)'; // Cyan with transparency
                    ctx.strokeStyle = 'rgba(120, 227, 254, 1)'; // Solid cyan for outline
                    ctx.lineWidth = 1;
                    
                    const middle = height / 2;
                    
                    // Draw as bars (Mozart-style)
                    ctx.beginPath();
                    for (let i = 0; i < normalizedData.length; i++) {
                        const x = i;
                        const barHeight = normalizedData[i] * (height * 0.8); // 80% of height
                        const y = middle - (barHeight / 2);
                        
                        // Draw vertical bar
                        ctx.fillRect(x, y, 1, barHeight);
                    }
                    
                    // Add subtle gradient overlay
                    const gradient = ctx.createLinearGradient(0, 0, 0, height);
                    gradient.addColorStop(0, 'rgba(120, 227, 254, 0.4)');
                    gradient.addColorStop(0.5, 'rgba(120, 227, 254, 0.2)');
                    gradient.addColorStop(1, 'rgba(120, 227, 254, 0.4)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                    
                    console.log('‚úÖ Waveform rendered for:', clip.name);
                })
                .catch(error => {
                    console.error('‚ùå Error rendering waveform:', error);
                    // Fallback: draw simple placeholder
                    ctx.fillStyle = 'rgba(120, 227, 254, 0.3)';
                    ctx.fillRect(0, height / 3, width, height / 3);
                });
        }
        
        // ========================================
        // KEYBOARD SHORTCUTS
        // ========================================
        
        function handleKeyboard(e) {
            // Space = Play/Pause
            if (e.code === 'Space' && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                togglePlay();
            }
            
            // V = Select tool
            if (e.key === 'v' || e.key === 'V') {
                setTool('select');
            }
            
            // H = Hand tool
            if (e.key === 'h' || e.key === 'H') {
                setTool('hand');
            }
            
            // C = Cut tool
            if (e.key === 'c' || e.key === 'C') {
                if (!e.ctrlKey && !e.metaKey) {
                    setTool('cut');
                }
            }
            
            // Ctrl/Cmd + C = Copy
            if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                e.preventDefault();
                copySelected();
            }
            
            // Ctrl/Cmd + V = Paste
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                e.preventDefault();
                paste();
            }
            
            // Delete/Backspace = Delete selected
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (e.target.tagName !== 'INPUT') {
                    e.preventDefault();
                    deleteSelected();
                }
            }
            
            // + = Zoom in
            if (e.key === '+' || e.key === '=') {
                zoomIn();
            }
            
            // - = Zoom out
            if (e.key === '-' || e.key === '_') {
                zoomOut();
            }
        }
        
        // ========================================
        // INITIALIZE ON LOAD
        // ========================================
        
        window.addEventListener('DOMContentLoaded', initializeDAW);
        
        // Re-render timeline ruler on window resize
        window.addEventListener('resize', () => {
            renderTimelineRuler();
        });
        
        console.log('üé® Mozart-style DAW script loaded');
    </script>
</body>
</html>
