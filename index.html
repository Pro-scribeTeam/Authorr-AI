<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AUTHORR AI - AI-Powered Audiobook Creation Platform</title>
    <meta name="description" content="Create professional audiobooks with AI-powered writing, chapter generation, and text-to-speech narration. AUTHORR AI - Your complete audiobook creation solution.">
    <meta name="keywords" content="audiobook creation, AI writing, text to speech, book generation, storytelling, AI narration">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" rel="stylesheet">
    <script type="module">
        // Optional Supabase modules - only load if available
        try {
            const { storyManager } = await import('./src/story-manager.js');
            window.storyManager = storyManager;
            console.log('Supabase StoryManager loaded successfully');
        } catch (error) {
            console.log('Supabase not available, using standalone dialogue scanning:', error.message);
            window.storyManager = null;
        }
    </script>
    <style>
        /* AUTHORR AI Brand Colors - Cyan, Silver, Black, White */
        :root {
          --brand-cyan: #78e3fe;
          --brand-cyan-hover: #5dd8fc;
          --brand-silver: #C0C0C0;
          --brand-black: #000000;
          --brand-white: #FFFFFF;
          --brand-cyan-glow: 0 0 15px rgba(120, 227, 254, 0.6), 0 0 30px rgba(120, 227, 254, 0.3);
          --brand-silver-glow: 0 0 10px rgba(192, 192, 192, 0.8), 0 0 20px rgba(192, 192, 192, 0.4);
        }
        
        .authorr-brand-text {
          background: linear-gradient(135deg, #78e3fe, #5dd8fc);
          -webkit-background-clip: text;
          -webkit-text-fill-color: transparent;
          background-clip: text;
          text-shadow: 0 0 10px rgba(120, 227, 254, 0.3);
          font-weight: 800;
          letter-spacing: 0.05em;
        }
        
        .logo-image {
          filter: drop-shadow(0 0 10px rgba(120, 227, 254, 0.4));
          animation: logoPulse 3s ease-in-out infinite alternate;
        }
        
        @keyframes logoPulse {
          0% { filter: drop-shadow(0 0 10px rgba(120, 227, 254, 0.4)); }
          100% { filter: drop-shadow(0 0 15px rgba(120, 227, 254, 0.6)); }
        }
        
        /* AI Writing Tools Button Styling - BLACK BACKGROUND, WHITE TEXT, GOLD GLOW */
        .ai-writing-tool-btn {
          background: #000000 !important;
          color: #ffffff !important;
          border: 2px solid #ffd700 !important;
          box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.3) !important;
          font-weight: 600;
          transition: all 0.3s ease;
        }
        
        .ai-writing-tool-btn:hover {
          background: #1a1a1a !important;
          border-color: #ffed4a !important;
          box-shadow: 0 0 15px rgba(255, 215, 0, 0.7), 0 0 30px rgba(255, 215, 0, 0.4) !important;
          transform: translateY(-1px);
        }
        
        /* Chapter Editing Tools Styling */
        .tool-btn {
          background: linear-gradient(135deg, #1e293b 0%, #334155 100%) !important;
          color: #e2e8f0 !important;
          border: 1px solid #475569 !important;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
          font-weight: 500;
          transition: all 0.3s ease;
          position: relative;
        }
        
        .tool-btn:hover {
          background: linear-gradient(135deg, #0ea5e9 0%, #06b6d4 100%) !important;
          border-color: #0284c7 !important;
          box-shadow: 0 4px 12px rgba(6, 182, 212, 0.4) !important;
          transform: translateY(-1px);
          color: #ffffff !important;
        }
        
        .tool-info {
          position: absolute;
          top: -8px;
          right: -8px;
          width: 16px;
          height: 16px;
          background: #3b82f6;
          color: white;
          border-radius: 50%;
          font-size: 10px;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: help;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .tool-info:hover {
          background: #1d4ed8;
          transform: scale(1.1);
        }
        
        /* Theme Support */
        .theme-light {
          --bg-primary: #ffffff;
          --bg-secondary: #f8fafc;
          --text-primary: #1a202c;
          --text-secondary: #4a5568;
          --border-color: #e2e8f0;
        }
        
        .theme-dark {
          --bg-primary: #1a202c;
          --bg-secondary: #2d3748;
          --text-primary: #ffffff;
          --text-secondary: #cbd5e0;
          --border-color: #4a5568;
        }
        
        body {
          background-color: var(--bg-primary);
          color: var(--text-primary);
        }
        
        .bg-theme-primary { background-color: var(--bg-primary); }
        .bg-theme-secondary { background-color: var(--bg-secondary); }
        .text-theme-primary { color: var(--text-primary); }
        .text-theme-secondary { color: var(--text-secondary); }
        .border-theme { border-color: var(--border-color); }
        
        /* Navigation Styling */
        .nav-item {
          color: white !important;
          border: 2px solid transparent;
          transition: all 0.3s ease;
        }
        
        .nav-item:hover, .nav-item.active {
          border-color: var(--brand-cyan);
          box-shadow: var(--brand-cyan-glow);
          background: rgba(120, 227, 254, 0.1);
        }
        
        /* Glow Effects */
        .cyan-glow { box-shadow: var(--brand-cyan-glow); }
        .silver-glow { box-shadow: var(--brand-silver-glow); }
        
        /* Form Enhancements */
        .form-field {
          border: 2px solid var(--border-color);
          transition: all 0.3s ease;
        }
        
        .form-field:focus {
          border-color: var(--brand-cyan);
          box-shadow: 0 0 10px rgba(120, 227, 254, 0.3);
          outline: none;
        }
        
        /* Button Styles */
        .btn-primary {
          background: linear-gradient(135deg, var(--brand-cyan), var(--brand-cyan-hover));
          color: white;
          border: none;
          transition: all 0.3s ease;
        }
        
        .btn-primary:hover {
          transform: translateY(-2px);
          box-shadow: var(--brand-cyan-glow);
        }
        
        .btn-secondary {
          background: var(--brand-silver);
          color: var(--brand-black);
          border: 2px solid var(--brand-silver);
          transition: all 0.3s ease;
        }
        
        .btn-secondary:hover {
          background: transparent;
          color: var(--brand-silver);
          box-shadow: var(--brand-silver-glow);
        }
        
        /* Loading Animation */
        .loading-spinner {
          border: 3px solid rgba(120, 227, 254, 0.3);
          border-radius: 50%;
          border-top: 3px solid var(--brand-cyan);
          width: 30px;
          height: 30px;
          animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }

        /* Book Flipping Animation */
        .book-loader {
          position: relative;
          width: 80px;
          height: 60px;
          margin: 0 auto;
        }
        
        .book-pages {
          position: absolute;
          width: 100%;
          height: 100%;
          background: linear-gradient(45deg, var(--brand-cyan), var(--brand-silver));
          border-radius: 4px;
          transform-origin: left center;
          animation: flip-pages 2s ease-in-out infinite;
        }
        
        .book-pages:nth-child(1) { animation-delay: 0s; z-index: 3; }
        .book-pages:nth-child(2) { animation-delay: 0.4s; z-index: 2; }
        .book-pages:nth-child(3) { animation-delay: 0.8s; z-index: 1; }
        
        .book-spine {
          position: absolute;
          left: -2px;
          top: 0;
          width: 4px;
          height: 100%;
          background: var(--brand-gold);
          border-radius: 2px;
          z-index: 4;
        }
        
        @keyframes flip-pages {
          0%, 20% {
            transform: rotateY(0deg);
            opacity: 1;
          }
          50% {
            transform: rotateY(-90deg);
            opacity: 0.7;
          }
          80%, 100% {
            transform: rotateY(-180deg);
            opacity: 0.3;
          }
        }
        
        .loading-content {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 16px;
        }
        
        /* Word Count Display */
        .word-count {
          position: absolute;
          bottom: 10px;
          right: 15px;
          background: rgba(120, 227, 254, 0.1);
          color: var(--brand-cyan);
          padding: 4px 8px;
          border-radius: 4px;
          font-size: 12px;
          font-weight: 600;
        }
        
        /* Editable Elements */
        .editable-title:focus, .editable-summary:focus {
          background-color: rgba(120, 227, 254, 0.1) !important;
          border-radius: 4px;
          padding: 2px;
          outline: 2px solid var(--brand-cyan);
        }
        
        /* Chapter Status */
        .chapter-status {
          font-size: 10px;
          margin-top: 4px;
          padding: 2px 6px;
          border-radius: 12px;
          text-align: center;
        }
        
        .status-ready { background: rgba(34, 197, 94, 0.2); color: #16a34a; }
        .status-generating { background: rgba(251, 191, 36, 0.2); color: #d97706; }
        .status-complete { background: rgba(59, 130, 246, 0.2); color: #2563eb; }
        
        /* Error States */
        .error-border { border-color: #ef4444 !important; }
        .error-text { color: #ef4444; }
        
        /* Success States */
        .success-border { border-color: #10b981 !important; }
        .success-text { color: #10b981; }
        
        /* Sound Wave Animation */
        .sound-wave-container {
          display: flex;
          justify-content: center;
          align-items: center;
          padding: 20px;
          background: linear-gradient(135deg, rgba(6, 182, 212, 0.1), rgba(34, 197, 94, 0.1));
          border-radius: 12px;
          border: 1px solid rgba(6, 182, 212, 0.3);
          width: fit-content;
          margin: 0 auto;
        }
        
        .sound-wave {
          display: flex;
          align-items: center;
          gap: 4px;
        }
        
        .wave-bar {
          width: 8px;
          height: 20px;
          background: linear-gradient(to top, #06b6d4, #10b981);
          border-radius: 4px;
          animation: wave 1.5s ease-in-out infinite;
          transform-origin: bottom;
        }
        
        .wave-bar:nth-child(1) { animation-delay: 0s; }
        .wave-bar:nth-child(2) { animation-delay: 0.1s; }
        .wave-bar:nth-child(3) { animation-delay: 0.2s; }
        .wave-bar:nth-child(4) { animation-delay: 0.3s; }
        .wave-bar:nth-child(5) { animation-delay: 0.4s; }
        .wave-bar:nth-child(6) { animation-delay: 0.3s; }
        .wave-bar:nth-child(7) { animation-delay: 0.2s; }
        .wave-bar:nth-child(8) { animation-delay: 0.1s; }
        
        @keyframes wave {
          0%, 100% { 
            transform: scaleY(1);
            background: linear-gradient(to top, #06b6d4, #10b981);
          }
          50% { 
            transform: scaleY(3);
            background: linear-gradient(to top, #0891b2, #059669, #10b981);
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.5);
          }
        }
        
        /* Cloning Station Effects */
        .cloning-station {
          position: relative;
          overflow: hidden;
        }
        
        .cloning-station::before {
          content: '';
          position: absolute;
          top: -2px;
          left: -2px;
          right: -2px;
          bottom: -2px;
          background: linear-gradient(45deg, transparent, rgba(6, 182, 212, 0.3), transparent, rgba(16, 185, 129, 0.3), transparent);
          border-radius: 14px;
          animation: borderGlow 3s linear infinite;
          z-index: -1;
        }
        
        /* Silver Glow for Cloning Sections */
        .cloning-section-silver {
          box-shadow: 0 0 10px rgba(192, 192, 192, 0.3), 0 0 20px rgba(192, 192, 192, 0.1);
          transition: box-shadow 0.3s ease;
        }
        
        .cloning-section-silver:hover {
          box-shadow: 0 0 15px rgba(192, 192, 192, 0.5), 0 0 30px rgba(192, 192, 192, 0.2);
        }
        
        @keyframes borderGlow {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        
        /* Recording Sound Wave Animation */
        .recording-wave-container {
          display: flex;
          justify-content: center;
          align-items: center;
          padding: 10px;
          background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(245, 158, 11, 0.1));
          border-radius: 8px;
          border: 1px solid rgba(239, 68, 68, 0.3);
        }
        
        .recording-wave {
          display: flex;
          align-items: center;
          gap: 2px;
        }
        
        .recording-bar {
          width: 4px;
          height: 10px;
          background: linear-gradient(to top, #ef4444, #f59e0b);
          border-radius: 2px;
          animation: recordingWave 0.8s ease-in-out infinite;
        }
        
        .recording-bar:nth-child(1) { animation-delay: 0s; }
        .recording-bar:nth-child(2) { animation-delay: 0.1s; }
        .recording-bar:nth-child(3) { animation-delay: 0.2s; }
        .recording-bar:nth-child(4) { animation-delay: 0.1s; }
        .recording-bar:nth-child(5) { animation-delay: 0s; }
        
        @keyframes recordingWave {
          0%, 100% { 
            height: 10px;
            background: linear-gradient(to top, #ef4444, #f59e0b);
          }
          50% { 
            height: 25px;
            background: linear-gradient(to top, #dc2626, #d97706, #f59e0b);
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
          }
        }

        /* Professional DAW Fader Styling */
        .daw-fader-container {
          display: flex;
          flex-direction: column;
          align-items: center;
          width: 60px;
          height: 300px;
          margin: 10px auto;
          position: relative;
        }

        .daw-fader-track {
          width: 8px;
          height: 240px;
          background: linear-gradient(to bottom, 
            #ff4444 0%, #ff4444 10%,     /* Red zone +10dB to +5dB */
            #ffaa44 10%, #ffaa44 15%,    /* Orange zone +5dB to 0dB */
            #666 15%, #666 65%,          /* Gray zone 0dB to -20dB */
            #333 65%, #333 100%          /* Dark zone -20dB to -∞ */
          );
          border-radius: 4px;
          position: relative;
          box-shadow: inset 0 0 3px rgba(0,0,0,0.5);
        }

        .daw-fader-handle {
          width: 24px;
          height: 16px;
          background: linear-gradient(to bottom, 
            #f0f0f0 0%, 
            #e0e0e0 20%, 
            #d0d0d0 40%, 
            #c0c0c0 60%, 
            #b0b0b0 80%, 
            #a0a0a0 100%
          );
          border: 1px solid #999;
          border-radius: 2px;
          position: absolute;
          left: -8px;
          cursor: pointer;
          box-shadow: 
            0 1px 3px rgba(0,0,0,0.4),
            inset 0 1px 0 rgba(255,255,255,0.3);
          transition: all 0.1s ease;
        }

        .daw-fader-handle:hover {
          background: linear-gradient(to bottom, 
            #ffffff 0%, 
            #f0f0f0 20%, 
            #e0e0e0 40%, 
            #d0d0d0 60%, 
            #c0c0c0 80%, 
            #b0b0b0 100%
          );
          box-shadow: 
            0 2px 4px rgba(0,0,0,0.5),
            inset 0 1px 0 rgba(255,255,255,0.4);
        }

        .daw-fader-handle:active {
          background: linear-gradient(to bottom, 
            #e0e0e0 0%, 
            #d0d0d0 20%, 
            #c0c0c0 40%, 
            #b0b0b0 60%, 
            #a0a0a0 80%, 
            #909090 100%
          );
          box-shadow: 
            inset 0 1px 3px rgba(0,0,0,0.4),
            0 1px 2px rgba(0,0,0,0.3);
        }

        .daw-fader-scale {
          position: absolute;
          right: -30px;
          top: 0;
          height: 240px;
          display: flex;
          flex-direction: column;
          justify-content: space-between;
          font-size: 9px;
          color: #999;
          font-family: 'Courier New', monospace;
        }

        .daw-fader-scale-mark {
          position: relative;
          text-align: left;
          line-height: 1;
        }

        .daw-fader-scale-mark::before {
          content: '';
          position: absolute;
          left: -12px;
          top: 50%;
          width: 8px;
          height: 1px;
          background: #666;
          transform: translateY(-50%);
        }

        .daw-fader-scale-mark.major::before {
          width: 12px;
          background: #aaa;
        }

        .daw-fader-value {
          margin-top: 8px;
          font-size: 10px;
          color: #00bcd4;
          text-align: center;
          font-weight: bold;
          min-height: 12px;
        }

        .daw-fader-label {
          margin-bottom: 8px;
          font-size: 11px;
          color: #ccc;
          text-align: center;
          font-weight: bold;
        }

        /* Hide default range slider */
        .daw-fader-input {
          display: none;
        }

        /* LED Indicator */
        .daw-led {
          width: 12px;
          height: 12px;
          border-radius: 50%;
          margin: 4px auto;
          transition: all 0.2s ease;
          box-shadow: 
            inset 0 1px 2px rgba(0,0,0,0.3),
            0 0 4px rgba(0,255,0,0.3);
        }

        .daw-led.active {
          background: #00ff00;
          box-shadow: 
            inset 0 1px 2px rgba(0,0,0,0.3),
            0 0 8px rgba(0,255,0,0.8),
            0 0 16px rgba(0,255,0,0.4);
        }

        .daw-led.inactive {
          background: #333;
          box-shadow: 
            inset 0 1px 2px rgba(0,0,0,0.5);
        }

        /* Enhanced track containers */
        .daw-track-container {
          background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
          border: 1px solid #444;
          border-radius: 8px;
          padding: 16px;
          margin-bottom: 12px;
          box-shadow: 
            0 4px 8px rgba(0,0,0,0.3),
            inset 0 1px 0 rgba(255,255,255,0.1);
        }

        /* Fix scrolling issues for GitHub Pages deployment */
        html {
          scroll-behavior: smooth;
          height: 100%;
          overflow-y: auto;
        }

        body {
          height: 100%;
          min-height: 100vh;
          overflow-y: auto;
          overflow-x: hidden;
          position: relative;
        }

        .container {
          width: 100%;
          max-width: 100%;
          overflow-x: hidden;
        }

        /* Ensure modals can scroll */
        .modal-overlay {
          overflow-y: auto;
          height: 100vh;
          display: flex;
          align-items: flex-start;
          padding: 20px 0;
        }

        .modal-content {
          max-height: calc(100vh - 40px);
          overflow-y: auto;
        }

        /* Timeline container scrolling */
        .timeline-container {
          overflow-x: auto;
          overflow-y: hidden;
          width: 100%;
        }

        /* DAW track scrolling */
        .daw-tracks-container {
          max-height: 70vh;
          overflow-y: auto;
          overflow-x: hidden;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
          .mobile-stack { flex-direction: column; }
          .mobile-full { width: 100%; }
          .mobile-text-sm { font-size: 14px; }
          .sound-wave-container { padding: 15px; }
          .wave-bar { width: 6px; height: 16px; }
          .daw-fader-container { width: 50px; height: 250px; }
          .daw-fader-track { height: 200px; }
          .daw-fader-scale { right: -25px; height: 200px; }
        }
    </style>
</head>
<body class="theme-dark">
    <!-- Navigation -->
    <nav class="bg-black border-b-2 border-cyan-400 shadow-lg">
        <div class="container mx-auto px-4">
            <div class="flex justify-between items-center py-4">
                <div class="flex items-center space-x-3">
                    <img src="https://page.gensparksite.com/v1/base64_upload/5ec0a971230da95148e537dd473d0fb1" alt="AUTHORR AI Logo" class="w-12 h-12 logo-image">
                    <h1 class="text-3xl font-bold authorr-brand-text">AUTHORR AI</h1>
                </div>
                <div class="hidden md:flex items-center space-x-6">
                    <button onclick="showPage('dashboard')" class="nav-item px-4 py-2 rounded-lg font-semibold active">
                        <i class="fas fa-home mr-2"></i>Dashboard
                    </button>
                    <button onclick="showPage('workspace')" class="nav-item px-4 py-2 rounded-lg font-semibold">
                        <i class="fas fa-edit mr-2"></i>Workspace
                    </button>
                    <button onclick="showPage('narration')" class="nav-item px-4 py-2 rounded-lg font-semibold">
                        <i class="fas fa-microphone mr-2"></i>Narration
                    </button>
                    <button onclick="showPage('covers')" class="nav-item px-4 py-2 rounded-lg font-semibold">
                        <i class="fas fa-image mr-2"></i>Covers
                    </button>
                    <button onclick="showPage('export')" class="nav-item px-4 py-2 rounded-lg font-semibold">
                        <i class="fas fa-download mr-2"></i>Export
                    </button>
                    <button onclick="showPage('config')" class="nav-item px-4 py-2 rounded-lg font-semibold">
                        <i class="fas fa-cog mr-2"></i>Config
                    </button>
                </div>
                <button onclick="toggleTheme()" class="text-cyan-400 hover:text-cyan-300 text-xl">
                    <i id="themeIcon" class="fas fa-moon"></i>
                </button>
            </div>
        </div>
    </nav>

    <!-- Dashboard Page -->
    <div id="dashboard" class="page">
        <div class="container mx-auto px-4 py-8">
            <!-- Hero Section -->
            <div class="text-center mb-12">
                <div class="flex justify-center items-center mb-6">
                    <img src="https://page.gensparksite.com/v1/base64_upload/5ec0a971230da95148e537dd473d0fb1" alt="AUTHORR AI Logo" class="w-20 h-20 logo-image mr-4">
                    <h1 class="text-6xl font-bold authorr-brand-text">AUTHORR AI</h1>
                </div>
                <p class="text-xl text-theme-secondary mb-8 max-w-3xl mx-auto">
                    Transform your stories into professional audiobooks with AI-powered writing, chapter generation, 
                    and high-quality text-to-speech narration. Create, edit, and publish audiobooks in minutes.
                </p>
                <button onclick="showPage('workspace')" class="btn-primary px-8 py-4 rounded-lg text-lg font-semibold">
                    <i class="fas fa-rocket mr-2"></i>Start Creating Your Audiobook
                </button>
            </div>

            <!-- Features Grid -->
            <div class="grid md:grid-cols-3 gap-8 mb-12">
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme hover:border-cyan-400 transition-all duration-300 cyan-glow">
                    <div class="text-cyan-400 text-3xl mb-4">
                        <i class="fas fa-brain"></i>
                    </div>
                    <h3 class="text-xl font-bold mb-3">AI-Powered Writing</h3>
                    <p class="text-theme-secondary">
                        Generate engaging chapters, stories, and content with advanced GPT-4o-mini integration. 
                        Choose from multiple genres, tones, and writing styles.
                    </p>
                </div>
                
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme hover:border-cyan-400 transition-all duration-300 cyan-glow">
                    <div class="text-cyan-400 text-3xl mb-4">
                        <i class="fas fa-microphone"></i>
                    </div>
                    <h3 class="text-xl font-bold mb-3">Professional Narration</h3>
                    <p class="text-theme-secondary">
                        Convert your text to high-quality speech with OpenAI's TTS-1-HD. Choose from 6 professional 
                        voices including Alloy, Echo, Fable, Onyx, Nova, and Shimmer.
                    </p>
                </div>
                
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme hover:border-cyan-400 transition-all duration-300 cyan-glow">
                    <div class="text-cyan-400 text-3xl mb-4">
                        <i class="fas fa-image"></i>
                    </div>
                    <h3 class="text-xl font-bold mb-3">AI Book Covers</h3>
                    <p class="text-theme-secondary">
                        Generate stunning book covers with DALL-E 3 in HD quality (1024x1792). 
                        Create professional artwork that matches your story's theme.
                    </p>
                </div>
            </div>

            <!-- Stats Section -->
            <div class="grid md:grid-cols-4 gap-6 mb-12">
                <div class="text-center bg-theme-secondary p-6 rounded-xl">
                    <div class="text-3xl font-bold text-cyan-400 mb-2">25</div>
                    <div class="text-theme-secondary">Max Chapters</div>
                </div>
                <div class="text-center bg-theme-secondary p-6 rounded-xl">
                    <div class="text-3xl font-bold text-cyan-400 mb-2">3000</div>
                    <div class="text-theme-secondary">Max Words/Chapter</div>
                </div>
                <div class="text-center bg-theme-secondary p-6 rounded-xl">
                    <div class="text-3xl font-bold text-cyan-400 mb-2">6</div>
                    <div class="text-theme-secondary">AI Voices</div>
                </div>
                <div class="text-center bg-theme-secondary p-6 rounded-xl">
                    <div class="text-3xl font-bold text-cyan-400 mb-2">∞</div>
                    <div class="text-theme-secondary">Possibilities</div>
                </div>
            </div>

            <!-- Quick Start Guide -->
            <div class="bg-theme-secondary p-8 rounded-xl border-2 border-theme">
                <h2 class="text-2xl font-bold mb-6 text-center">
                    <i class="fas fa-play-circle text-cyan-400 mr-2"></i>
                    Quick Start Guide
                </h2>
                <div class="grid md:grid-cols-4 gap-6">
                    <div class="text-center">
                        <div class="bg-cyan-400 text-black rounded-full w-12 h-12 flex items-center justify-center mx-auto mb-3 font-bold text-xl">1</div>
                        <h3 class="font-semibold mb-2">Plan Your Story</h3>
                        <p class="text-sm text-theme-secondary">Choose genre, set chapter count, and define your story parameters</p>
                    </div>
                    <div class="text-center">
                        <div class="bg-cyan-400 text-black rounded-full w-12 h-12 flex items-center justify-center mx-auto mb-3 font-bold text-xl">2</div>
                        <h3 class="font-semibold mb-2">Generate Content</h3>
                        <p class="text-sm text-theme-secondary">Use AI writing tools to create engaging chapters and storylines</p>
                    </div>
                    <div class="text-center">
                        <div class="bg-cyan-400 text-black rounded-full w-12 h-12 flex items-center justify-center mx-auto mb-3 font-bold text-xl">3</div>
                        <h3 class="font-semibold mb-2">Create Narration</h3>
                        <p class="text-sm text-theme-secondary">Convert to speech with professional AI voices and generate covers</p>
                    </div>
                    <div class="text-center">
                        <div class="bg-cyan-400 text-black rounded-full w-12 h-12 flex items-center justify-center mx-auto mb-3 font-bold text-xl">4</div>
                        <h3 class="font-semibold mb-2">Export & Publish</h3>
                        <p class="text-sm text-theme-secondary">Download your complete audiobook and share with the world</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Workspace Page -->
    <div id="workspace" class="page hidden">
        <div class="container mx-auto px-4 py-8">
            <div class="flex justify-between items-center mb-8">
                <h1 class="text-3xl font-bold">
                    <i class="fas fa-edit text-cyan-400 mr-3"></i>
                    Audiobook Workspace
                </h1>
                <button onclick="showPage('narration')" id="continueToNarration" class="btn-primary px-6 py-2 rounded-lg font-semibold">
                    <i class="fas fa-arrow-right mr-2"></i>Continue to Narration
                </button>
            </div>

            <!-- Story Planning Form -->
            <div class="grid lg:grid-cols-2 gap-8 mb-8">
                <!-- Left Column: Story Parameters -->
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                    <h2 class="text-xl font-bold mb-4">
                        <i class="fas fa-cogs text-cyan-400 mr-2"></i>
                        Story Parameters
                    </h2>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold mb-2">Book Title</label>
                            <input type="text" id="bookTitle" placeholder="Enter your book title" 
                                   class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">
                                <i class="fas fa-palette mr-1"></i>Story Genre
                                <span id="genreTooltip" class="ml-2 text-xs text-cyan-400 cursor-help"></span>
                            </label>
                            <select id="storyGenre" onchange="updateGenreSettings()" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                <option value="General">General (No Specific Genre)</option>
                                <option value="Thriller">Thriller</option>
                                <option value="Romance">Romance</option>
                                <option value="Fantasy">Fantasy</option>
                                <option value="Horror">Horror</option>
                                <option value="Comedy">Comedy</option>
                                <option value="Drama">Drama</option>
                                <option value="YoungAdult">Young Adult</option>
                                <option value="Children">Children's Story</option>
                                <option value="Memoir">Memoir/Non-Fiction</option>
                            </select>
                        </div>
                        
                        <!-- Human Touch Score -->
                        <div class="bg-theme-primary p-4 rounded-lg border border-theme">
                            <div class="flex items-center justify-between">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-heart text-red-400"></i>
                                    <span class="text-sm font-semibold">Human Touch Score:</span>
                                </div>
                                <span class="human-touch-score text-lg font-bold">0%</span>
                            </div>
                            <div class="text-xs text-theme-secondary mt-1">
                                Based on personal edits, notes, and voice choices
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-semibold mb-2">Chapter Selection</label>
                                <select id="chapterCount" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                    <option value="3">3 Chapters</option>
                                    <option value="5">5 Chapters</option>
                                    <option value="7">7 Chapters</option>
                                    <option value="10" selected>10 Chapters</option>
                                    <option value="15">15 Chapters</option>
                                    <option value="20">20 Chapters</option>
                                    <option value="25">25 Chapters</option>
                                </select>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-semibold mb-2">Words per Chapter</label>
                                <select id="wordsPerChapter" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                    <option value="250">250 words (~1 min audio)</option>
                                    <option value="500">500 words (~2 min audio)</option>
                                    <option value="750">750 words (~3 min audio)</option>
                                    <option value="1000" selected>1000 words (~4 min audio)</option>
                                    <option value="1250">1250 words (~5 min audio)</option>
                                    <option value="1500">1500 words (~6 min audio)</option>
                                    <option value="2000">2000 words (~8 min audio)</option>
                                    <option value="2500">2500 words (~10 min audio)</option>
                                    <option value="3000">3000 words (~12 min audio)</option>
                                </select>
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">Genre & Subgenre</label>
                            <select id="genre" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                <option value="fiction-literary">Fiction - Literary</option>
                                <option value="fiction-mystery">Fiction - Mystery/Thriller</option>
                                <option value="fiction-romance">Fiction - Romance</option>
                                <option value="fiction-scifi">Fiction - Science Fiction</option>
                                <option value="fiction-fantasy">Fiction - Fantasy</option>
                                <option value="fiction-horror">Fiction - Horror</option>
                                <option value="fiction-historical">Fiction - Historical</option>
                                <option value="nonfiction-biography">Non-Fiction - Biography</option>
                                <option value="nonfiction-selfhelp">Non-Fiction - Self-Help</option>
                                <option value="nonfiction-business">Non-Fiction - Business</option>
                                <option value="nonfiction-history">Non-Fiction - History</option>
                                <option value="children-adventure">Children's - Adventure</option>
                                <option value="children-educational">Children's - Educational</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">Tone & Voice</label>
                            <select id="tone" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                <option value="professional">Professional</option>
                                <option value="casual">Casual & Conversational</option>
                                <option value="dramatic">Dramatic & Intense</option>
                                <option value="humorous">Humorous & Light</option>
                                <option value="inspiring">Inspiring & Motivational</option>
                                <option value="mysterious">Mysterious & Suspenseful</option>
                                <option value="romantic">Romantic & Emotional</option>
                                <option value="educational">Educational & Informative</option>
                                <option value="adventurous">Adventurous & Exciting</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">Story Outline</label>
                            <div class="relative">
                                <textarea id="storyOutline" placeholder="Describe your story concept, main characters, and plot outline..." 
                                          class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary h-24 resize-none"></textarea>
                                <div class="absolute bottom-2 right-3 text-xs text-cyan-400 bg-black bg-opacity-50 px-2 py-1 rounded">
                                    <span id="outlineWordCount">0 words</span>
                                </div>
                            </div>
                        </div>
                        
                        <button onclick="generateChapterPlan()" class="btn-primary w-full py-3 rounded-lg font-semibold">
                            <i class="fas fa-magic mr-2"></i>Generate Chapter Plan
                        </button>
                    </div>
                </div>
                
                <!-- Right Column: Chapter Plan -->
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold">
                            <i class="fas fa-list-ol text-cyan-400 mr-2"></i>
                            Chapter Plan
                        </h2>
                        <div class="flex space-x-2">
                            <button onclick="generateAllChapters()" id="generateAllBtn" class="btn-secondary px-4 py-2 rounded-lg text-sm font-semibold" disabled>
                                <i class="fas fa-bolt mr-1"></i>Generate All Chapters
                            </button>
                            <button onclick="combineAllChapters()" id="combineAllBtn" class="btn-primary px-4 py-2 rounded-lg text-sm font-semibold" disabled>
                                <i class="fas fa-book mr-1"></i>Combine All
                            </button>
                        </div>
                    </div>
                    
                    <div id="chapterPlan" class="space-y-3 h-80 overflow-y-auto">
                        <div class="text-center text-theme-secondary py-8">
                            <i class="fas fa-lightbulb text-4xl mb-3 opacity-50"></i>
                            <p>Generate a chapter plan to get started</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Text Editor Section -->
            <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold">
                        <i class="fas fa-pen-fancy text-cyan-400 mr-2"></i>
                        Story Editor
                    </h2>
                    <div class="flex items-center space-x-3">
                        <div class="word-count" id="wordCount">0 words</div>
                        <button onclick="undoEdit()" id="undoBtn" class="btn-secondary px-3 py-1 rounded text-sm" disabled>
                            <i class="fas fa-undo"></i> Undo
                        </button>
                        <button onclick="redoEdit()" id="redoBtn" class="btn-secondary px-3 py-1 rounded text-sm" disabled>
                            <i class="fas fa-redo"></i> Redo
                        </button>
                        <button onclick="saveStory()" id="saveBtn" class="btn-primary px-3 py-1 rounded text-sm">
                            <i class="fas fa-save"></i> Save
                        </button>
                    </div>
                </div>
                
                <div class="relative mb-4">
                    <textarea id="storyEditor" placeholder="Start writing your story here, or use the AI writing tools to generate content..." 
                              class="w-full px-4 py-3 rounded-lg form-field bg-theme-primary text-theme-primary h-96 resize-none"></textarea>
                </div>

                <!-- Chapter-by-Chapter Editing Tools -->
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold text-cyan-400">
                            <i class="fas fa-tools mr-2"></i>Chapter Editing Tools
                        </h3>
                        <div class="text-xs text-theme-secondary">Work on one chapter at a time</div>
                    </div>
                    
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3 p-4 bg-theme-primary rounded-lg border border-theme">
                        <!-- Row 1 -->
                        <div class="relative">
                            <button onclick="plotHoleDetector()" class="tool-btn w-full px-3 py-2 rounded text-sm font-medium">
                                <i class="fas fa-search mr-1"></i>Plot Hole Detector
                            </button>
                            <i class="fas fa-info-circle tool-info" title="Finds gaps or mistakes in the story that don't make sense and shows you how to fix them."></i>
                        </div>
                        
                        <div class="relative">
                            <button onclick="characterArcDesigner()" class="tool-btn w-full px-3 py-2 rounded text-sm font-medium">
                                <i class="fas fa-user-edit mr-1"></i>Character Arc Designer
                            </button>
                            <i class="fas fa-info-circle tool-info" title="Helps shape how your character changes from the beginning of the story to the end."></i>
                        </div>
                        
                        <div class="relative">
                            <button onclick="toneShifter()" class="tool-btn w-full px-3 py-2 rounded text-sm font-medium">
                                <i class="fas fa-palette mr-1"></i>Tone Shifter
                            </button>
                            <i class="fas fa-info-circle tool-info" title="Adjusts the mood and style of your writing so it feels consistent and matches your target audience."></i>
                        </div>
                        
                        <div class="relative">
                            <button onclick="conflictIntensifier()" class="tool-btn w-full px-3 py-2 rounded text-sm font-medium">
                                <i class="fas fa-fire mr-1"></i>Conflict Intensifier
                            </button>
                            <i class="fas fa-info-circle tool-info" title="Adds more tension and drama to your story by making sure characters' goals and obstacles clash strongly."></i>
                        </div>
                        
                        <!-- Row 2 -->
                        <div class="relative">
                            <button onclick="dialogueEnhancer()" class="tool-btn w-full px-3 py-2 rounded text-sm font-medium">
                                <i class="fas fa-comments mr-1"></i>Dialogue Enhancer
                            </button>
                            <i class="fas fa-info-circle tool-info" title="Makes conversations between characters sound more real, engaging, and filled with hidden meaning."></i>
                        </div>
                        
                        <div class="relative">
                            <button onclick="symbolismSuggester()" class="tool-btn w-full px-3 py-2 rounded text-sm font-medium">
                                <i class="fas fa-gem mr-1"></i>Symbolism Suggester
                            </button>
                            <i class="fas fa-info-circle tool-info" title="Suggests meaningful symbols or motifs that give your story extra depth and layers of meaning."></i>
                        </div>
                        
                        <div class="relative">
                            <button onclick="metaphorGenerator()" class="tool-btn w-full px-3 py-2 rounded text-sm font-medium">
                                <i class="fas fa-feather-alt mr-1"></i>Metaphor Generator
                            </button>
                            <i class="fas fa-info-circle tool-info" title="Creates fresh, vivid comparisons that make your descriptions more powerful and memorable."></i>
                        </div>
                        
                        <div class="relative">
                            <button onclick="themeTracker()" class="tool-btn w-full px-3 py-2 rounded text-sm font-medium">
                                <i class="fas fa-compass mr-1"></i>Theme Tracker
                            </button>
                            <i class="fas fa-info-circle tool-info" title="Keeps your story's big idea or moral consistent and visible throughout the book."></i>
                        </div>
                        
                        <!-- Row 3 -->
                        <div class="relative">
                            <button onclick="emotionalResonanceChecker()" class="tool-btn w-full px-3 py-2 rounded text-sm font-medium">
                                <i class="fas fa-heart mr-1"></i>Emotional Resonance
                            </button>
                            <i class="fas fa-info-circle tool-info" title="Makes sure readers feel the emotions you want them to feel at the right time in the story."></i>
                        </div>
                        
                        <div class="relative">
                            <button onclick="redHerringGenerator()" class="tool-btn w-full px-3 py-2 rounded text-sm font-medium">
                                <i class="fas fa-mask mr-1"></i>Red Herring Generator
                            </button>
                            <i class="fas fa-info-circle tool-info" title="Adds clever misdirections in mystery or thriller stories to keep readers guessing without cheating."></i>
                        </div>
                        
                        <div class="relative">
                            <button onclick="pacingBalancer()" class="tool-btn w-full px-3 py-2 rounded text-sm font-medium">
                                <i class="fas fa-tachometer-alt mr-1"></i>Pacing Balancer
                            </button>
                            <i class="fas fa-info-circle tool-info" title="Controls the speed and rhythm of your story so it never feels too slow or rushed."></i>
                        </div>
                        
                        <div class="relative">
                            <button onclick="subtextBuilder()" class="tool-btn w-full px-3 py-2 rounded text-sm font-medium">
                                <i class="fas fa-layer-group mr-1"></i>Subtext Builder
                            </button>
                            <i class="fas fa-info-circle tool-info" title="Helps characters say one thing but mean another, adding layers of hidden meaning to dialogue."></i>
                        </div>
                    </div>
                </div>

                <!-- Text Humanization Section -->
                <div class="mb-6">
                    <div class="bg-theme-primary p-4 rounded-lg border border-theme">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="text-lg font-semibold text-purple-400">
                                <i class="fas fa-user-edit mr-2"></i>Text Humanization
                            </h3>
                            <div class="flex space-x-2">
                                <button onclick="undoEdit()" class="btn-secondary px-3 py-1 rounded text-xs">
                                    <i class="fas fa-undo"></i> Undo
                                </button>
                                <button onclick="redoEdit()" class="btn-secondary px-3 py-1 rounded text-xs">
                                    <i class="fas fa-redo"></i> Redo
                                </button>
                            </div>
                        </div>
                        
                        <p class="text-sm text-theme-secondary mb-3">Enhance text to sound more natural and human-written while preserving meaning and quality.</p>
                        
                        <div class="flex gap-3 flex-wrap">
                            <div class="relative">
                                <button onclick="humanizeText()" class="btn-primary px-4 py-2 rounded font-medium" id="humanizeBtn">
                                    <i class="fas fa-user-edit mr-2"></i>Humanize Text
                                </button>
                                <i class="fas fa-info-circle tool-info" title="Applies advanced techniques to make text sound more natural and human-written while preserving meaning and quality."></i>
                            </div>
                        </div>

                        <!-- Continue to Narration Button -->
                        <div class="mt-6 text-center">
                            <button onclick="showPage('narration')" class="btn-glow bg-cyan-600 hover:bg-cyan-500 text-white px-8 py-3 rounded-lg font-semibold transition-all">
                                <i class="fas fa-microphone mr-2"></i>Continue to Narration
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Narration Page -->
    <div id="narration" class="page hidden">
        <div class="container mx-auto px-4 py-8">
            <div class="flex justify-between items-center mb-8">
                <h1 class="text-3xl font-bold">
                    <i class="fas fa-microphone text-cyan-400 mr-3"></i>
                    Audio Narration
                </h1>
                <button onclick="showPage('export')" class="btn-primary px-6 py-2 rounded-lg font-semibold">
                    <i class="fas fa-download mr-2"></i>Export Audiobook
                </button>
            </div>
            
            <!-- Genre-Specific Narration Guidance -->
            <div id="genreNarrationGuidance" class="mb-6 bg-gradient-to-r from-purple-600 to-blue-600 p-4 rounded-xl border-2 border-purple-400">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-3">
                        <i class="fas fa-palette text-purple-200"></i>
                        <span class="text-white font-semibold" id="currentGenreDisplay">General</span>
                        <span class="text-purple-200 text-sm">Narration Guidelines</span>
                    </div>
                    <span class="text-purple-200 text-sm">Human Touch: <span class="human-touch-score text-white font-semibold">0%</span></span>
                </div>
                <div id="genreNarrationTips" class="text-purple-100 text-sm mt-2">
                    Select a genre in the Workspace to get tailored narration guidance.
                </div>
            </div>

            <!-- Animated Sound Wave -->
            <div class="sound-wave-container mb-8">
                <div class="sound-wave">
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                </div>
            </div>

            <div class="grid lg:grid-cols-2 gap-8">
                <!-- Voice Selection & Controls -->
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                    <h2 class="text-xl font-bold mb-4">
                        <i class="fas fa-volume-up text-cyan-400 mr-2"></i>
                        Voice & Audio Settings
                    </h2>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold mb-2">Voice Actors</label>
                            <select id="voiceSelection" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                <option value="alloy">Alloy - Balanced, Clear</option>
                                <option value="echo">Echo - Male, Authoritative</option>
                                <option value="fable">Fable - Warm, Storytelling</option>
                                <option value="onyx">Onyx - Deep, Professional</option>
                                <option value="nova">Nova - Female, Engaging</option>
                                <option value="shimmer">Shimmer - Soft, Gentle</option>
                            </select>
                            <button onclick="previewSelectedVoice()" class="btn-secondary w-full mt-2 py-2 rounded-lg text-sm">
                                <i class="fas fa-play mr-2"></i>Preview Voice
                            </button>
                            <div id="voicePreviewPlayer" class="hidden mt-2">
                                <audio controls class="w-full">
                                    <source id="voicePreviewSource" src="" type="audio/mpeg">
                                </audio>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-semibold mb-2">Speech Rate</label>
                                <select id="speechRate" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                    <option value="0.75">Slow (0.75x)</option>
                                    <option value="1.0" selected>Normal (1.0x)</option>
                                    <option value="1.25">Fast (1.25x)</option>
                                </select>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-semibold mb-2">Audio Format</label>
                                <select id="audioFormat" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                    <option value="mp3" selected>MP3 (Recommended)</option>
                                    <option value="opus">OPUS (High Quality)</option>
                                    <option value="aac">AAC (Apple Compatible)</option>
                                    <option value="flac">FLAC (Lossless)</option>
                                </select>
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">Preview Text</label>
                            <textarea id="previewText" placeholder="Enter text to preview the selected voice..." 
                                      class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary h-20 resize-none"></textarea>
                        </div>
                        
                        <button onclick="previewVoice()" class="btn-secondary w-full py-2 rounded-lg font-semibold">
                            <i class="fas fa-play mr-2"></i>Preview Voice
                        </button>
                        
                        <div class="border-t border-theme pt-4">
                            <button onclick="generateNarration()" class="btn-primary w-full py-3 rounded-lg font-semibold">
                                <i class="fas fa-microphone mr-2"></i>Generate Full Narration
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Dialogue-Specific Voice Assignment -->
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                    <h2 class="text-xl font-bold mb-4">
                        <i class="fas fa-users text-purple-400 mr-2"></i>
                        Dialogue Voice Assignment
                    </h2>
                    
                    <div class="space-y-4">
                        <p class="text-sm text-theme-secondary">
                            Assign different voices to characters in your story for dynamic narration.
                        </p>
                        
                        <!-- Content Status Indicator -->
                        <div id="contentStatusIndicator" class="bg-theme-primary p-3 rounded-lg border border-theme">
                            <div class="flex items-center justify-between">
                                <div class="flex items-center space-x-2">
                                    <div id="contentStatusIcon" class="w-3 h-3 rounded-full bg-gray-400"></div>
                                    <span class="text-sm font-medium">Story Content Status:</span>
                                </div>
                                <button onclick="refreshContentStatus()" class="text-xs text-cyan-400 hover:text-cyan-300">
                                    <i class="fas fa-sync mr-1"></i>Refresh
                                </button>
                            </div>
                            <div id="contentStatusText" class="text-xs text-theme-secondary mt-1">
                                Checking for story content...
                            </div>
                            <div id="contentPreviewToggle" class="mt-2 hidden">
                                <div class="flex items-center space-x-2">
                                    <button onclick="toggleContentPreview()" class="text-xs text-cyan-400 hover:text-cyan-300">
                                        <i class="fas fa-eye mr-1"></i>Preview Content
                                    </button>
                                    <button onclick="clearPreviewContent()" class="text-xs text-yellow-400 hover:text-yellow-300">
                                        <i class="fas fa-refresh mr-1"></i>Clear Preview
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Content Preview (Hidden by default) -->
                        <div id="contentPreview" class="hidden bg-theme-primary p-3 rounded-lg border border-theme">
                            <div class="flex items-center justify-between mb-2">
                                <h5 class="text-sm font-medium text-cyan-400">Content Preview:</h5>
                                <button onclick="toggleContentPreview()" class="text-xs text-theme-secondary">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            <div id="contentPreviewText" class="text-xs text-theme-secondary max-h-32 overflow-y-auto bg-theme-secondary p-2 rounded font-mono">
                                <!-- Content preview will appear here -->
                            </div>
                        </div>
                        
                        <button onclick="scanToNarration()" class="btn-secondary w-full py-2 rounded-lg font-semibold">
                            <i class="fas fa-microphone mr-2"></i>Scan to Narration
                        </button>
                        
                        <!-- Dialogue Assignment Results -->
                        <!-- Character Voice Assignments removed - all dialogue now uses narrator voice -->

                        <!-- Narration Preview -->
                        <div id="narrationPreview" class="hidden">
                            <div class="bg-theme-primary p-4 rounded-lg border border-theme">
                                <h4 class="font-semibold mb-3 text-green-400">Story Content for Narration</h4>
                                
                                <!-- Narrator Voice Selection -->
                                <div class="mb-4 p-3 bg-theme-secondary rounded-lg border border-theme">
                                    <h5 class="font-medium mb-2 text-cyan-400">Select Narrator Voice</h5>
                                    <div class="flex items-center space-x-2">
                                        <select id="narratorVoiceSelect" class="flex-1 px-3 py-2 rounded bg-theme-primary border border-theme text-sm">
                                            <option value="">Select narrator voice...</option>
                                        </select>
                                        <button onclick="previewNarratorVoice()" id="narratorPreviewBtn" class="px-4 py-2 bg-cyan-600 hover:bg-cyan-500 rounded text-white text-sm font-medium" disabled>
                                            <i class="fas fa-play mr-1"></i>Preview Voice
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- Story Content Preview -->
                                <div class="mb-3">
                                    <h5 class="font-medium mb-2 text-cyan-400">Story Content (First 500 characters)</h5>
                                    <div id="storyContentPreview" class="text-sm text-theme-secondary bg-theme-secondary p-3 rounded border max-h-32 overflow-y-auto">
                                        <!-- Story preview will be populated here -->
                                    </div>
                                </div>
                                
                                <div class="text-center">
                                    <div id="fullStoryStats" class="text-xs text-gray-400">
                                        <!-- Story statistics will be shown here -->
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="border-t border-theme pt-4">
                            <button onclick="generateNarration()" id="generateNarrationBtn" class="btn-primary w-full py-3 rounded-lg font-semibold" disabled>
                                <i class="fas fa-microphone mr-2"></i>Generate Narration
                            </button>
                        </div>
                    </div>
                    
                    <!-- Multi-Voice Narration Results -->
                    <div id="narrationResults" class="mt-4"></div>
                </div>
                
                <!-- High-Tech Voice Cloning Station -->
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme cloning-station">
                    <h2 class="text-xl font-bold mb-4">
                        <i class="fas fa-dna text-cyan-400 mr-2 animate-pulse"></i>
                        Voice Cloning Station
                    </h2>
                    
                    <div class="space-y-6">
                        <div class="bg-theme-primary p-4 rounded-lg border border-cyan-500">
                            <div class="flex items-center mb-2">
                                <div class="w-3 h-3 rounded-full bg-green-400 mr-2 animate-pulse"></div>
                                <span class="text-sm font-semibold text-cyan-400">Neural Voice Matrix</span>
                            </div>
                            <p class="text-xs text-theme-secondary mb-3">Upload voice samples to create custom AI narrator profiles</p>
                        </div>
                        
                        <!-- Audio Upload Section -->
                        <div class="border-2 border-gray-400 p-4 rounded-lg text-center hover:border-gray-300 transition-colors cursor-pointer cloning-section-silver" 
                             ondrop="handleVoiceDrop(event)" ondragover="allowDrop(event)" onclick="document.getElementById('voiceUpload').click()">
                            <i class="fas fa-microphone text-gray-300 text-2xl mb-2"></i>
                            <p class="text-sm text-gray-300">Drag & drop audio files or click to browse</p>
                            <input type="file" id="voiceUpload" accept=".mp3,.wav,.m4a" multiple class="hidden">
                        </div>
                        
                        <!-- Text Input Section -->
                        <div class="border-2 border-gray-400 p-4 rounded-lg hover:border-gray-300 transition-colors cloning-section-silver" 
                             ondrop="handleTextDrop(event)" ondragover="allowDrop(event)">
                            <div class="flex items-center mb-2">
                                <i class="fas fa-file-text text-gray-300 mr-2"></i>
                                <span class="text-sm font-semibold text-gray-300">Text Input & Preview</span>
                            </div>
                            <textarea id="cloneTextInput" placeholder="Drag & drop text files here or type/paste your text for voice cloning preview..." 
                                      class="w-full px-3 py-2 rounded-lg form-field bg-theme-primary text-theme-primary h-20 resize-none text-sm"></textarea>
                            <div class="flex justify-between items-center mt-2 text-xs text-theme-secondary">
                                <span id="textCharCount">0 characters</span>
                                <button onclick="previewCloneText()" class="btn-secondary px-3 py-1 rounded text-xs">
                                    <i class="fas fa-play mr-1"></i>Preview
                                </button>
                            </div>
                        </div>
                        
                        <!-- Recording Section -->
                        <div class="border-2 border-red-500 p-4 rounded-lg">
                            <div class="flex items-center justify-between mb-3">
                                <div class="flex items-center">
                                    <i class="fas fa-record-vinyl text-red-400 mr-2"></i>
                                    <span class="text-sm font-semibold text-red-400">Live Recording</span>
                                </div>
                                <div id="recordingIndicator" class="hidden flex items-center">
                                    <div class="w-2 h-2 bg-red-500 rounded-full animate-pulse mr-1"></div>
                                    <span class="text-xs text-red-400">Recording...</span>
                                </div>
                            </div>
                            
                            <!-- Mini Recording Sound Wave -->
                            <div id="recordingWave" class="hidden recording-wave-container mb-3">
                                <div class="recording-wave">
                                    <div class="recording-bar"></div>
                                    <div class="recording-bar"></div>
                                    <div class="recording-bar"></div>
                                    <div class="recording-bar"></div>
                                    <div class="recording-bar"></div>
                                </div>
                            </div>
                            
                            <div class="flex space-x-2">
                                <button id="recordBtn" onclick="startRecording()" class="bg-red-500 hover:bg-red-600 text-black flex-1 py-2 rounded-lg text-sm font-semibold transition-colors">
                                    <i class="fas fa-microphone mr-1 text-black"></i>Record
                                </button>
                                <button id="stopBtn" onclick="stopRecording()" disabled class="btn-secondary flex-1 py-2 rounded-lg text-sm opacity-50">
                                    <i class="fas fa-stop mr-1"></i>Stop
                                </button>
                            </div>
                            
                            <div id="recordedAudio" class="hidden mt-3">
                                <audio controls class="w-full">
                                    <source id="recordedAudioSource" src="" type="audio/wav">
                                </audio>
                            </div>
                        </div>
                    </div>
                        
                        <div class="space-y-3">
                            <div class="flex justify-between items-center">
                                <span class="text-sm font-semibold">Clone Quality</span>
                                <div class="flex space-x-1">
                                    <div class="w-2 h-4 bg-green-400 rounded animate-pulse"></div>
                                    <div class="w-2 h-4 bg-green-400 rounded animate-pulse" style="animation-delay: 0.1s"></div>
                                    <div class="w-2 h-4 bg-yellow-400 rounded animate-pulse" style="animation-delay: 0.2s"></div>
                                    <div class="w-2 h-4 bg-gray-600 rounded"></div>
                                    <div class="w-2 h-4 bg-gray-600 rounded"></div>
                                </div>
                            </div>
                            
                            <select id="cloneModel" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                <option value="enhanced">Enhanced Neural Model</option>
                                <option value="standard">Standard Clone</option>
                                <option value="premium">Premium Voice Synthesis</option>
                            </select>
                        </div>
                        
                        <button onclick="initiateVoiceClone()" class="btn-primary w-full py-3 rounded-lg font-semibold bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-400 hover:to-blue-500">
                            <i class="fas fa-flask mr-2"></i>Initialize Voice Clone
                        </button>
                        
                        <div id="cloningProgress" class="hidden mt-4">
                            <div class="bg-theme-primary p-3 rounded-lg">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="text-sm font-semibold text-cyan-400">Neural Processing...</span>
                                    <span class="text-xs text-theme-secondary" id="cloningPercent">0%</span>
                                </div>
                                <div class="w-full bg-gray-700 rounded-full h-2">
                                    <div id="cloningBar" class="bg-gradient-to-r from-cyan-500 to-blue-500 h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Audio Progress & Results -->
            <div class="mt-8 bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                <h2 class="text-xl font-bold mb-4">
                    <i class="fas fa-headphones text-cyan-400 mr-2"></i>
                    Narration Progress
                </h2>
                
                <div id="narrationProgress" class="hidden">
                    <div class="mb-4">
                        <div class="flex justify-between text-sm mb-2">
                            <span>Generating Audio...</span>
                            <span id="progressPercent">0%</span>
                        </div>
                        <div class="w-full bg-gray-300 rounded-full h-3">
                            <div id="progressBar" class="bg-cyan-400 h-3 rounded-full transition-all duration-300" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
                
                <div id="audioResults" class="space-y-4">
                    <!-- Generated audio files will appear here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Book Covers Page -->
    <div id="covers" class="page hidden">
        <div class="container mx-auto px-4 py-8">
            <h1 class="text-3xl font-bold mb-8">
                <i class="fas fa-image text-cyan-400 mr-3"></i>
                AI Book Cover Generator
            </h1>

            <!-- Platform Dimension Templates -->
            <div class="mb-8 bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                <h2 class="text-xl font-bold mb-4">
                    <i class="fas fa-ruler text-cyan-400 mr-2"></i>
                    Platform Dimension Templates
                </h2>
                <div class="grid md:grid-cols-3 lg:grid-cols-5 gap-4">
                    <button onclick="selectPlatformTemplate('audible')" class="platform-template p-3 rounded-lg bg-theme-primary border border-theme hover:border-cyan-400 transition-colors">
                        <div class="text-center">
                            <i class="fab fa-amazon text-orange-400 text-2xl mb-2"></i>
                            <div class="font-semibold text-sm">Audible</div>
                            <div class="text-xs text-theme-secondary">2400×2400px</div>
                        </div>
                    </button>
                    <button onclick="selectPlatformTemplate('spotify')" class="platform-template p-3 rounded-lg bg-theme-primary border border-theme hover:border-cyan-400 transition-colors">
                        <div class="text-center">
                            <i class="fab fa-spotify text-green-400 text-2xl mb-2"></i>
                            <div class="font-semibold text-sm">Spotify</div>
                            <div class="text-xs text-theme-secondary">3000×3000px</div>
                        </div>
                    </button>
                    <button onclick="selectPlatformTemplate('apple')" class="platform-template p-3 rounded-lg bg-theme-primary border border-theme hover:border-cyan-400 transition-colors">
                        <div class="text-center">
                            <i class="fab fa-apple text-gray-300 text-2xl mb-2"></i>
                            <div class="font-semibold text-sm">Apple</div>
                            <div class="text-xs text-theme-secondary">3000×3000px</div>
                        </div>
                    </button>
                    <button onclick="selectPlatformTemplate('google')" class="platform-template p-3 rounded-lg bg-theme-primary border border-theme hover:border-cyan-400 transition-colors">
                        <div class="text-center">
                            <i class="fab fa-google text-blue-400 text-2xl mb-2"></i>
                            <div class="font-semibold text-sm">Google Play</div>
                            <div class="text-xs text-theme-secondary">2400×2400px</div>
                        </div>
                    </button>
                    <button onclick="selectPlatformTemplate('overdrive')" class="platform-template p-3 rounded-lg bg-theme-primary border border-theme hover:border-cyan-400 transition-colors">
                        <div class="text-center">
                            <i class="fas fa-book text-purple-400 text-2xl mb-2"></i>
                            <div class="font-semibold text-sm">OverDrive</div>
                            <div class="text-xs text-theme-secondary">1800×2700px</div>
                        </div>
                    </button>
                </div>
                <div class="mt-4 text-sm text-theme-secondary">
                    <i class="fas fa-info-circle mr-2"></i>
                    Click a platform to auto-configure dimensions and optimization settings
                </div>
            </div>

            <div class="grid lg:grid-cols-2 gap-8">
                <!-- Cover Design Panel -->
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                    <h2 class="text-xl font-bold mb-4">
                        <i class="fas fa-palette text-cyan-400 mr-2"></i>
                        Design Your Cover
                    </h2>
                    
                    <div class="space-y-4">
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-semibold mb-2">Platform</label>
                                <select id="selectedPlatform" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                    <option value="universal">Universal (Square)</option>
                                    <option value="audible">Audible (2400×2400)</option>
                                    <option value="spotify">Spotify (3000×3000)</option>
                                    <option value="apple">Apple Podcasts (3000×3000)</option>
                                    <option value="google">Google Play (2400×2400)</option>
                                    <option value="overdrive">OverDrive (1800×2700)</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-semibold mb-2">Cover Style</label>
                                <select id="coverStyle" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                    <option value="modern">Modern & Clean</option>
                                    <option value="classic">Classic Literature</option>
                                    <option value="mysterious">Dark & Mysterious</option>
                                    <option value="romantic">Romantic & Elegant</option>
                                    <option value="fantasy">Fantasy Adventure</option>
                                    <option value="scifi">Sci-Fi Futuristic</option>
                                    <option value="horror">Horror & Thriller</option>
                                    <option value="children">Children's Colorful</option>
                                    <option value="business">Professional Business</option>
                                    <option value="memoir">Personal Memoir</option>
                                </select>
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">Book Title</label>
                            <input type="text" id="coverTitle" placeholder="Enter your book title..." 
                                   class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">Author Name</label>
                            <input type="text" id="coverAuthor" placeholder="Enter author name..." 
                                   class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">Subtitle (Optional)</label>
                            <input type="text" id="coverSubtitle" placeholder="Enter subtitle if any..." 
                                   class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">Visual Description</label>
                            <textarea id="coverDescription" placeholder="Describe the visual elements, mood, colors, and style for your book cover. Be specific about imagery, atmosphere, and design elements..." 
                                      class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary h-32 resize-none"></textarea>
                        </div>
                        
                        <div class="grid grid-cols-3 gap-4">
                            <div>
                                <label class="block text-sm font-semibold mb-2">Primary Color</label>
                                <input type="color" id="primaryColor" value="#06b6d4" 
                                       class="w-full h-12 rounded-lg border-2 border-theme cursor-pointer">
                            </div>
                            <div>
                                <label class="block text-sm font-semibold mb-2">Accent Color</label>
                                <input type="color" id="accentColor" value="#10b981" 
                                       class="w-full h-12 rounded-lg border-2 border-theme cursor-pointer">
                            </div>
                            <div>
                                <label class="block text-sm font-semibold mb-2">Text Color</label>
                                <input type="color" id="textColor" value="#ffffff" 
                                       class="w-full h-12 rounded-lg border-2 border-theme cursor-pointer">
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-semibold mb-2">Image Quality</label>
                                <select id="imageQuality" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                    <option value="standard">Standard (1024×1024)</option>
                                    <option value="hd" selected>HD (1792×1024)</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-semibold mb-2">Art Style</label>
                                <select id="artStyle" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                    <option value="photorealistic">Photorealistic</option>
                                    <option value="digital-art">Digital Art</option>
                                    <option value="illustration">Illustration</option>
                                    <option value="painting">Oil Painting</option>
                                    <option value="minimalist">Minimalist</option>
                                    <option value="vintage">Vintage</option>
                                </select>
                            </div>
                        </div>
                        
                        <button onclick="generateAICover()" class="btn-primary w-full py-3 rounded-lg font-semibold bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-400 hover:to-blue-500">
                            <i class="fas fa-magic mr-2"></i>Generate Cover
                        </button>
                    </div>
                </div>
                
                <!-- Cover Preview Panel -->
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                    <h2 class="text-xl font-bold mb-4">
                        <i class="fas fa-eye text-cyan-400 mr-2"></i>
                        Cover Preview & Variations
                    </h2>
                    
                    <div id="coverPreviewPanel">
                        <div class="bg-theme-primary border-2 border-dashed border-theme rounded-lg p-8 mb-4 text-center" id="placeholderPreview">
                            <i class="fas fa-image text-6xl text-theme-secondary mb-4"></i>
                            <p class="text-theme-secondary">Generate your AI cover to see preview</p>
                            <p class="text-xs text-theme-secondary mt-2">Dimensions will adjust based on selected platform</p>
                        </div>
                        
                        <div id="coverPreview" class="hidden">
                            <div class="text-center mb-4">
                                <div class="inline-block relative">
                                    <img id="generatedCover" src="" alt="Generated Book Cover" class="max-w-full h-auto rounded-lg shadow-lg border-2 border-theme">
                                    <div class="absolute top-2 right-2 bg-black bg-opacity-75 text-white text-xs px-2 py-1 rounded" id="dimensionDisplay">
                                        2400×2400px
                                    </div>
                                </div>
                            </div>
                            
                            <div class="space-y-3">
                                <div class="flex justify-center space-x-2">
                                    <button onclick="regenerateAICover()" class="btn-secondary px-4 py-2 rounded text-sm">
                                        <i class="fas fa-sync mr-1"></i>Regenerate
                                    </button>
                                    <button onclick="createVariations()" class="btn-secondary px-4 py-2 rounded text-sm">
                                        <i class="fas fa-clone mr-1"></i>Variations
                                    </button>
                                    <button onclick="downloadCover()" class="btn-primary px-4 py-2 rounded text-sm">
                                        <i class="fas fa-download mr-1"></i>Download
                                    </button>
                                </div>
                                
                                <div class="grid grid-cols-2 gap-2">
                                    <button onclick="downloadForPlatform('print')" class="btn-secondary w-full py-2 rounded text-xs">
                                        <i class="fas fa-print mr-1"></i>Print Ready
                                    </button>
                                    <button onclick="downloadForPlatform('web')" class="btn-secondary w-full py-2 rounded text-xs">
                                        <i class="fas fa-globe mr-1"></i>Web Optimized
                                    </button>
                                </div>
                                
                                <button onclick="setCoverAsMain()" class="btn-primary w-full py-2 rounded text-sm">
                                    <i class="fas fa-check mr-1"></i>Use as Main Cover
                                </button>
                            </div>
                        </div>
                        
                        <!-- Cover Variations -->
                        <div id="coverVariations" class="hidden mt-6">
                            <h3 class="text-lg font-semibold mb-4">AI Generated Variations</h3>
                            <div class="grid grid-cols-2 gap-4" id="variationsGrid">
                                <!-- Variations will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Generation Progress -->
            <div id="coverGenerationProgress" class="hidden mt-8 bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                <h3 class="text-lg font-semibold mb-4">
                    <i class="fas fa-magic text-cyan-400 mr-2 animate-spin"></i>
                    AI Cover Generation in Progress
                </h3>
                
                <div class="space-y-4">
                    <div class="flex items-center justify-between">
                        <span class="text-sm" id="generationStep">Analyzing design preferences...</span>
                        <div class="w-6 h-6 border-2 border-cyan-400 border-t-transparent rounded-full animate-spin"></div>
                    </div>
                    
                    <div class="w-full bg-theme-primary rounded-full h-3">
                        <div id="coverProgressBar" class="bg-gradient-to-r from-cyan-500 to-blue-500 h-3 rounded-full transition-all duration-500" style="width: 0%"></div>
                    </div>
                    
                    <div class="text-xs text-theme-secondary text-center">
                        <div id="progressMessage">Processing with OpenAI DALL-E API...</div>
                        <div class="mt-1">High-quality generation typically takes 10-30 seconds</div>
                    </div>
                </div>
            </div>

            <!-- Platform Requirements Info -->
            <div class="mt-8 bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                <h3 class="text-lg font-semibold mb-4">
                    <i class="fas fa-info-circle text-cyan-400 mr-2"></i>
                    Platform Requirements & Guidelines
                </h3>
                
                <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-4 text-sm">
                    <div class="bg-theme-primary p-4 rounded-lg">
                        <h4 class="font-semibold text-orange-400 mb-2"><i class="fab fa-amazon mr-1"></i> Audible</h4>
                        <ul class="space-y-1 text-theme-secondary">
                            <li>• 2400×2400px minimum</li>
                            <li>• Square aspect ratio</li>
                            <li>• RGB color space</li>
                            <li>• Text must be readable at 150px</li>
                        </ul>
                    </div>
                    
                    <div class="bg-theme-primary p-4 rounded-lg">
                        <h4 class="font-semibold text-green-400 mb-2"><i class="fab fa-spotify mr-1"></i> Spotify</h4>
                        <ul class="space-y-1 text-theme-secondary">
                            <li>• 3000×3000px recommended</li>
                            <li>• Square format required</li>
                            <li>• High contrast text</li>
                            <li>• No promotional text</li>
                        </ul>
                    </div>
                    
                    <div class="bg-theme-primary p-4 rounded-lg">
                        <h4 class="font-semibold text-gray-300 mb-2"><i class="fab fa-apple mr-1"></i> Apple</h4>
                        <ul class="space-y-1 text-theme-secondary">
                            <li>• 3000×3000px minimum</li>
                            <li>• Square aspect ratio</li>
                            <li>• 72 DPI minimum</li>
                            <li>• Clear, legible text</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Page -->
    <div id="export" class="page hidden">
        <div class="container mx-auto px-4 py-8">
            <h1 class="text-3xl font-bold mb-8">
                <i class="fas fa-download text-cyan-400 mr-3"></i>
                Export Your Audiobook
            </h1>

            <!-- Export Options -->
            <div class="grid md:grid-cols-2 gap-8 mb-8">
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                    <h2 class="text-xl font-bold mb-4">
                        <i class="fas fa-file-archive text-cyan-400 mr-2"></i>
                        Package Options
                    </h2>
                    
                    <div class="space-y-4">
                        <div class="border border-theme p-4 rounded-lg">
                            <div class="flex items-center justify-between mb-2">
                                <h3 class="font-semibold">Complete Audiobook Package</h3>
                                <button class="btn-primary px-4 py-1 rounded text-sm">Download</button>
                            </div>
                            <p class="text-sm text-theme-secondary">All audio files, cover image, and metadata in ZIP format</p>
                        </div>
                        
                        <div class="border border-theme p-4 rounded-lg">
                            <div class="flex items-center justify-between mb-2">
                                <h3 class="font-semibold">Audio Files Only</h3>
                                <button class="btn-secondary px-4 py-1 rounded text-sm">Download</button>
                            </div>
                            <p class="text-sm text-theme-secondary">MP3 files for each chapter</p>
                        </div>
                        
                        <div class="border border-theme p-4 rounded-lg">
                            <div class="flex items-center justify-between mb-2">
                                <h3 class="font-semibold">Text Manuscript</h3>
                                <button class="btn-secondary px-4 py-1 rounded text-sm">Download</button>
                            </div>
                            <p class="text-sm text-theme-secondary">Complete story text in DOC/PDF format</p>
                        </div>
                    </div>
                </div>
                
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                    <h2 class="text-xl font-bold mb-4">
                        <i class="fas fa-share-alt text-cyan-400 mr-2"></i>
                        Publishing Options
                    </h2>
                    
                    <div class="space-y-4">
                        <div class="border border-theme p-4 rounded-lg">
                            <h3 class="font-semibold mb-2">Audible Ready</h3>
                            <p class="text-sm text-theme-secondary mb-3">Format optimized for Audible submission</p>
                            <button class="btn-primary px-4 py-1 rounded text-sm w-full">Prepare for Audible</button>
                        </div>
                        
                        <div class="border border-theme p-4 rounded-lg">
                            <h3 class="font-semibold mb-2">Podcast Format</h3>
                            <p class="text-sm text-theme-secondary mb-3">Individual episodes with RSS feed</p>
                            <button class="btn-secondary px-4 py-1 rounded text-sm w-full">Generate Podcast</button>
                        </div>
                        
                        <div class="border border-theme p-4 rounded-lg">
                            <h3 class="font-semibold mb-2">YouTube Series</h3>
                            <p class="text-sm text-theme-secondary mb-3">Video format with static cover image</p>
                            <button class="btn-secondary px-4 py-1 rounded text-sm w-full">Create Video Series</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Project Summary -->
            <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                <h2 class="text-xl font-bold mb-4">
                    <i class="fas fa-info-circle text-cyan-400 mr-2"></i>
                    Project Summary
                </h2>
                
                <div class="grid md:grid-cols-3 gap-6">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-cyan-400 mb-1" id="exportChapterCount">10</div>
                        <div class="text-sm text-theme-secondary">Chapters</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-cyan-400 mb-1" id="exportTotalWords">10,000</div>
                        <div class="text-sm text-theme-secondary">Total Words</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-cyan-400 mb-1" id="exportDuration">~2.5 hours</div>
                        <div class="text-sm text-theme-secondary">Audio Duration</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Config Page -->
    <div id="config" class="page hidden">
        <div class="container mx-auto px-4 py-8">
            <h1 class="text-3xl font-bold mb-8">
                <i class="fas fa-cog text-cyan-400 mr-3"></i>
                Configuration & Settings
            </h1>

            <!-- API Configuration -->
            <div class="grid lg:grid-cols-2 gap-8 mb-8">
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                    <h2 class="text-xl font-bold mb-4">
                        <i class="fas fa-key text-cyan-400 mr-2"></i>
                        API Configuration
                    </h2>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold mb-2">OpenAI API Key</label>
                            <input type="password" id="openaiKey" placeholder="sk-..." 
                                   class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                            <p class="text-xs text-theme-secondary mt-1">Required for AI writing and narration features</p>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">ElevenLabs API Key</label>
                            <input type="password" id="elevenlabsKey" placeholder="Enter your ElevenLabs API key..." 
                                   class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                            <p class="text-xs text-theme-secondary mt-1">Optional: Enables advanced voice cloning and additional voices</p>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">Model Selection</label>
                            <select id="modelSelection" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                <option value="gpt-4o-mini" selected>GPT-4o-mini (Recommended)</option>
                                <option value="gpt-3.5-turbo">GPT-3.5-turbo (Faster)</option>
                                <option value="gpt-4">GPT-4 (Premium)</option>
                            </select>
                        </div>
                        
                        <div class="space-y-2">
                            <button onclick="testApiConnection()" class="btn-primary w-full py-2 rounded-lg font-semibold">
                                <i class="fas fa-wifi mr-2"></i>Test API Connection
                            </button>
                            <button onclick="saveSettings()" class="btn-secondary w-full py-2 rounded-lg font-semibold">
                                <i class="fas fa-save mr-2"></i>Save Settings
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                    <h2 class="text-xl font-bold mb-4">
                        <i class="fas fa-palette text-cyan-400 mr-2"></i>
                        Appearance Settings
                    </h2>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold mb-2">Theme</label>
                            <div class="grid grid-cols-2 gap-2">
                                <button onclick="setTheme('light')" class="p-3 rounded-lg border-2 border-theme bg-white text-black">
                                    <i class="fas fa-sun mb-1"></i><br>Light
                                </button>
                                <button onclick="setTheme('dark')" class="p-3 rounded-lg border-2 border-theme bg-gray-800 text-white">
                                    <i class="fas fa-moon mb-1"></i><br>Dark
                                </button>
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">Font Size</label>
                            <select id="fontSize" class="w-full px-4 py-2 rounded-lg form-field bg-theme-primary text-theme-primary">
                                <option value="small">Small</option>
                                <option value="medium" selected>Medium</option>
                                <option value="large">Large</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold mb-2">Auto-save</label>
                            <label class="flex items-center">
                                <input type="checkbox" id="autoSave" checked class="mr-2">
                                <span>Automatically save work every 30 seconds</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- About & Help -->
            <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                <h2 class="text-xl font-bold mb-4">
                    <i class="fas fa-info text-cyan-400 mr-2"></i>
                    About AUTHORR AI
                </h2>
                
                <div class="grid md:grid-cols-2 gap-8">
                    <div>
                        <h3 class="font-semibold mb-2">Platform Information</h3>
                        <ul class="text-sm space-y-1 text-theme-secondary">
                            <li>• Version: 2.5 Fixed Platform</li>
                            <li>• AI Model: GPT-4o-mini with TTS-1-HD</li>
                            <li>• Voice Options: 6 Professional AI Voices</li>
                            <li>• Image Generation: DALL-E 3 HD Quality</li>
                            <li>• Max Chapters: 25 per audiobook</li>
                            <li>• Max Words: 3,000 per chapter</li>
                        </ul>
                    </div>
                    
                    <div>
                        <h3 class="font-semibold mb-2">Support & Resources</h3>
                        <div class="space-y-2">
                            <button class="btn-secondary w-full py-2 rounded text-sm">
                                <i class="fas fa-book mr-1"></i>User Guide
                            </button>
                            <button class="btn-secondary w-full py-2 rounded text-sm">
                                <i class="fas fa-video mr-1"></i>Video Tutorials
                            </button>
                            <button class="btn-secondary w-full py-2 rounded text-sm">
                                <i class="fas fa-life-ring mr-1"></i>Contact Support
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-theme-secondary p-8 rounded-xl border-2 border-cyan-400 text-center">
            <div class="loading-content">
                <div class="book-loader">
                    <div class="book-spine"></div>
                    <div class="book-pages"></div>
                    <div class="book-pages"></div>
                    <div class="book-pages"></div>
                </div>
                <div class="loading-spinner mx-auto" style="display: none;"></div>
            </div>
            <p id="loadingText" class="text-lg font-semibold">Processing...</p>
        </div>
    </div>

    <script>
        // Global State Management
        let currentPage = 'dashboard';
        let storyData = {
            title: '',
            chapters: [],
            currentChapter: 0,
            settings: {
                chapterCount: 10,
                wordsPerChapter: 1000,
                genre: 'fiction-literary',
                tone: 'professional'
            }
        };
        
        // History management for undo/redo
        let editHistory = [];
        let historyIndex = -1;
        const maxHistorySize = 50;
        
        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            loadSettings();
            updateWordCount();
            setupAutoSave();
            
            // Initialize undo/redo system
            const editor = document.getElementById('storyEditor');
            if (editor) {
                // Save initial state
                saveEditState();
                
                // Auto-save on content changes (debounced)
                let saveTimeout;
                editor.addEventListener('input', function() {
                    clearTimeout(saveTimeout);
                    saveTimeout = setTimeout(() => {
                        saveEditState();
                    }, 1000); // Save after 1 second of no typing
                });
            }
            
            // Initialize button states
            updateUndoRedoButtons();
        });
        
        // Page Navigation
        function showPage(pageId, clickEvent = null) {
            document.querySelectorAll('.page').forEach(page => page.classList.add('hidden'));
            document.getElementById(pageId).classList.remove('hidden');
            
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            if (clickEvent && clickEvent.target) {
                clickEvent.target.classList.add('active');
            }
            
            currentPage = pageId;
            
            // Transfer story data when navigating to narration
            if (pageId === 'narration') {
                transferStoryToNarration();
            }
        }
        
        // Theme Management
        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.getElementById('themeIcon');
            
            if (body.classList.contains('theme-light')) {
                body.classList.remove('theme-light');
                body.classList.add('theme-dark');
                themeIcon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
            } else {
                body.classList.remove('theme-dark');
                body.classList.add('theme-light');
                themeIcon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
            }
        }
        
        function setTheme(theme) {
            const body = document.body;
            const themeIcon = document.getElementById('themeIcon');
            
            body.className = `theme-${theme}`;
            themeIcon.className = theme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
            localStorage.setItem('theme', theme);
        }
        
        function loadSettings() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            setTheme(savedTheme);
            
            // Load API key if saved
            const apiKey = localStorage.getItem('openai_api_key');
            if (apiKey) {
                document.getElementById('openaiKey').value = apiKey;
            }
        }
        
        // Story Generation Functions
        async function generateChapterPlan() {
            const title = document.getElementById('bookTitle').value;
            const chapterCount = parseInt(document.getElementById('chapterCount').value);
            const wordsPerChapter = parseInt(document.getElementById('wordsPerChapter').value);
            const genre = document.getElementById('genre').value;
            const tone = document.getElementById('tone').value;
            const outline = document.getElementById('storyOutline').value;
            
            if (!title || !outline) {
                alert('Please enter a book title and story outline.');
                return;
            }
            
            showLoading('Generating comprehensive chapter plan...');
            
            try {
                // Enhanced AI API call simulation for chapter planning
                const chapterPlan = await simulateEnhancedChapterGeneration(title, chapterCount, genre, tone, outline);
                displayEnhancedChapterPlan(chapterPlan);
                
                // Update story data
                storyData.title = title;
                storyData.settings = { chapterCount, wordsPerChapter, genre, tone, outline };
                storyData.chapters = chapterPlan.map(chapter => ({ ...chapter, content: '' }));
                
                document.getElementById('generateAllBtn').disabled = false;
                hideLoading();
            } catch (error) {
                console.error('Chapter generation error:', error);
                alert('Failed to generate chapter plan. Please try again.');
                hideLoading();
            }
        }
        
        async function simulateEnhancedChapterGeneration(title, chapterCount, genre, tone, outline) {
            // Simulate API delay
            await new Promise(resolve => setTimeout(resolve, 2500));
            
            const chapters = [];
            const detailedSummaries = generateDetailedSummaries(genre, tone, outline, chapterCount);
            const chapterTitles = generateChapterTitles(genre, chapterCount);
            
            for (let i = 1; i <= chapterCount; i++) {
                chapters.push({
                    number: i,
                    title: `Chapter ${i}: ${chapterTitles[i-1]}`,
                    summary: detailedSummaries[i-1],
                    wordTarget: parseInt(document.getElementById('wordsPerChapter').value),
                    editable: true,
                    status: 'ready'
                });
            }
            return chapters;
        }
        
        function generateDetailedSummaries(genre, tone, outline, chapterCount) {
            const summaries = {
                'fiction-mystery': [
                    'Introduce the detective protagonist and establish the mysterious crime that will drive the investigation forward. Set the scene and atmosphere.',
                    'The first clues emerge as the detective begins interviewing witnesses and examining evidence. Red herrings and false leads create complexity.',
                    'A breakthrough occurs when a crucial piece of evidence is discovered, but it only deepens the mystery and raises more disturbing questions.',
                    'The investigation takes a dangerous turn as someone attempts to stop the detective, suggesting the killer is still active and watching.',
                    'All the pieces of the puzzle begin to come together in a shocking revelation that changes everything the detective thought they knew.',
                    'The final confrontation between detective and killer, with the truth finally revealed and justice served in a dramatic climax.',
                    'Epilogue: The aftermath of the case and how the events have permanently changed both the detective and the community.',
                ],
                'fiction-romance': [
                    'The meet-cute: Two characters encounter each other in an unexpected and memorable way, with instant chemistry despite initial resistance.',
                    'Growing attraction develops despite external obstacles and personal misunderstandings that seem to keep them apart.',
                    'A moment of deep emotional connection brings them closer together, revealing vulnerable sides of both characters.',
                    'Major conflict arises - external pressures or internal fears threaten to tear the couple apart just as love begins to bloom.',
                    'The dark moment when all seems lost and true love appears impossible due to circumstances beyond their control.',
                    'The grand romantic gesture and heartfelt confession that overcomes all obstacles and wins back their one true love.',
                    'Happy ending with the couple united, planning their future together, and having grown as individuals through their journey.',
                ],
                'fiction-fantasy': [
                    'The ordinary world before magic enters the protagonist\'s life. Establish the character\'s mundane existence and hidden potential.',
                    'The call to adventure arrives when magical forces thrust the hero into an extraordinary quest they cannot refuse.',
                    'Meeting magical allies and discovering ancient powers or prophecies that reveal the true scope of the hero\'s destiny.',
                    'The first major challenge tests the hero\'s newfound abilities against dark forces, with mixed success and important lessons.',
                    'The ultimate confrontation with the primary antagonist in an epic battle between good and evil that will determine the fate of the realm.',
                    'Victory is achieved, but at great personal cost. The hero must make difficult sacrifices to save others and fulfill their destiny.',
                    'Return to the ordinary world, forever changed by the magical journey. The hero integrates their experiences into a new life.',
                ],
                'fiction-scifi': [
                    'Establish the futuristic or alien setting while introducing the protagonist and the scientific/technological premise.',
                    'The discovery or invention that changes everything, setting the main technological conflict into motion.',
                    'Exploring the implications and consequences of the new technology or alien contact on society and individuals.',
                    'Rising conflict as the protagonist must navigate political, ethical, or survival challenges in this new reality.',
                    'The climactic confrontation where science, technology, or first contact reaches a critical turning point.',
                    'Resolution of the technological crisis with wisdom gained about progress, humanity, or our place in the universe.',
                    'New equilibrium: How the world has changed and what the future now holds for humanity.',
                ]
            };
            
            const defaultSummaries = [
                'Setting the scene and introducing the main characters in their world, establishing the tone and central premise.',
                'The inciting incident occurs, disrupting the status quo and setting the main plot into unstoppable motion.',
                'Rising action as characters face their first major challenges, revealing personality and building relationships.',
                'Complications arise that deepen the conflict, raise the stakes, and test character resolve and relationships.',
                'The climax arrives - the turning point where everything hangs in the balance and characters face their greatest test.',
                'Falling action begins as the main conflict moves toward resolution and characters deal with consequences.',
                'Resolution and conclusion, tying up loose ends, showing character growth, and providing satisfying closure.',
            ];
            
            const genreSummaries = summaries[genre] || defaultSummaries;
            
            // Extend or customize summaries to match chapter count
            const result = [];
            for (let i = 0; i < chapterCount; i++) {
                if (i < genreSummaries.length) {
                    result.push(genreSummaries[i]);
                } else {
                    // Generate additional summaries for longer books
                    const baseIndex = i % genreSummaries.length;
                    result.push(`Chapter ${i + 1}: Continuing the ${genre.replace('-', ' ')} narrative with ${tone} tone, building toward the climactic conclusion.`);
                }
            }
            
            return result;
        }
        
        function generateChapterTitles(genre, chapterCount) {
            const titleTemplates = {
                'fiction-mystery': [
                    'The Crime Scene', 'First Clues', 'Witnesses Speak', 'Hidden Motives', 'False Leads', 
                    'Breaking Point', 'The Truth Emerges', 'Final Confrontation', 'Justice Served'
                ],
                'fiction-romance': [
                    'Unexpected Encounter', 'Growing Attraction', 'First Kiss', 'Complications', 
                    'Heartbreak', 'Realization', 'Grand Gesture', 'Forever Together'
                ],
                'fiction-fantasy': [
                    'The Calling', 'Into the Unknown', 'Ancient Powers', 'Dark Forces', 
                    'The Prophecy', 'Final Battle', 'Victory\'s Price', 'New Dawn'
                ],
                'fiction-scifi': [
                    'Discovery', 'First Contact', 'New Worlds', 'Alien Minds', 
                    'Technology\'s Edge', 'The Singularity', 'Evolution', 'Future Awakens'
                ]
            };
            
            const defaultTitles = [
                'Beginning', 'Rising Action', 'Development', 'Complication', 
                'Climax', 'Resolution', 'Conclusion'
            ];
            
            const titles = titleTemplates[genre] || defaultTitles;
            const result = [];
            
            for (let i = 0; i < chapterCount; i++) {
                if (i < titles.length) {
                    result.push(titles[i]);
                } else {
                    result.push(`Part ${i + 1}`);
                }
            }
            
            return result;
        }
        
        function displayEnhancedChapterPlan(chapters) {
            const planContainer = document.getElementById('chapterPlan');
            planContainer.innerHTML = chapters.map(chapter => `
                <div class="border border-theme p-3 rounded-lg bg-theme-primary" id="chapter-${chapter.number}">
                    <div class="flex justify-between items-start mb-2">
                        <h3 class="font-semibold text-sm editable-title" 
                            contenteditable="true" 
                            onblur="updateChapterTitle(${chapter.number}, this.textContent)"
                            data-original="${chapter.title}">${chapter.title}</h3>
                        <div class="flex space-x-1">
                            <button onclick="editChapter(${chapter.number})" class="btn-secondary px-2 py-1 rounded text-xs" title="Edit Chapter">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button onclick="generateSingleChapter(${chapter.number})" class="btn-primary px-2 py-1 rounded text-xs" title="Generate Story">
                                <i class="fas fa-magic"></i>
                            </button>
                        </div>
                    </div>
                    <p class="text-xs text-theme-secondary mb-2 editable-summary" 
                       contenteditable="true" 
                       onblur="updateChapterSummary(${chapter.number}, this.textContent)"
                       data-original="${chapter.summary}">${chapter.summary}</p>
                    <div class="text-xs text-cyan-400 mb-1">Target: ${chapter.wordTarget} words</div>
                    <div class="chapter-status status-${chapter.status} text-xs" id="chapter-status-${chapter.number}">
                        Ready to generate story content
                    </div>
                </div>
            `).join('');
        }
        
        function updateChapterTitle(chapterNum, newTitle) {
            const chapterIndex = chapterNum - 1;
            if (storyData.chapters[chapterIndex]) {
                storyData.chapters[chapterIndex].title = newTitle.trim();
                console.log(`Updated chapter ${chapterNum} title:`, newTitle);
                showStatusMessage(`Chapter ${chapterNum} title updated`);
            }
        }
        
        function updateChapterSummary(chapterNum, newSummary) {
            const chapterIndex = chapterNum - 1;
            if (storyData.chapters[chapterIndex]) {
                storyData.chapters[chapterIndex].summary = newSummary.trim();
                console.log(`Updated chapter ${chapterNum} summary:`, newSummary);
                showStatusMessage(`Chapter ${chapterNum} summary updated`);
            }
        }
        
        function editChapter(chapterNum) {
            try {
                const chapterDiv = document.getElementById(`chapter-${chapterNum}`);
                if (!chapterDiv) {
                    showNotification(`Chapter ${chapterNum} not found`, 'error');
                    return;
                }
                
                const titleEl = chapterDiv.querySelector('.editable-title');
                const summaryEl = chapterDiv.querySelector('.editable-summary');
                
                if (!titleEl || !summaryEl) {
                    showNotification('Chapter elements not found', 'error');
                    return;
                }
                
                // Highlight for editing
                titleEl.focus();
                titleEl.style.backgroundColor = 'rgba(120, 227, 254, 0.1)';
                summaryEl.style.backgroundColor = 'rgba(120, 227, 254, 0.1)';
                
                // Show edit instruction
                showNotification(`Editing Chapter ${chapterNum} - Click outside when done`, 'info');
                
                // Remove highlight after editing
                setTimeout(() => {
                    titleEl.style.backgroundColor = '';
                    summaryEl.style.backgroundColor = '';
                }, 5000);
                
            } catch (error) {
                console.error('Edit chapter error:', error);
                showNotification('Failed to edit chapter', 'error');
            }
        }
        
        async function generateAllChapters() {
            console.log('📚 Generating ALL chapter content - clearing old dialogue data...');
            
            // Clear dialogue data when generating new story content
            clearAllDialogueData(true);
            
            if (!storyData.chapters || storyData.chapters.length === 0) {
                showNotification('Please generate a chapter plan first.', 'error');
                return;
            }
            
            const apiKey = getOpenAIApiKey();
            if (!apiKey) {
                showNotification('Please configure your OpenAI API key first', 'error');
                return;
            }
            
            showNotification('Generating all chapter content...', 'info');
            
            try {
                let allContent = '';
                let successCount = 0;
                
                for (let i = 0; i < storyData.chapters.length; i++) {
                    const chapter = storyData.chapters[i];
                    const chapterNumber = chapter.number || (i + 1);
                    
                    showNotification(`Generating Chapter ${chapterNumber} of ${storyData.chapters.length}...`, 'info');
                    
                    try {
                        // Generate content for this chapter
                        await generateChapterContent(chapterNumber);
                        
                        // Get the generated content from the chapter
                        const chapterContent = chapter.content || '';
                        if (chapterContent.trim()) {
                            allContent += `\n\n=== Chapter ${chapterNumber}: ${chapter.title || 'Untitled'} ===\n\n${chapterContent}`;
                            successCount++;
                            
                            // Update chapter status with actual word count
                            updateChapterStatus(chapterNumber, 'complete', `Story complete (${countWords(chapterContent)} words)`);
                            showNotification(`Chapter ${chapterNumber} generated successfully (${countWords(chapterContent)} words)`, 'success');
                        } else {
                            updateChapterStatus(chapterNumber, 'error', 'Failed to generate');
                            showNotification(`Chapter ${chapterNumber}: No content generated`, 'warning');
                        }
                    } catch (chapterError) {
                        console.error(`Error generating chapter ${chapterNumber}:`, chapterError);
                        updateChapterStatus(chapterNumber, 'error', 'Generation failed');
                        showNotification(`Failed to generate Chapter ${chapterNumber}: ${chapterError.message}`, 'error');
                        // Continue with next chapter instead of stopping
                    }
                    
                    // Small delay between chapters to prevent rate limiting
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                // Add all content to Story Editor if any was generated
                if (allContent.trim()) {
                    addToStoryEditor(allContent.trim());
                    showNotification(`Successfully generated ${successCount}/${storyData.chapters.length} chapters! Content added to Story Editor.`, 'success');
                } else {
                    showNotification('No content was generated for any chapters. Please check your API key and try again.', 'error');
                }
                
            } catch (error) {
                console.error('Chapter generation error:', error);
                showNotification(`Failed to generate all chapters: ${error.message}`, 'error');
            }
        }
        
        function updateChapterStatus(chapterNum, status, message) {
            const statusEl = document.getElementById(`chapter-status-${chapterNum}`);
            if (statusEl) {
                statusEl.className = `chapter-status status-${status} text-xs`;
                statusEl.textContent = message;
            }
        }
        
        // Add content to Story Editor
        function addToStoryEditor(content) {
            const editor = document.getElementById('storyEditor');
            if (editor) {
                if (editor.value.trim()) {
                    editor.value += '\n\n' + content;
                } else {
                    editor.value = content;
                }
                
                // Update word count if function exists
                if (typeof updateWordCount === 'function') {
                    updateWordCount();
                }
                
                // Switch to workspace to show the editor
                showPage('workspace');
                
                // Scroll to editor
                setTimeout(() => {
                    editor.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 500);
            }
        }
        
        async function generateSingleChapter(chapterNumber) {
            const chapterIndex = chapterNumber - 1;
            if (!storyData.chapters[chapterIndex]) return '';
            
            const chapter = storyData.chapters[chapterIndex];
            
            try {
                updateChapterStatus(chapterNumber, 'generating', 'Creating story content...');
                
                // Enhanced content generation
                const content = await simulateEnhancedContentGeneration(chapter, storyData.settings);
                storyData.chapters[chapterIndex].content = content;
                
                // If this is the current chapter being viewed, update editor
                if (storyData.currentChapter === chapterIndex) {
                    document.getElementById('storyEditor').value = content;
                    updateWordCount();
                    saveToHistory();
                }
                
                updateChapterStatus(chapterNumber, 'complete', `Complete (${countWords(content)} words)`);
                return content;
                
            } catch (error) {
                console.error('Single chapter generation error:', error);
                updateChapterStatus(chapterNumber, 'ready', 'Error - Ready to retry');
                throw error;
            }
        }
        
        async function simulateEnhancedContentGeneration(chapter, settings) {
            // Simulate AI API delay
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            const { title, summary, wordTarget } = chapter;
            const { genre, tone } = settings;
            
            // Generate more realistic content based on chapter info
            let content = `${title}\n\n`;
            
            // Generate introduction
            content += generateChapterIntroduction(summary, genre, tone) + '\n\n';
            
            // Calculate paragraphs needed (aim for 150-200 words per paragraph)
            const wordsPerParagraph = 150;
            const paragraphCount = Math.ceil(wordTarget / wordsPerParagraph);
            
            // Generate main content paragraphs
            for (let i = 0; i < paragraphCount - 1; i++) {
                content += generateContentParagraph(genre, tone, summary, i + 1) + '\n\n';
            }
            
            // Generate conclusion paragraph
            content += generateChapterConclusion(summary, genre, tone);
            
            return content.trim();
        }
        
        function generateChapterIntroduction(summary, genre, tone) {
            const intros = {
                'fiction-mystery': [
                    'The morning mist hung heavy over the crime scene as Detective Morrison arrived, coffee still steaming in her hand. What she was about to discover would change everything she thought she knew about this case.',
                    'The call came at 3:47 AM, jarring Detective Chen from a restless sleep. Another body had been found, and the pattern was becoming disturbingly clear.',
                    'Something was wrong with this picture. Detective Rodriguez stood at the edge of the scene, her trained eye catching details that others had missed.'
                ],
                'fiction-romance': [
                    'Sarah had always believed that love at first sight was a myth—until she walked into that coffee shop on a rainy Tuesday morning and saw him.',
                    'The wedding invitation fell from Emma\'s hands like autumn leaves, each word on the elegant cardstock a reminder of what she had lost.',
                    'Marcus had sworn off relationships after his last heartbreak, but when she smiled at him across the bookstore aisle, all his carefully built walls began to crumble.'
                ]
            };
            
            const defaultIntros = [
                'The chapter begins with our protagonist facing a new challenge that will test their resolve and change their perspective.',
                'As events unfold, the characters find themselves in a situation that demands courage and quick thinking.',
                'The story takes an unexpected turn as hidden truths begin to surface and relationships are put to the test.'
            ];
            
            const genreIntros = intros[genre] || defaultIntros;
            return genreIntros[Math.floor(Math.random() * genreIntros.length)];
        }
        
        function generateContentParagraph(genre, tone, summary, position) {
            const paragraphs = {
                'fiction-mystery': [
                    'The evidence pointed in multiple directions, each clue seeming to contradict the last. The detective methodically examined each piece, knowing that somewhere in this puzzle lay the truth.',
                    'Witnesses provided conflicting accounts, their memories clouded by fear and confusion. Separating fact from fiction would require patience and skill.',
                    'A breakthrough came from an unexpected source—a detail so small that others had overlooked it entirely. Sometimes the smallest threads unravel the biggest mysteries.',
                    'The investigation took a darker turn as threats began to surface. Someone was desperate to keep these secrets buried, but the truth had a way of demanding to be heard.'
                ],
                'fiction-romance': [
                    'Their conversations flowed like music, each word building a bridge between two hearts that had been waiting to find each other.',
                    'The obstacles seemed insurmountable—family expectations, career demands, and the fear of vulnerability all conspired to keep them apart.',
                    'In quiet moments together, they discovered that love wasn\'t just about grand gestures but about the small, tender moments that made life meaningful.',
                    'Misunderstandings clouded their judgment, and pride kept them from speaking the words that could heal the growing distance between them.'
                ]
            };
            
            const defaultParagraphs = [
                'The characters navigated through challenges that tested their beliefs and forced them to grow beyond their comfort zones.',
                'Relationships deepened and evolved as trust was built through shared experiences and mutual support during difficult times.',
                'Conflicts arose that revealed the true nature of each character, showing both their strengths and their vulnerabilities.',
                'Resolution began to emerge as the characters learned to work together and understand each other\'s perspectives.'
            ];
            
            const genreParagraphs = paragraphs[genre] || defaultParagraphs;
            return genreParagraphs[position % genreParagraphs.length];
        }
        
        function generateChapterConclusion(summary, genre, tone) {
            const conclusions = {
                'fiction-mystery': [
                    'As the chapter drew to a close, one crucial question remained unanswered, its significance growing like a shadow over the investigation.',
                    'The detective gathered the pieces of evidence, each one forming part of a larger picture that was finally beginning to emerge from the darkness.',
                    'With new leads to follow and fresh determination, the investigation moved forward, bringing both hope and trepidation for what lay ahead.'
                ],
                'fiction-romance': [
                    'As they parted ways that evening, both carried with them a new understanding of what their hearts truly desired.',
                    'The chapter ended with a promise—spoken or unspoken—that their story was far from over.',
                    'Love had planted seeds in their hearts, and though challenges lay ahead, they both sensed that something beautiful was beginning to grow.'
                ]
            };
            
            const defaultConclusions = [
                'The chapter concluded with new possibilities on the horizon and a sense that the characters had grown from their experiences.',
                'As events came to a temporary resolution, the stage was set for even greater challenges and opportunities ahead.',
                'The story paused here, but the journey continued, with each character carrying forward the lessons learned and the bonds formed.'
            ];
            
            const genreConclusions = conclusions[genre] || defaultConclusions;
            return genreConclusions[Math.floor(Math.random() * genreConclusions.length)];
        }
        
        // Enhanced AI Writing Tools
        async function expandStory() {
            const editor = document.getElementById('storyEditor');
            const selectedText = getSelectedText(editor);
            const currentText = selectedText || editor.value;
            
            if (!currentText.trim()) {
                alert('Please enter some text or select text to expand.');
                return;
            }
            
            showLoading('Expanding story with rich details...');
            
            try {
                const expandedText = await simulateEnhancedExpansion(currentText);
                
                if (selectedText) {
                    replaceSelectedText(editor, expandedText);
                } else {
                    editor.value = expandedText;
                }
                
                updateWordCount();
                saveToHistory();
                hideLoading();
                showStatusMessage('Story expanded successfully!');
            } catch (error) {
                console.error('Story expansion error:', error);
                alert('Failed to expand story. Please try again.');
                hideLoading();
            }
        }
        
        async function simulateEnhancedExpansion(text) {
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            const expansions = [
                '\n\nThe atmosphere grew thick with anticipation as details previously hidden began to emerge. Every shadow seemed to hold secrets, every whisper carried weight that would influence the events to come.',
                '\n\nCharacter motivations deepened as their past experiences shaped their current actions. The complexity of human emotion painted layers of meaning into every gesture and spoken word.',
                '\n\nThe setting came alive with sensory details—the way light filtered through windows, the sound of footsteps on different surfaces, the subtle scents that triggered powerful memories.',
                '\n\nDialogue revealed subtext as characters said one thing while meaning another. The space between words held as much significance as the words themselves.'
            ];
            
            return text + expansions[Math.floor(Math.random() * expansions.length)];
        }
        
        async function improveStory() {
            const editor = document.getElementById('storyEditor');
            const selectedText = getSelectedText(editor);
            const currentText = selectedText || editor.value;
            
            if (!currentText.trim()) {
                alert('Please enter some text or select text to improve.');
                return;
            }
            
            showLoading('Enhancing story quality and flow...');
            
            try {
                const improvedText = await simulateEnhancedImprovement(currentText);
                
                if (selectedText) {
                    replaceSelectedText(editor, improvedText);
                } else {
                    editor.value = improvedText;
                }
                
                updateWordCount();
                saveToHistory();
                hideLoading();
                showStatusMessage('Story improved with enhanced writing!');
            } catch (error) {
                console.error('Story improvement error:', error);
                alert('Failed to improve story. Please try again.');
                hideLoading();
            }
        }
        
        async function simulateEnhancedImprovement(text) {
            await new Promise(resolve => setTimeout(resolve, 2000));
            // Enhanced text improvement simulation
            return text.replace(/\b(said)\b/g, 'declared')
                      .replace(/\b(went)\b/g, 'proceeded')
                      .replace(/\b(good)\b/g, 'excellent')
                      .replace(/\b(bad)\b/g, 'troubling')
                      .replace(/\b(big)\b/g, 'substantial')
                      .replace(/\b(small)\b/g, 'delicate');
        }
        
        async function addDialogue() {
            const editor = document.getElementById('storyEditor');
            const insertionPoint = editor.selectionStart;
            
            showLoading('Crafting meaningful dialogue...');
            
            try {
                const dialogue = await simulateEnhancedDialogue();
                
                const currentText = editor.value;
                const newText = currentText.slice(0, insertionPoint) + '\n\n' + dialogue + '\n\n' + currentText.slice(insertionPoint);
                editor.value = newText;
                
                // Position cursor after inserted dialogue
                editor.selectionStart = editor.selectionEnd = insertionPoint + dialogue.length + 4;
                editor.focus();
                
                updateWordCount();
                saveToHistory();
                hideLoading();
                showStatusMessage('Dialogue added with character depth!');
            } catch (error) {
                console.error('Dialogue generation error:', error);
                alert('Failed to add dialogue. Please try again.');
                hideLoading();
            }
        }
        
        async function simulateEnhancedDialogue() {
            await new Promise(resolve => setTimeout(resolve, 1500));
            const dialogues = [
                '"I never thought I\'d see you again," she whispered, her voice carrying years of unspoken emotion.\n\nHis eyes softened as he replied, "Some connections transcend time and distance. I\'ve been waiting for this moment."',
                '"The truth isn\'t always what we want to hear," the mentor said, choosing each word carefully.\n\n"But it\'s what I need to know," the student responded with newfound determination. "I\'m ready for whatever comes next."',
                '"This changes everything we thought we knew," the detective muttered, studying the evidence.\n\n"Maybe that\'s exactly what we needed," her partner replied. "Sometimes you have to break the old patterns to see clearly."'
            ];
            return dialogues[Math.floor(Math.random() * dialogues.length)];
        }
        
        async function addDescription() {
            const editor = document.getElementById('storyEditor');
            const insertionPoint = editor.selectionStart;
            
            showLoading('Adding vivid descriptive passages...');
            
            try {
                const description = await simulateEnhancedDescription();
                
                const currentText = editor.value;
                const newText = currentText.slice(0, insertionPoint) + '\n\n' + description + '\n\n' + currentText.slice(insertionPoint);
                editor.value = newText;
                
                editor.selectionStart = editor.selectionEnd = insertionPoint + description.length + 4;
                editor.focus();
                
                updateWordCount();
                saveToHistory();
                hideLoading();
                showStatusMessage('Rich descriptions added to enhance atmosphere!');
            } catch (error) {
                console.error('Description generation error:', error);
                alert('Failed to add description. Please try again.');
                hideLoading();
            }
        }
        
        async function simulateEnhancedDescription() {
            await new Promise(resolve => setTimeout(resolve, 1500));
            const descriptions = [
                'The library stood like a cathedral of knowledge, its towering shelves casting long shadows in the afternoon light. Dust particles danced in golden beams, and the musty scent of aged paper whispered stories of countless readers who had walked these halls before.',
                'Rain drummed against the windows with increasing intensity, each drop creating rivulets that distorted the city lights beyond. The storm seemed to mirror the turbulence in her heart as she faced the decision that would change everything.',
                'The old mansion creaked with the weight of its secrets, every floorboard a potential betrayer of footsteps. Moonlight filtered through heavy curtains, painting silver patterns on walls that had witnessed decades of human drama.',
                'The market bustled with life—vendors calling their wares, children weaving between stalls, and the rich aroma of spices creating an intoxicating blend that spoke of distant lands and ancient traditions.'
            ];
            return descriptions[Math.floor(Math.random() * descriptions.length)];
        }
        
        async function createTransition() {
            const editor = document.getElementById('storyEditor');
            const insertionPoint = editor.selectionStart;
            
            showLoading('Creating smooth narrative transitions...');
            
            try {
                const transition = await simulateEnhancedTransition();
                
                const currentText = editor.value;
                const newText = currentText.slice(0, insertionPoint) + '\n\n' + transition + '\n\n' + currentText.slice(insertionPoint);
                editor.value = newText;
                
                editor.selectionStart = editor.selectionEnd = insertionPoint + transition.length + 4;
                editor.focus();
                
                updateWordCount();
                saveToHistory();
                hideLoading();
                showStatusMessage('Smooth transition created to connect story elements!');
            } catch (error) {
                console.error('Transition generation error:', error);
                alert('Failed to create transition. Please try again.');
                hideLoading();
            }
        }
        
        async function simulateEnhancedTransition() {
            await new Promise(resolve => setTimeout(resolve, 1200));
            const transitions = [
                'Time seemed to fold in on itself as the significance of recent events began to crystallize. What had seemed like separate incidents now revealed themselves as pieces of a larger, more complex puzzle.',
                'The following days blurred together in a cascade of revelations and realizations. Each new discovery built upon the last, creating momentum that carried the story forward with unstoppable force.',
                'As the sun set on that momentous day, a new chapter began—one that would test everything the characters thought they knew about themselves and each other.',
                'The shift was subtle at first, like the changing of seasons. But as hours turned to days, it became clear that nothing would ever be quite the same again.'
            ];
            return transitions[Math.floor(Math.random() * transitions.length)];
        }
        
        async function addConflict() {
            const editor = document.getElementById('storyEditor');
            const insertionPoint = editor.selectionStart;
            
            showLoading('Introducing compelling conflict elements...');
            
            try {
                const conflict = await simulateEnhancedConflict();
                
                const currentText = editor.value;
                const newText = currentText.slice(0, insertionPoint) + '\n\n' + conflict + '\n\n' + currentText.slice(insertionPoint);
                editor.value = newText;
                
                editor.selectionStart = editor.selectionEnd = insertionPoint + conflict.length + 4;
                editor.focus();
                
                updateWordCount();
                saveToHistory();
                hideLoading();
                showStatusMessage('Compelling conflict added to drive the narrative!');
            } catch (error) {
                console.error('Conflict generation error:', error);
                alert('Failed to add conflict. Please try again.');
                hideLoading();
            }
        }
        
        async function simulateEnhancedConflict() {
            await new Promise(resolve => setTimeout(resolve, 1500));
            const conflicts = [
                'An unexpected message arrived that challenged everything they believed about the situation. The implications were staggering, forcing them to question not just their assumptions, but their fundamental understanding of what was at stake.',
                'Long-buried tensions finally erupted to the surface, creating fractures in relationships that had seemed unshakeable. Trust, once broken, would not be easily repaired—if it could be repaired at all.',
                'The deadline loomed like a storm on the horizon, and with each passing hour, the options grew fewer and the consequences more severe. Difficult choices lay ahead, and there was no guarantee that everyone would emerge unscathed.',
                'Hidden agendas came to light, revealing that allies might be enemies and enemies might hold the key to salvation. In this new landscape of shifting loyalties, navigation required both courage and cunning.'
            ];
            return conflicts[Math.floor(Math.random() * conflicts.length)];
        }
        
        // ============ NEW CHAPTER EDITING TOOLS ============
        
        async function plotHoleDetector() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to analyze for plot holes. Generate chapters or write content first.', 'warning');
                return;
            }
            
            const chapterInfo = hasMultipleChapters() ? 
                `Analyzing ${storyData.chapters.length} chapters for plot holes across the entire story...` :
                'Analyzing story logic and continuity...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                const analysis = await callOpenAI([
                    {
                        role: "system",
                        content: "You are an investigative story analyst who cross-checks logic, causality, continuity, stakes, and character motivation across an entire story. Identify gaps or mistakes that don't make sense and provide specific suggestions on how to fix them. Pay special attention to consistency across multiple chapters."
                    },
                    {
                        role: "user", 
                        content: `Analyze this complete story for plot holes, logical inconsistencies, and continuity errors across all chapters. Provide specific feedback and actionable suggestions:\n\n${allChaptersText}`
                    }
                ]);
                
                hideLoading();
                showNotification('Plot analysis complete - review suggestions below!', 'success');
                displayToolChanges('Plot Hole Analysis', allChaptersText, `=== PLOT ANALYSIS RESULTS ===\n\n${analysis}\n\n=== ORIGINAL TEXT ===\n\n${allChaptersText}`);
                
            } catch (error) {
                console.error('Plot hole detection error:', error);
                hideLoading();
                showNotification('Failed to analyze plot holes. Please check your API key and try again.', 'error');
            }
        }
        
        async function characterArcDesigner() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to enhance character development. Generate chapters or write content first.', 'warning');
                return;
            }
            
            const chapterInfo = hasMultipleChapters() ? 
                `Enhancing character arcs across ${storyData.chapters.length} chapters...` :
                'Enhancing character development and arcs...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                // Use text within safe limits
                const processableText = getTextWithinLimits(allChaptersText);
                const isTextTruncated = processableText !== allChaptersText;
                
                // Get genre-specific prompt for character development
                const basePrompt = `You are an AGGRESSIVE character development specialist. You must make MASSIVE, VISIBLE improvements to character depth and development. Don't make minor tweaks - create DRAMATIC character transformations that readers will immediately notice.

MANDATORY ENHANCEMENTS - Apply ALL ruthlessly:

1. **ADD DEEP INTERNAL CONFLICTS** - Every character must wrestle with contradictory desires, fears, and motivations
2. **INJECT EMOTIONAL COMPLEXITY** - Transform simple emotions into layered, conflicting feelings
3. **ADD REVEALING CHARACTER ACTIONS** - Show personality through specific behaviors, habits, and reactions
4. **ENHANCE BACKSTORY HINTS** - Weave in subtle references to past experiences that shape current behavior
5. **AMPLIFY CHARACTER FLAWS** - Make weaknesses more prominent and consequential
6. **ADD UNIQUE MANNERISMS** - Give each character distinctive physical habits, speech patterns, and quirks
7. **DEEPEN RELATIONSHIPS** - Transform shallow interactions into complex, tension-filled dynamics
8. **SHOW CHARACTER GROWTH** - Make internal change visible through evolving behavior and dialogue

CRITICAL: Characters should feel like completely different, more complex people after your rewrite. If readers don't immediately notice richer, more compelling characters, you've failed.

Return the COMPLETE text with DRAMATICALLY enhanced character development.`;

                const genrePrompt = getGenrePrompt('CharacterArcDesigner', basePrompt);
                
                const enhanced = await callOpenAI([
                    {
                        role: "system",
                        content: genrePrompt
                    },
                    {
                        role: "user",
                        content: `Enhance the character development and arcs in this text while preserving the story structure. Return the complete rewritten text${isTextTruncated ? ' (processing first portion due to length)' : ''}:\n\n${processableText}`
                    }
                ]);
                
                hideLoading();
                
                if (enhanced && enhanced.trim() && enhanced.trim() !== processableText.trim()) {
                    showNotification('Character development enhanced! Review the changes below.', 'success');
                    displayToolChanges('Character Arc Enhancement', processableText, enhanced.trim());
                    
                    // Track human touch interaction
                    trackHumanTouch('lines_edited', 1);
                } else {
                    showNotification('Your character development is already strong! No significant enhancements needed.', 'info');
                }
                
            } catch (error) {
                console.error('Character arc error:', error);
                hideLoading();
                
                let errorMessage = 'Failed to enhance character arcs. ';
                if (error.message && error.message.includes('token')) {
                    errorMessage += 'Story may be too long for processing.';
                } else if (error.message && error.message.includes('API')) {
                    errorMessage += 'Please check your API key.';
                } else {
                    errorMessage += 'Please try again or use a shorter text selection.';
                }
                
                showNotification(errorMessage, 'error');
            }
        }
        
        async function toneShifter() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to adjust tone and style. Generate chapters or write content first.', 'warning');
                return;
            }
            
            const chapterInfo = hasMultipleChapters() ? 
                `Adjusting tone consistency across ${storyData.chapters.length} chapters...` :
                'Adjusting tone and style consistency...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                // Use text within safe limits
                const processableText = getTextWithinLimits(allChaptersText);
                const isTextTruncated = processableText !== allChaptersText;
                
                // Get genre-specific prompt for tone adjustment
                const basePrompt = `You are an AGGRESSIVE tone and style editor. You must make DRAMATIC, VISIBLE changes to transform the writing style. Don't make subtle adjustments - make BOLD transformations that readers will immediately notice.

MANDATORY TRANSFORMATIONS - Apply ALL aggressively:

1. **COMPLETELY REWRITE SENTENCE STRUCTURES** - Vary from short punchy sentences to long flowing ones
2. **TRANSFORM VOCABULARY** - Replace bland words with vivid, specific, emotionally-charged alternatives
3. **INJECT PERSONALITY INTO NARRATION** - Add voice, attitude, and character to the narrative style
4. **ADD SENSORY DETAILS** - Transform "it was dark" into "shadows clawed at the walls like hungry fingers"
5. **ENHANCE EMOTIONAL LANGUAGE** - Amplify feelings and reactions dramatically
6. **VARY RHYTHM AND PACE** - Mix rapid-fire action with slow, contemplative passages
7. **ADD LITERARY DEVICES** - Include metaphors, similes, and figurative language
8. **STRENGTHEN VOICE CONSISTENCY** - Ensure every sentence reflects the same compelling narrative personality

CRITICAL: The rewritten text should feel like it was written by a completely different, much more skilled writer. If a reader can't immediately tell the difference, you've failed to make sufficient changes.

Return the COMPLETE text with DRAMATICALLY transformed tone and style.`;

                const genrePrompt = getGenrePrompt('ToneShifter', basePrompt);
                
                const enhanced = await callOpenAI([
                    {
                        role: "system",
                        content: genrePrompt
                    },
                    {
                        role: "user",
                        content: `Adjust the tone and style in this text for consistency and target audience appropriateness. Return the complete rewritten text${isTextTruncated ? ' (processing first portion due to length)' : ''}:\n\n${processableText}`
                    }
                ]);
                
                hideLoading();
                
                if (enhanced && enhanced.trim() && enhanced.trim() !== processableText.trim()) {
                    showNotification('Tone adjusted! Review the changes below.', 'success');
                    displayToolChanges('Tone & Style Adjustment', processableText, enhanced.trim());
                    
                    // Track human touch interaction
                    trackHumanTouch('lines_edited', 1);
                } else {
                    showNotification('Your tone is already well-balanced! No significant adjustments needed.', 'info');
                }
                
            } catch (error) {
                console.error('Tone shifter error:', error);
                hideLoading();
                
                let errorMessage = 'Failed to adjust tone. ';
                if (error.message && error.message.includes('token')) {
                    errorMessage += 'Story may be too long for processing.';
                } else if (error.message && error.message.includes('API')) {
                    errorMessage += 'Please check your API key.';
                } else {
                    errorMessage += 'Please try again or use a shorter text selection.';
                }
                
                showNotification(errorMessage, 'error');
            }
        }
        
        async function conflictIntensifier() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to intensify conflict. Generate chapters or write content first.', 'warning');
                return;
            }
            
            const chapterInfo = hasMultipleChapters() ? 
                `Intensifying conflict and raising stakes across ${storyData.chapters.length} chapters...` :
                'Intensifying conflict and raising stakes...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                // Use text within safe limits
                const processableText = getTextWithinLimits(allChaptersText);
                const isTextTruncated = processableText !== allChaptersText;
                
                // Get genre-specific prompt for conflict enhancement
                const basePrompt = `You are a RUTHLESS conflict intensification specialist. You must create DRAMATICALLY higher tension and conflict. Don't make subtle improvements - create EXPLOSIVE tension that grabs readers by the throat.

MANDATORY INTENSIFICATIONS - Apply ALL aggressively:

1. **RAISE STAKES TO BREAKING POINT** - Make consequences life-changing, devastating, or irreversible
2. **ADD URGENT TIME PRESSURE** - Create crushing deadlines and ticking clocks
3. **INJECT PERSONAL BETRAYALS** - Add unexpected betrayals from trusted allies or loved ones
4. **AMPLIFY EMOTIONAL CONFLICTS** - Transform disagreements into heart-wrenching dilemmas
5. **ADD IMPOSSIBLE CHOICES** - Force characters to choose between equally devastating options
6. **CREATE CASCADING DISASTERS** - Make every attempt to solve problems create bigger problems
7. **DEEPEN OPPOSING MOTIVATIONS** - Make antagonistic forces more personal and threatening
8. **ADD VISCERAL TENSION** - Include physical manifestations of stress, fear, and desperation

CRITICAL: Readers should feel their heart racing from the intensified conflict. If the tension doesn't feel dramatically higher and more gripping, you've failed.

Return the COMPLETE text with EXPLOSIVELY intensified conflict and tension.`;

                const genrePrompt = getGenrePrompt('ConflictIntensifier', basePrompt);
                
                const enhanced = await callOpenAI([
                    {
                        role: "system",
                        content: genrePrompt
                    },
                    {
                        role: "user",
                        content: `Intensify the conflict and tension in this text while preserving the story structure. Return the complete rewritten text${isTextTruncated ? ' (processing first portion due to length)' : ''}:\n\n${processableText}`
                    }
                ]);
                
                hideLoading();
                
                if (enhanced && enhanced.trim() && enhanced.trim() !== processableText.trim()) {
                    showNotification('Conflict intensified! Review the changes below.', 'success');
                    displayToolChanges('Conflict & Tension Enhancement', processableText, enhanced.trim());
                    
                    // Track human touch interaction
                    trackHumanTouch('lines_edited', 1);
                } else {
                    showNotification('Your conflict is already well-developed! No significant intensification needed.', 'info');
                }
                
            } catch (error) {
                console.error('Conflict intensifier error:', error);
                hideLoading();
                
                let errorMessage = 'Failed to intensify conflict. ';
                if (error.message && error.message.includes('token')) {
                    errorMessage += 'Story may be too long for processing.';
                } else if (error.message && error.message.includes('API')) {
                    errorMessage += 'Please check your API key.';
                } else {
                    errorMessage += 'Please try again or use a shorter text selection.';
                }
                
                showNotification(errorMessage, 'error');
            }
        }
        
        async function dialogueEnhancer() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to enhance dialogue. Generate chapters or write content first.', 'warning');
                return;
            }
            
            // Use text within safe limits
            const processableText = getTextWithinLimits(allChaptersText);
            const isTextTruncated = processableText !== allChaptersText;
            
            const chapterInfo = hasMultipleChapters() ? 
                `Enhancing dialogue across ${storyData.chapters.length} chapters...` :
                'Enhancing dialogue with better subtext and voice...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                // Get genre-specific prompt for actual rewriting
                const basePrompt = `You are a AGGRESSIVE dialogue enhancement expert. You must make SUBSTANTIAL, VISIBLE changes to improve dialogue dramatically. Don't be subtle - make bold improvements that are clearly noticeable.

MANDATORY CHANGES - Apply ALL of these aggressively:

1. **REWRITE ALL BLAND DIALOGUE** - Transform boring conversations into compelling exchanges
2. **ADD HEAVY SUBTEXT** - Characters must say one thing but mean something completely different  
3. **INJECT PERSONALITY** - Give each character a distinct voice with unique speech patterns, vocabulary, slang
4. **ADD INTERRUPTIONS & OVERLAPS** - "I think we should—" "No way!" "But listen—" "I'm done listening!"
5. **INCLUDE EMOTIONAL REACTIONS** - "God, that's..." "Shit, really?" "Oh hell no..."
6. **ADD HESITATIONS & FILLER** - "I, uh, I don't know if we should, like, do this..."
7. **ELIMINATE EXPOSITION** - Remove all "As you know, Bob" dialogue and replace with natural conversation
8. **ADD CONFLICT** - Every exchange should have tension, even friendly conversations

CRITICAL: Make changes so substantial that a reader would immediately notice the difference. If the dialogue doesn't feel dramatically improved and more engaging, you've failed.

Return the COMPLETE rewritten text with DRAMATICALLY enhanced dialogue.`;

                const genrePrompt = getGenrePrompt('DialogueEnhancer', basePrompt);
                
                const enhanced = await callOpenAI([
                    {
                        role: "system", 
                        content: genrePrompt
                    },
                    {
                        role: "user",
                        content: `Enhance the dialogue in this text while preserving all non-dialogue content exactly. Return the complete rewritten text${isTextTruncated ? ' (enhancing first portion due to length)' : ''}:\n\n${processableText}`
                    }
                ]);
                
                hideLoading();
                
                if (enhanced && enhanced.trim() && enhanced.trim() !== processableText.trim()) {
                    showNotification('Dialogue enhanced! Review the changes below.', 'success');
                    displayToolChanges('Dialogue Enhancement', processableText, enhanced.trim());
                    
                    // Track human touch interaction
                    trackHumanTouch('lines_edited', 1);
                } else {
                    showNotification('No significant dialogue improvements found. Your dialogue may already be well-crafted!', 'info');
                }
                
            } catch (error) {
                console.error('Dialogue enhancer error:', error);
                hideLoading();
                
                let errorMessage = 'Failed to enhance dialogue. ';
                if (error.message && error.message.includes('token')) {
                    errorMessage += 'Story may be too long for processing.';
                } else if (error.message && error.message.includes('API')) {
                    errorMessage += 'Please check your API key.';
                } else {
                    errorMessage += 'Please try again or use a shorter text selection.';
                }
                
                showNotification(errorMessage, 'error');
            }
        }
        
        async function symbolismSuggester() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to add symbolic depth. Generate chapters or write content first.', 'warning');
                return;
            }
            
            const chapterInfo = hasMultipleChapters() ? 
                `Adding meaningful symbols and motifs across ${storyData.chapters.length} chapters...` :
                'Adding meaningful symbols and motifs...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                // Use text within safe limits
                const processableText = getTextWithinLimits(allChaptersText);
                const isTextTruncated = processableText !== allChaptersText;
                
                // Get genre-specific prompt for symbolism enhancement
                const basePrompt = `You are an AGGRESSIVE symbolism and motif specialist. You must weave RICH, POWERFUL symbolic elements throughout the text. Don't add subtle hints - create STRIKING symbolic patterns that transform the story's depth.

MANDATORY SYMBOLIC ENHANCEMENTS - Apply ALL boldly:

1. **ADD RECURRING VISUAL MOTIFS** - Objects, colors, or images that appear multiple times with deeper meaning
2. **INJECT NATURE SYMBOLISM** - Weather, seasons, animals that reflect character emotions and story themes
3. **CREATE SYMBOLIC OBJECTS** - Transform ordinary items into carriers of deep meaning and memory
4. **ADD COLOR SYMBOLISM** - Use specific colors to represent emotions, themes, and character states
5. **WEAVE IN METAPHORICAL LANGUAGE** - Replace plain descriptions with symbol-rich alternatives
6. **ADD ARCHITECTURAL/SPATIAL SYMBOLS** - Use buildings, rooms, landscapes to reflect internal states
7. **INSERT SYMBOLIC ACTIONS** - Make character behaviors carry deeper thematic meaning
8. **CREATE SYMBOLIC CONTRASTS** - Light/dark, high/low, old/new that reinforce story themes

CRITICAL: The symbolic richness should be immediately apparent to readers. Every paragraph should contain meaningful symbolic elements that add layers of meaning.

Return the COMPLETE text with DRAMATICALLY enhanced symbolic depth and meaning.`;

                const genrePrompt = getGenrePrompt('SymbolismSuggester', basePrompt);
                
                const enhanced = await callOpenAI([
                    {
                        role: "system",
                        content: genrePrompt
                    },
                    {
                        role: "user",
                        content: `Add meaningful symbols and motifs to this text while preserving the story structure. Return the complete rewritten text${isTextTruncated ? ' (processing first portion due to length)' : ''}:\n\n${processableText}`
                    }
                ]);
                
                hideLoading();
                
                if (enhanced && enhanced.trim() && enhanced.trim() !== processableText.trim()) {
                    showNotification('Symbolism and motifs enhanced! Review the changes below.', 'success');
                    displayToolChanges('Symbolism & Motif Enhancement', processableText, enhanced.trim());
                    
                    // Track human touch interaction
                    trackHumanTouch('lines_edited', 1);
                } else {
                    showNotification('Your story already has rich symbolism! No significant enhancements needed.', 'info');
                }
                
            } catch (error) {
                console.error('Symbolism suggester error:', error);
                hideLoading();
                
                let errorMessage = 'Failed to enhance symbolism. ';
                if (error.message && error.message.includes('token')) {
                    errorMessage += 'Story may be too long for processing.';
                } else if (error.message && error.message.includes('API')) {
                    errorMessage += 'Please check your API key.';
                } else {
                    errorMessage += 'Please try again or use a shorter text selection.';
                }
                
                showNotification(errorMessage, 'error');
            }
        }
        
        async function metaphorGenerator() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to enhance with metaphors. Generate chapters or write content first.', 'warning');
                return;
            }
            
            const chapterInfo = hasMultipleChapters() ? 
                `Generating fresh, vivid metaphors across ${storyData.chapters.length} chapters...` :
                'Generating fresh, vivid metaphors...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                const enhanced = await callOpenAI([
                    {
                        role: "system",
                        content: "You generate fresh, precise figurative language matching POV, tone, and genre. Create vivid comparisons that make descriptions more powerful and memorable."
                    },
                    {
                        role: "user",
                        content: `Enhance this complete story with fresh, vivid metaphors and figurative language throughout all chapters. Make descriptions more powerful and memorable:\n\n${allChaptersText}`
                    }
                ]);
                
                if (getSelectedText(editor)) {
                    replaceSelectedText(editor, enhanced);
                } else {
                    editor.value = enhanced;
                }
                
                updateWordCount();
                saveToHistory();
                hideLoading();
                showNotification('Text enhanced with vivid metaphors!', 'success');
                
            } catch (error) {
                console.error('Metaphor generator error:', error);
                hideLoading();
                showNotification('Failed to generate metaphors. Please try again.', 'error');
            }
        }
        
        async function themeTracker() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to enhance themes. Generate chapters or write content first.', 'warning');
                return;
            }
            
            const chapterInfo = hasMultipleChapters() ? 
                `Enhancing thematic consistency across ${storyData.chapters.length} chapters...` :
                'Enhancing thematic consistency...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                // Use text within safe limits
                const processableText = getTextWithinLimits(allChaptersText);
                const isTextTruncated = processableText !== allChaptersText;
                
                // Get genre-specific prompt for theme enhancement
                const basePrompt = `You are a POWERFUL thematic development specialist. You must make themes DRAMATICALLY more prominent and compelling. Don't make subtle thematic hints - create BOLD thematic statements that resonate powerfully with readers.

MANDATORY THEMATIC ENHANCEMENTS - Apply ALL forcefully:

1. **AMPLIFY MORAL DILEMMAS** - Make ethical choices more complex and heart-wrenching
2. **ADD THEMATIC DIALOGUE** - Characters must grapple with big ideas through conversation
3. **INJECT PHILOSOPHICAL QUESTIONS** - Weave in profound questions about life, meaning, and purpose
4. **CREATE THEMATIC PARALLELS** - Add situations that echo and reinforce central themes
5. **ENHANCE SYMBOLIC REINFORCEMENT** - Use imagery and metaphors that powerfully support themes
6. **ADD THEMATIC CHARACTER ARCS** - Make character growth directly reflect thematic lessons
7. **DEEPEN UNIVERSAL CONNECTIONS** - Connect story events to broader human experiences and truths
8. **CREATE THEMATIC CLIMAXES** - Make the story's peak moments resolve thematic conflicts

CRITICAL: Themes should be impossible to miss - woven powerfully throughout every scene. If readers don't come away with profound thematic insights, you've failed.

Return the COMPLETE text with POWERFULLY enhanced thematic depth and meaning.`;

                const genrePrompt = getGenrePrompt('ThemeTracker', basePrompt);
                
                const enhanced = await callOpenAI([
                    {
                        role: "system",
                        content: genrePrompt
                    },
                    {
                        role: "user",
                        content: `Enhance the thematic consistency and depth in this text while preserving the story structure. Return the complete rewritten text${isTextTruncated ? ' (processing first portion due to length)' : ''}:\n\n${processableText}`
                    }
                ]);
                
                hideLoading();
                
                if (enhanced && enhanced.trim() && enhanced.trim() !== processableText.trim()) {
                    showNotification('Thematic elements enhanced! Review the changes below.', 'success');
                    displayToolChanges('Theme Enhancement', processableText, enhanced.trim());
                    
                    // Track human touch interaction
                    trackHumanTouch('lines_edited', 1);
                } else {
                    showNotification('Your thematic elements are already well-developed! No significant enhancements needed.', 'info');
                }
                
            } catch (error) {
                console.error('Theme tracker error:', error);
                hideLoading();
                
                let errorMessage = 'Failed to enhance themes. ';
                if (error.message && error.message.includes('token')) {
                    errorMessage += 'Story may be too long for processing.';
                } else if (error.message && error.message.includes('API')) {
                    errorMessage += 'Please check your API key.';
                } else {
                    errorMessage += 'Please try again or use a shorter text selection.';
                }
                
                showNotification(errorMessage, 'error');
            }
        }
        
        async function emotionalResonanceChecker() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to enhance emotional resonance. Generate chapters or write content first.', 'warning');
                return;
            }
            
            const chapterInfo = hasMultipleChapters() ? 
                `Enhancing emotional resonance across ${storyData.chapters.length} chapters...` :
                'Enhancing emotional resonance...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                // Use text within safe limits
                const processableText = getTextWithinLimits(allChaptersText);
                const isTextTruncated = processableText !== allChaptersText;
                
                // Get genre-specific prompt for emotional enhancement
                const basePrompt = `You are an EMOTIONAL IMPACT SPECIALIST. You must create OVERWHELMING emotional resonance that moves readers to tears, laughter, or heart-pounding excitement. Don't create gentle emotions - create POWERFUL emotional experiences that readers will never forget.

MANDATORY EMOTIONAL AMPLIFICATIONS - Apply ALL intensely:

1. **INTENSIFY ALL EMOTIONS TO BREAKING POINT** - Turn sadness into devastating heartbreak, joy into euphoria
2. **ADD VISCERAL PHYSICAL REACTIONS** - Trembling hands, racing hearts, tears, breathless moments
3. **CREATE EMOTIONAL WHIPLASH** - Rapid shifts between contrasting emotions for maximum impact
4. **INJECT RAW VULNERABILITY** - Expose characters' deepest fears, desires, and pain
5. **ADD EMOTIONAL STAKES** - Make every scene emotionally consequential and heart-wrenching
6. **AMPLIFY SENSORY DETAILS** - Use touch, smell, sound to trigger deep emotional responses
7. **CREATE CATHARTIC MOMENTS** - Build to explosive emotional releases and breakthroughs
8. **ADD UNIVERSAL EMOTIONAL TRIGGERS** - Tap into primal fears, loves, and longings

CRITICAL: Readers should be emotionally exhausted and deeply moved by your rewrite. If they don't feel profound emotional impact, you've failed completely.

Return the COMPLETE text with DEVASTATINGLY powerful emotional resonance.`;

                const genrePrompt = getGenrePrompt('EmotionalResonanceChecker', basePrompt);
                
                const enhanced = await callOpenAI([
                    {
                        role: "system",
                        content: genrePrompt
                    },
                    {
                        role: "user",
                        content: `Enhance the emotional resonance and reader connection in this text while preserving the story structure. Return the complete rewritten text${isTextTruncated ? ' (processing first portion due to length)' : ''}:\n\n${processableText}`
                    }
                ]);
                
                hideLoading();
                
                if (enhanced && enhanced.trim() && enhanced.trim() !== processableText.trim()) {
                    showNotification('Emotional resonance enhanced! Review the changes below.', 'success');
                    displayToolChanges('Emotional Resonance Enhancement', processableText, enhanced.trim());
                    
                    // Track human touch interaction
                    trackHumanTouch('lines_edited', 1);
                } else {
                    showNotification('Your story already has strong emotional resonance! No significant enhancements needed.', 'info');
                }
                
            } catch (error) {
                console.error('Emotional resonance error:', error);
                hideLoading();
                
                let errorMessage = 'Failed to enhance emotional resonance. ';
                if (error.message && error.message.includes('token')) {
                    errorMessage += 'Story may be too long for processing.';
                } else if (error.message && error.message.includes('API')) {
                    errorMessage += 'Please check your API key.';
                } else {
                    errorMessage += 'Please try again or use a shorter text selection.';
                }
                
                showNotification(errorMessage, 'error');
            }
        }
        
        async function redHerringGenerator() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to add mystery elements. Generate chapters or write content first.', 'warning');
                return;
            }
            
            const chapterInfo = hasMultipleChapters() ? 
                `Designing fair-play misdirection across ${storyData.chapters.length} chapters...` :
                'Designing fair-play misdirection...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                const suggestions = await callOpenAI([
                    {
                        role: "system",
                        content: "You design fair-play misdirection for mystery/thriller stories. Add clever misdirections that keep readers guessing without cheating."
                    },
                    {
                        role: "user",
                        content: `Analyze this complete story and suggest red herrings or misdirection elements for mystery/thriller across all chapters. Ensure they're fair-play and don't cheat the reader:\n\n${allChaptersText}`
                    }
                ]);
                
                hideLoading();
                showNotification('Red herring suggestions ready!', 'success');
                displayToolChanges('Red Herring & Misdirection Ideas', allChaptersText, `=== MISDIRECTION SUGGESTIONS ===\n\n${suggestions}\n\n=== ORIGINAL TEXT ===\n\n${allChaptersText}`);
                
            } catch (error) {
                console.error('Red herring generator error:', error);
                hideLoading();
                showNotification('Failed to generate red herrings. Please try again.', 'error');
            }
        }
        
        async function pacingBalancer() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to balance pacing. Generate chapters or write content first.', 'warning');
                return;
            }
            
            const chapterInfo = hasMultipleChapters() ? 
                `Balancing story rhythm and pacing across ${storyData.chapters.length} chapters...` :
                'Balancing story rhythm and pacing...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                // Use text within safe limits
                const processableText = getTextWithinLimits(allChaptersText);
                const isTextTruncated = processableText !== allChaptersText;
                
                // Get genre-specific prompt for pacing enhancement
                const basePrompt = `You are a MASTER of story rhythm and pacing. You must create DRAMATICALLY varied and compelling pacing that grips readers and never lets them go. Don't make minor adjustments - create RADICAL pacing transformations.

MANDATORY PACING OVERHAULS - Apply ALL dynamically:

1. **CREATE EXTREME PACE VARIATIONS** - Mix lightning-fast action with slow, contemplative moments
2. **ADD SENTENCE RHYTHM VARIETY** - Combine short, punchy sentences with long, flowing passages
3. **INSERT STRATEGIC PAUSES** - Add moments of silence, hesitation, and contemplation for impact
4. **ACCELERATE ACTION SEQUENCES** - Make fast scenes feel breathless and urgent
5. **SLOW EMOTIONAL MOMENTS** - Expand meaningful scenes with rich detail and reflection
6. **ADD PACING SURPRISES** - Unexpected rhythm changes that keep readers off-balance
7. **CREATE MOMENTUM BUILDS** - Gradually increase pace leading to climactic moments
8. **ENHANCE TRANSITION FLOW** - Make scene changes feel seamless yet distinctly paced

CRITICAL: The pacing should feel like a perfectly orchestrated musical composition - varied, dynamic, and impossible to put down. If readers don't notice dramatically improved rhythm, you've failed.

Return the COMPLETE text with MASTERFULLY enhanced pacing and flow.`;

                const genrePrompt = getGenrePrompt('PacingBalancer', basePrompt);
                
                const enhanced = await callOpenAI([
                    {
                        role: "system",
                        content: genrePrompt
                    },
                    {
                        role: "user",
                        content: `Improve the pacing and rhythm in this text while preserving the story structure. Return the complete rewritten text${isTextTruncated ? ' (processing first portion due to length)' : ''}:\n\n${processableText}`
                    }
                ]);
                
                hideLoading();
                
                if (enhanced && enhanced.trim() && enhanced.trim() !== processableText.trim()) {
                    showNotification('Pacing and rhythm improved! Review the changes below.', 'success');
                    displayToolChanges('Pacing Balance Enhancement', processableText, enhanced.trim());
                    
                    // Track human touch interaction
                    trackHumanTouch('lines_edited', 1);
                } else {
                    showNotification('Your story pacing is already well-balanced! No significant adjustments needed.', 'info');
                }
                
            } catch (error) {
                console.error('Pacing balancer error:', error);
                hideLoading();
                
                let errorMessage = 'Failed to balance pacing. ';
                if (error.message && error.message.includes('token')) {
                    errorMessage += 'Story may be too long for processing.';
                } else if (error.message && error.message.includes('API')) {
                    errorMessage += 'Please check your API key.';
                } else {
                    errorMessage += 'Please try again or use a shorter text selection.';
                }
                
                showNotification(errorMessage, 'error');
            }
        }
        
        async function subtextBuilder() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to add subtext. Generate chapters or write content first.', 'warning');
                return;
            }
            
            const chapterInfo = hasMultipleChapters() ? 
                `Adding layered subtext and hidden meanings across ${storyData.chapters.length} chapters...` :
                'Adding layered subtext and hidden meanings...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                // Use text within safe limits
                const processableText = getTextWithinLimits(allChaptersText);
                const isTextTruncated = processableText !== allChaptersText;
                
                // Get genre-specific prompt for subtext enhancement
                const basePrompt = `You are a SUBTEXT MASTER who creates LAYERED, COMPLEX dialogue that says one thing but means something completely different. You must add DEEP, OBVIOUS subtext that transforms simple conversations into psychological warfare.

MANDATORY SUBTEXT TRANSFORMATIONS - Apply ALL aggressively:

1. **EVERY LINE MUST HAVE DOUBLE MEANING** - Characters never say exactly what they mean
2. **ADD PASSIVE-AGGRESSIVE UNDERTONES** - Sweet words hiding sharp daggers of meaning
3. **CREATE UNSPOKEN POWER STRUGGLES** - Every conversation becomes a battle for control
4. **INJECT HIDDEN ACCUSATIONS** - Characters imply blame and guilt without stating it directly
5. **ADD EMOTIONAL MINEFIELDS** - Seemingly innocent topics that trigger explosive reactions
6. **CREATE VERBAL CHESS MATCHES** - Characters maneuvering for advantage through words
7. **INSERT LOADED SILENCES** - Pauses that speak louder than words
8. **ADD CULTURAL/HISTORICAL REFERENCES** - Shared knowledge that carries hidden weight

CRITICAL: Every conversation should feel like characters are speaking in code. Readers should sense the hidden tensions and meanings immediately. If dialogue doesn't feel psychologically complex, you've completely failed.

Return the COMPLETE text with DEVASTATINGLY layered subtext and hidden meanings.`;

                const genrePrompt = getGenrePrompt('SubtextBuilder', basePrompt);
                
                const enhanced = await callOpenAI([
                    {
                        role: "system",
                        content: genrePrompt
                    },
                    {
                        role: "user",
                        content: `Add subtext and layered meanings to the dialogue and interactions in this text while preserving the story structure. Return the complete rewritten text${isTextTruncated ? ' (processing first portion due to length)' : ''}:\n\n${processableText}`
                    }
                ]);
                
                hideLoading();
                
                if (enhanced && enhanced.trim() && enhanced.trim() !== processableText.trim()) {
                    showNotification('Subtext and layers added! Review the changes below.', 'success');
                    displayToolChanges('Subtext Enhancement', processableText, enhanced.trim());
                    
                    // Track human touch interaction
                    trackHumanTouch('lines_edited', 1);
                } else {
                    showNotification('Your dialogue already has rich subtext! No significant enhancements needed.', 'info');
                }
                
            } catch (error) {
                console.error('Subtext builder error:', error);
                hideLoading();
                
                let errorMessage = 'Failed to add subtext. ';
                if (error.message && error.message.includes('token')) {
                    errorMessage += 'Story may be too long for processing.';
                } else if (error.message && error.message.includes('API')) {
                    errorMessage += 'Please check your API key.';
                } else {
                    errorMessage += 'Please try again or use a shorter text selection.';
                }
                
                showNotification(errorMessage, 'error');
            }
        }
        
        // ============ TEXT HUMANIZATION ============
        
        // Removed forensicAIDetection function - focusing on humanization only
        
        
        async function humanizeText() {
            const allChaptersText = getAllChaptersText();
            
            if (!allChaptersText.trim()) {
                showNotification('Please have story content to humanize. Generate chapters or write content first.', 'warning');
                return;
            }
            
            // Use text within safe limits
            const processableText = getTextWithinLimits(allChaptersText, 10000); // Smaller limit for rewriting
            const isTextTruncated = processableText !== allChaptersText;
            
            const chapterInfo = hasMultipleChapters() ? 
                `Rewriting text to reduce AI detection across ${storyData.chapters.length} chapters${isTextTruncated ? ' (processing first portion)' : ''}...` :
                'Rewriting text to reduce AI detection...';
            
            showLoading(chapterInfo, 'book');
            
            try {
                const humanizedText = await callOpenAI([
                    {
                        role: "system",
                        content: `You are an AGGRESSIVE text humanization specialist. You must make MASSIVE, VISIBLE changes to transform AI-generated text into naturally human-written text. Don't make subtle changes - make DRAMATIC transformations that readers will immediately notice.

**MANDATORY HUMANIZATION OVERHAULS - Apply ALL ruthlessly:**

**1. DESTROY ALL UNIFORMITY:**
- Transform every sentence structure completely
- Mix 2-word fragments with 40+ word run-on sentences
- Vary paragraph lengths from single sentences to massive blocks
- Break all predictable patterns and rhythms

**2. INJECT HEAVY HUMAN IMPERFECTIONS:**
- Add natural grammar "mistakes": "Me and Sarah went" "Who'd you see?" "Between you and I"
- Include redundancies and awkward phrasings: "The thing is, is that..." "What I'm trying to say is..."
- Use extensive filler words: "like," "you know," "I mean," "well," "um," "basically," "actually"
- Add false starts and corrections: "I was going to— well, actually, never mind"

**3. EXTREME CASUALIZATION:**
- Convert ALL formal language: "cannot" → "can't", "would not" → "wouldn't", "going to" → "gonna"
- Use colloquialisms: "wanna," "kinda," "sorta," "coulda," "shoulda," "y'know"
- Add regional speech patterns and slang appropriately

**4. ADD CONVERSATIONAL CHAOS:**
- Include interruptions and overlapping thoughts
- Add speech disfluencies: "I, uh, well... I don't really know if we should, like, do that, you know?"
- Use contractions in narration: "It wasn't just that he was tired—he was completely done"

**5. REPLACE ALL AI-TYPICAL LANGUAGE:**
- Eliminate: "Furthermore," "Moreover," "Additionally," "Nevertheless," "Consequently"
- Replace with: "And," "But," "So," "Plus," "Also," or just start new sentences
- Use abrupt transitions and tangential thoughts

**6. ADD HYPER-SPECIFIC DETAILS:**
- Replace "nice weather" → "that weird 73-degree October morning with the humidity that made my shirt stick"
- Replace "good food" → "the kind of greasy pizza that probably took years off my life but was worth every bite"
- Add sensory details that feel personally experienced

**7. INJECT PERSONALITY AND EMOTION:**
- Add personal reactions: "God, that was painful" "Christ, what a mess" "Ugh, seriously?"
- Include self-doubt: "I'm probably totally wrong here, but..." "Maybe I'm just being paranoid..."
- Add stream-of-consciousness asides and tangents

**CRITICAL:** The rewritten text should sound like it was written by a real person having real thoughts, not an AI trying to sound human. Every paragraph should have obvious human characteristics.

Return the COMPLETE text with DRAMATICALLY humanized writing that's obviously different from the original.`
                    },
                    {
                        role: "user",
                        content: `This text currently scores 90-100% on GPTZero/Copyleaks. Transform it to score 15-30% by applying ALL anti-detection techniques. Be RUTHLESS - destroy uniformity, inject imperfections, use heavy contractions. Preserve plot/characters but make it sound like casual human writing:\n\n${processableText}`
                    }
                ]);
                
                hideLoading();
                
                if (humanizedText && humanizedText.trim()) {
                    // Debug logging
                    console.log('=== HUMANIZATION DEBUG ===');
                    console.log('Original text length:', processableText.length);
                    console.log('Humanized text length:', humanizedText.length);
                    console.log('Original first 200 chars:', processableText.substring(0, 200));
                    console.log('Humanized first 200 chars:', humanizedText.substring(0, 200));
                    console.log('Texts are identical:', processableText.trim() === humanizedText.trim());
                    
                    showNotification('Text successfully humanized! Review the changes below.', 'success');
                    displayToolChanges('Text Humanization', processableText, humanizedText.trim());
                    
                    // Track human touch interaction
                    trackHumanTouch('lines_edited', 1);
                } else {
                    showNotification('Humanization completed but no changes detected. Text may already be sufficiently human-like.', 'warning');
                }
                
            } catch (error) {
                console.error('Humanization error:', error);
                hideLoading();
                
                // More detailed error message
                let errorMessage = 'Failed to humanize text. ';
                if (error.message && error.message.includes('token')) {
                    errorMessage += 'Story may be too long for processing. Try with shorter content.';
                } else if (error.message && error.message.includes('API')) {
                    errorMessage += 'Please check your OpenAI API key in Settings.';
                } else if (error.message && error.message.includes('rate')) {
                    errorMessage += 'Rate limit reached. Please wait a moment and try again.';
                } else {
                    errorMessage += 'Please try again or use a shorter text selection.';
                }
                
                showNotification(errorMessage, 'error');
            }
        }
        
        
        // Removed forensic analysis functions - focusing on humanization only

        // ============ UTILITY FUNCTIONS FOR TOOLS ============
        
        async function callOpenAI(messages) {
            const apiKey = getOpenAIApiKey();
            if (!apiKey) {
                throw new Error('OpenAI API key not configured');
            }
            
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: "gpt-4o-mini",
                    messages: messages,
                    temperature: 0.7,
                    max_tokens: 2000
                })
            });
            
            if (!response.ok) {
                throw new Error(`OpenAI API Error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }
        
        
        function displayToolChanges(title, originalText, newText) {
            // Generate highlighted diff
            const highlightedText = generateDiffHighlight(originalText, newText);
            
            // Create a modal for showing before/after comparison
            const resultModal = document.createElement('div');
            resultModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'bg-theme-secondary p-6 rounded-lg max-w-6xl max-h-[90vh] overflow-y-auto border-2 border-theme';
            
            modalContent.innerHTML = `
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-cyan-400">${title}</h3>
                    <button class="close-modal text-gray-400 hover:text-white">
                        <i class="fas fa-times text-xl"></i>
                    </button>
                </div>
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div class="bg-theme-primary p-4 rounded border border-theme">
                        <h4 class="text-sm font-bold text-gray-400 mb-2">ORIGINAL TEXT</h4>
                        <div class="text-xs text-theme-primary whitespace-pre-wrap max-h-96 overflow-y-auto bg-gray-900 p-3 rounded">${escapeHtml(originalText)}</div>
                    </div>
                    <div class="bg-theme-primary p-4 rounded border border-cyan-400">
                        <h4 class="text-sm font-bold text-cyan-400 mb-2">ENHANCED TEXT <span class="text-yellow-400">(Changes Highlighted)</span></h4>
                        <div class="text-xs text-theme-primary whitespace-pre-wrap max-h-96 overflow-y-auto bg-gray-900 p-3 rounded">${highlightedText}</div>
                    </div>
                </div>
                <div class="flex justify-between items-center">
                    <div class="text-xs text-theme-secondary">
                        💡 <strong>Tip:</strong> Yellow highlights show changes made. When applied, highlights are removed and only the changes remain.
                    </div>
                    <div class="flex space-x-3">
                        <button class="close-modal btn-gray px-4 py-2 rounded">
                            <i class="fas fa-times mr-1"></i>Keep Original
                        </button>
                        <button class="copy-changes btn-secondary px-4 py-2 rounded">
                            <i class="fas fa-copy mr-1"></i>Copy Enhanced
                        </button>
                        <button class="apply-enhanced btn-primary px-4 py-2 rounded">
                            <i class="fas fa-magic mr-1"></i>Apply Changes
                        </button>
                    </div>
                </div>
            `;
            
            // Add event listeners
            modalContent.querySelectorAll('.close-modal').forEach(btn => {
                btn.addEventListener('click', () => {
                    resultModal.remove();
                });
            });
            
            modalContent.querySelector('.copy-changes').addEventListener('click', () => {
                navigator.clipboard.writeText(newText).then(() => {
                    showNotification('Enhanced text copied to clipboard!', 'success');
                }).catch(() => {
                    showNotification('Failed to copy to clipboard', 'error');
                });
            });
            
            modalContent.querySelector('.apply-enhanced').addEventListener('click', () => {
                applyTextChanges(newText, resultModal);
            });
            
            resultModal.appendChild(modalContent);
            document.body.appendChild(resultModal);
        }

        function generateDiffHighlight(original, enhanced) {
            // Advanced word-by-word diff with precise highlighting
            const originalWords = original.split(/(\s+)/);
            const enhancedWords = enhanced.split(/(\s+)/);
            
            // Create a more sophisticated diff using dynamic programming approach
            const dp = [];
            for (let i = 0; i <= originalWords.length; i++) {
                dp[i] = [];
                for (let j = 0; j <= enhancedWords.length; j++) {
                    if (i === 0) dp[i][j] = j;
                    else if (j === 0) dp[i][j] = i;
                    else if (originalWords[i-1] === enhancedWords[j-1]) {
                        dp[i][j] = dp[i-1][j-1];
                    } else {
                        dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]);
                    }
                }
            }
            
            // Backtrack to find the actual changes
            let result = '';
            let i = originalWords.length;
            let j = enhancedWords.length;
            const changes = [];
            
            while (i > 0 && j > 0) {
                if (originalWords[i-1] === enhancedWords[j-1]) {
                    changes.unshift({type: 'same', word: enhancedWords[j-1]});
                    i--;
                    j--;
                } else if (dp[i-1][j] < dp[i][j-1]) {
                    // Deletion in original (skip)
                    i--;
                } else {
                    // Addition/substitution in enhanced (highlight)
                    changes.unshift({type: 'change', word: enhancedWords[j-1]});
                    j--;
                }
            }
            
            // Add remaining enhanced words (all changes)
            while (j > 0) {
                changes.unshift({type: 'change', word: enhancedWords[j-1]});
                j--;
            }
            
            // Build result with precise highlighting
            for (const change of changes) {
                if (change.type === 'same') {
                    result += escapeHtml(change.word);
                } else {
                    result += `<span style="background-color: #fbbf24; color: #000; padding: 1px 2px; border-radius: 2px; font-weight: 600;">${escapeHtml(change.word)}</span>`;
                }
            }
            
            return result;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function applyTextChanges(newText, modal) {
            console.log('✏️ Applying text changes - clearing dialogue data due to content modification...');
            
            // Clear dialogue data when text content is manually changed
            clearAllDialogueData(true);
            
            const editor = document.getElementById('storyEditor');
            if (!editor) {
                showNotification('No text editor found to apply changes', 'error');
                return;
            }

            // Save current state for undo
            saveEditState();

            // Apply the enhanced text
            editor.value = newText;
            
            // Update story data if we're in chapter editing mode
            const activeChapter = document.querySelector('.chapter-tab.active');
            if (activeChapter && storyData.chapters) {
                const chapterIndex = parseInt(activeChapter.dataset.chapter);
                if (!isNaN(chapterIndex) && storyData.chapters[chapterIndex]) {
                    storyData.chapters[chapterIndex].content = newText;
                }
            }

            // Track human touch for making edits
            trackHumanTouch('lines_edited', Math.max(1, newText.split('\n').length * 0.1));
            
            // Update UI
            updateUndoRedoButtons();
            showNotification('Changes applied successfully! ✨', 'success');
            
            modal.remove();
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showNotification('Result copied to clipboard!', 'success');
            }).catch(() => {
                showNotification('Failed to copy to clipboard', 'error');
            });
        }

        function copyAnalysis(title, content) {
            const textToCopy = `${title}\n${'='.repeat(title.length)}\n\n${content}`;
            navigator.clipboard.writeText(textToCopy).then(() => {
                showNotification('📋 Analysis copied to clipboard!', 'success');
            }).catch(() => {
                showNotification('Failed to copy to clipboard', 'error');
            });
        }

        function saveEditState() {
            const editor = document.getElementById('storyEditor');
            if (editor && editor.value !== (editHistory[historyIndex] || '')) {
                // Remove future history if we're not at the end
                if (historyIndex < editHistory.length - 1) {
                    editHistory = editHistory.slice(0, historyIndex + 1);
                }
                
                // Add new state
                editHistory.push(editor.value);
                historyIndex++;
                
                // Limit history size
                if (editHistory.length > 50) {
                    editHistory.shift();
                    historyIndex--;
                }
                
                updateUndoRedoButtons();
            }
        }

        function updateUndoRedoButtons() {
            const undoBtns = document.querySelectorAll('button[onclick="undoEdit()"]');
            const redoBtns = document.querySelectorAll('button[onclick="redoEdit()"]');
            
            undoBtns.forEach(btn => {
                btn.disabled = historyIndex <= 0;
                btn.style.opacity = historyIndex <= 0 ? '0.5' : '1';
            });
            
            redoBtns.forEach(btn => {
                btn.disabled = historyIndex >= editHistory.length - 1;
                btn.style.opacity = historyIndex >= editHistory.length - 1 ? '0.5' : '1';
            });
        }
        
        function updateHistoryButtons() {
            const undoBtns = document.querySelectorAll('[onclick="undoEdit()"]');
            const redoBtns = document.querySelectorAll('[onclick="redoEdit()"]');
            
            undoBtns.forEach(btn => {
                btn.disabled = historyIndex <= 0;
                btn.style.opacity = historyIndex <= 0 ? '0.5' : '1';
            });
            
            redoBtns.forEach(btn => {
                btn.disabled = historyIndex >= editHistory.length - 1;
                btn.style.opacity = historyIndex >= editHistory.length - 1 ? '0.5' : '1';
            });
        }

        async function applyToolChanges(title, suggestions, modal) {
            const editor = document.getElementById('storyEditor');
            const selectedText = getSelectedText(editor);
            const currentText = selectedText || editor.value;
            
            if (!currentText.trim()) {
                showNotification('No text to apply changes to', 'warning');
                return;
            }

            const confirmed = confirm(`Apply AI suggestions from "${title}" to your text?\n\nThis will modify your content based on the analysis.`);
            if (!confirmed) return;

            // Save current state before making changes
            saveEditState();

            showLoading('Applying AI suggestions to your text...');
            
            try {
                const improvedText = await callOpenAI([
                    {
                        role: "system",
                        content: "You are an expert editor. Apply the provided suggestions to improve the given text. Return ONLY the revised text, maintaining the original style and voice while implementing the suggested improvements."
                    },
                    {
                        role: "user",
                        content: `Original text:\n${currentText}\n\nSuggestions to apply:\n${suggestions}\n\nPlease provide the improved version:`
                    }
                ]);

                // Apply the changes
                if (selectedText) {
                    // Replace selected text
                    const start = editor.selectionStart;
                    const end = editor.selectionEnd;
                    editor.value = editor.value.substring(0, start) + improvedText + editor.value.substring(end);
                } else {
                    // Replace entire content
                    editor.value = improvedText;
                }

                // Update word count and save new state
                updateWordCount();
                saveEditState();
                
                hideLoading();
                modal.remove();
                
                showNotification(`✨ ${title} suggestions applied successfully!`, 'success');

            } catch (error) {
                console.error('Error applying suggestions:', error);
                hideLoading();
                showNotification('Failed to apply suggestions. Please try again.', 'error');
            }
        }
        
        // Utility Functions
        function getSelectedText(element) {
            const start = element.selectionStart;
            const end = element.selectionEnd;
            return start !== end ? element.value.substring(start, end) : '';
        }
        
        function replaceSelectedText(element, newText) {
            const start = element.selectionStart;
            const end = element.selectionEnd;
            const currentText = element.value;
            
            element.value = currentText.substring(0, start) + newText + currentText.substring(end);
            
            // Position cursor at end of replaced text
            element.selectionStart = element.selectionEnd = start + newText.length;
            element.focus();
        }
        
        // Enhanced word counting function
        function countWords(text) {
            if (!text || typeof text !== 'string') return 0;
            const words = text.trim().split(/\s+/).filter(word => word.length > 0);
            return text.trim() === '' ? 0 : words.length;
        }
        
        function updateWordCount() {
            const editor = document.getElementById('storyEditor');
            const text = editor.value;
            const wordCount = countWords(text);
            
            const wordCountElement = document.getElementById('wordCount');
            if (wordCountElement) {
                wordCountElement.textContent = `${wordCount.toLocaleString()} words`;
                
                // Update color based on target
                const target = storyData.settings?.wordsPerChapter || 1000;
                if (wordCount >= target) {
                    wordCountElement.style.color = '#10b981'; // green
                } else if (wordCount >= target * 0.7) {
                    wordCountElement.style.color = '#f59e0b'; // yellow
                } else {
                    wordCountElement.style.color = '#78e3fe'; // cyan
                }
            }
        }
        
        // Enhanced history management
        function saveToHistory() {
            const editor = document.getElementById('storyEditor');
            const currentState = editor.value;
            
            // Don't save if it's the same as the last state
            if (editHistory.length > 0 && editHistory[historyIndex] === currentState) {
                return;
            }
            
            // Remove future history if we're not at the end
            if (historyIndex < editHistory.length - 1) {
                editHistory = editHistory.slice(0, historyIndex + 1);
            }
            
            // Add new state to history
            editHistory.push(currentState);
            
            // Limit history size
            if (editHistory.length > maxHistorySize) {
                editHistory.shift();
            } else {
                historyIndex++;
            }
            
            updateHistoryButtons();
        }
        
        function undoEdit() {
            if (historyIndex > 0) {
                historyIndex--;
                const editor = document.getElementById('storyEditor');
                if (editor) {
                    editor.value = editHistory[historyIndex] || '';
                    updateWordCount();
                }
                updateUndoRedoButtons();
                showNotification('⏪ Changes undone', 'info');
            }
        }
        
        function redoEdit() {
            if (historyIndex < editHistory.length - 1) {
                historyIndex++;
                const editor = document.getElementById('storyEditor');
                if (editor) {
                    editor.value = editHistory[historyIndex] || '';
                    updateWordCount();
                }
                updateUndoRedoButtons();
                showNotification('⏩ Changes redone', 'info');
            }
        }
        
        function saveStory() {
            const editor = document.getElementById('storyEditor');
            const content = editor.value;
            
            // Save to localStorage with timestamp
            const saveData = {
                content: content,
                storyData: storyData,
                timestamp: new Date().toISOString(),
                wordCount: countWords(content)
            };
            
            localStorage.setItem('authorr_story_save', JSON.stringify(saveData));
            localStorage.setItem('authorr_story_content', content);
            localStorage.setItem('authorr_story_data', JSON.stringify(storyData));
            
            // Visual feedback
            const saveBtn = document.getElementById('saveBtn');
            const originalText = saveBtn.innerHTML;
            saveBtn.innerHTML = '<i class="fas fa-check"></i> Saved';
            saveBtn.classList.add('success-border');
            
            showStatusMessage(`Story saved! (${countWords(content)} words)`);
            
            setTimeout(() => {
                saveBtn.innerHTML = originalText;
                saveBtn.classList.remove('success-border');
            }, 2000);
        }
        
        function setupAutoSave() {
            const editor = document.getElementById('storyEditor');
            if (editor) {
                let autoSaveTimer;
                
                editor.addEventListener('input', () => {
                    clearTimeout(autoSaveTimer);
                    autoSaveTimer = setTimeout(() => {
                        if (document.getElementById('autoSave').checked) {
                            saveStory();
                        }
                    }, 30000);
                });
            }
        }
        
        // Status messaging system
        function showStatusMessage(message) {
            // Create or update status message element
            let statusEl = document.getElementById('statusMessage');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'statusMessage';
                statusEl.className = 'fixed bottom-4 right-4 bg-cyan-400 text-black px-4 py-2 rounded-lg font-semibold z-50 transition-all duration-300';
                document.body.appendChild(statusEl);
            }
            
            statusEl.textContent = message;
            statusEl.style.display = 'block';
            statusEl.style.opacity = '1';
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                statusEl.style.opacity = '0';
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 300);
            }, 3000);
        }
        
        // Narration Functions
        function transferStoryToNarration() {
            const editor = document.getElementById('storyEditor');
            const content = editor.value;
            
            if (content.trim()) {
                storyData.currentContent = content;
                
                // Update preview text with first paragraph
                const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
                const previewText = sentences.slice(0, 2).join('. ') + '.';
                document.getElementById('previewText').value = previewText;
                
                showStatusMessage('Story transferred to narration page');
            }
        }
        
        async function previewVoice() {
            const previewText = document.getElementById('previewText').value;
            const selectedVoice = document.getElementById('voiceSelection').value;
            
            if (!previewText.trim()) {
                alert('Please enter text to preview.');
                return;
            }
            
            showLoading(`Generating voice preview with ${selectedVoice}...`);
            
            try {
                await simulateVoicePreview(previewText, selectedVoice);
                hideLoading();
                showStatusMessage(`Voice preview for "${selectedVoice}" generated successfully!`);
            } catch (error) {
                console.error('Voice preview error:', error);
                alert('Failed to generate voice preview. Please try again.');
                hideLoading();
            }
        }
        
        async function simulateVoicePreview(text, voice) {
            // Simulate TTS API call
            await new Promise(resolve => setTimeout(resolve, 2500));
            console.log(`Generated preview with voice: ${voice}, text: ${text.substring(0, 50)}...`);
        }
        
        async function generateNarration() {
            const content = storyData.currentContent || document.getElementById('storyEditor').value;
            const selectedVoice = document.getElementById('voiceSelection').value;
            const speechRate = document.getElementById('speechRate').value;
            const audioFormat = document.getElementById('audioFormat').value;
            
            if (!content.trim()) {
                alert('No story content found. Please create content in the workspace first.');
                return;
            }
            
            document.getElementById('narrationProgress').classList.remove('hidden');
            showProgressBar();
            
            try {
                await simulateFullNarrationGeneration(content, selectedVoice, speechRate, audioFormat);
                displayEnhancedAudioResults(selectedVoice, audioFormat);
                showStatusMessage('Full narration generated successfully!');
            } catch (error) {
                console.error('Narration generation error:', error);
                alert('Failed to generate narration. Please try again.');
            } finally {
                document.getElementById('narrationProgress').classList.add('hidden');
            }
        }
        
        async function simulateFullNarrationGeneration(content, voice, rate, format) {
            // Simulate progress through content
            const chapters = storyData.chapters.length || 5;
            
            for (let i = 0; i < chapters; i++) {
                const progress = ((i + 1) / chapters) * 100;
                updateProgressBar(progress);
                updateLoadingText(`Generating audio for chapter ${i + 1} of ${chapters} with ${voice} voice...`);
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
        }
        
        function showProgressBar() {
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressPercent').textContent = '0%';
        }
        
        function updateProgressBar(percent) {
            document.getElementById('progressBar').style.width = `${percent}%`;
            document.getElementById('progressPercent').textContent = `${Math.round(percent)}%`;
        }
        
        function displayEnhancedAudioResults(voice, format) {
            const resultsContainer = document.getElementById('audioResults');
            const chapterCount = storyData.chapters.length || 5;
            
            let resultsHTML = `
                <div class="bg-theme-primary p-4 rounded-lg border border-theme">
                    <h3 class="font-semibold mb-3">Generated Audio Files (${voice} voice, ${format} format)</h3>
                    <div class="space-y-2">
            `;
            
            for (let i = 1; i <= chapterCount; i++) {
                resultsHTML += `
                    <div class="flex justify-between items-center p-2 bg-theme-secondary rounded">
                        <span>Chapter ${i} - ${storyData.chapters[i-1]?.title || `Part ${i}`}</span>
                        <div class="space-x-2">
                            <button class="btn-secondary px-2 py-1 rounded text-xs">
                                <i class="fas fa-play"></i> Play
                            </button>
                            <button class="btn-primary px-2 py-1 rounded text-xs">
                                <i class="fas fa-download"></i> Download
                            </button>
                        </div>
                    </div>
                `;
            }
            
            resultsHTML += `
                    </div>
                    <div class="mt-4 text-center">
                        <button class="btn-primary px-6 py-2 rounded-lg">
                            <i class="fas fa-download mr-2"></i>Download All Audio Files
                        </button>
                    </div>
                </div>
            `;
            
            resultsContainer.innerHTML = resultsHTML;
        }
        
        // Book Cover Generation
        async function generateCover() {
            const style = document.getElementById('coverStyle').value;
            const description = document.getElementById('coverDescription').value;
            const title = document.getElementById('bookTitle').value || storyData.title || 'Untitled Book';
            
            if (!description.trim() && !title) {
                alert('Please enter a cover description or book title.');
                return;
            }
            
            showLoading('Creating HD book cover with DALL-E 3...');
            
            try {
                const coverUrl = await simulateEnhancedCoverGeneration(style, description, title);
                displayGeneratedCover(coverUrl);
                hideLoading();
                showStatusMessage('Professional book cover generated!');
            } catch (error) {
                console.error('Cover generation error:', error);
                alert('Failed to generate book cover. Please try again.');
                hideLoading();
            }
        }
        
        async function simulateEnhancedCoverGeneration(style, description, title) {
            // Simulate DALL-E 3 API call
            await new Promise(resolve => setTimeout(resolve, 4000));
            
            // Create a more realistic placeholder that reflects the inputs
            const encodedTitle = encodeURIComponent(title);
            const styleColors = {
                'modern': '78e3fe/000000',
                'classic': '8B4513/F5F5DC',
                'mysterious': '2F2F2F/FF6B6B',
                'romantic': 'FFB6C1/8B008B',
                'fantasy': '4B0082/FFD700',
                'scifi': '191970/00FFFF',
                'horror': '8B0000/000000',
                'children': 'FF69B4/FFFF00'
            };
            
            const colors = styleColors[style] || '78e3fe/000000';
            return `https://via.placeholder.com/400x600/${colors}?text=${encodedTitle}`;
        }
        
        function displayGeneratedCover(imageUrl) {
            const coverPreview = document.getElementById('coverPreview');
            const generatedCover = document.getElementById('generatedCover');
            
            generatedCover.src = imageUrl;
            generatedCover.alt = `Generated book cover for ${storyData.title || 'your book'}`;
            coverPreview.classList.remove('hidden');
        }
        
        async function regenerateCover() {
            showStatusMessage('Regenerating book cover...');
            generateCover();
        }
        
        function downloadCover() {
            const coverImage = document.getElementById('generatedCover');
            const link = document.createElement('a');
            link.href = coverImage.src;
            link.download = `${storyData.title || 'Book'}_Cover.png`;
            link.click();
            showStatusMessage('Book cover download initiated');
        }
        
        // Configuration Functions
        async function testApiConnection() {
            const apiKey = document.getElementById('openaiKey').value;
            
            if (!apiKey.trim()) {
                alert('Please enter your OpenAI API key.');
                return;
            }
            
            showLoading('Testing OpenAI API connection...');
            
            try {
                // Simulate API test
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                // Save API key
                localStorage.setItem('openaiApiKey', apiKey);
                
                hideLoading();
                showStatusMessage('API connection successful! Key saved.');
            } catch (error) {
                console.error('API test error:', error);
                alert('API connection failed. Please check your key and try again.');
                hideLoading();
            }
        }
        
        // Helper Functions
        function getAllChaptersText() {
            // Get all chapters from storyData
            if (storyData.chapters && storyData.chapters.length > 0) {
                return storyData.chapters.map((chapter, index) => {
                    const title = chapter.title || `Chapter ${index + 1}`;
                    const content = chapter.content || '';
                    return `=== ${title} ===\n\n${content}`;
                }).join('\n\n');
            }
            
            // Fallback to current editor content if no chapters exist
            const editor = document.getElementById('storyEditor');
            return editor ? editor.value : '';
        }
        
        // NEW: Ensure we always get the FULL content, never truncated previews
        function getFullStoryContent() {
            // Priority order: chapters > current content > editor
            let content = '';
            
            // Try chapters first (most complete)
            if (storyData.chapters && storyData.chapters.length > 0) {
                content = getAllChaptersText();
                if (content && content.trim().length > 0) {
                    console.log('✅ Using chapters content:', content.length, 'characters');
                    return content;
                }
            }
            
            // Try current content (but check it's not truncated)
            if (storyData.currentContent && !storyData.currentContent.includes('[Content truncated')) {
                content = storyData.currentContent;
                if (content && content.trim().length > 0) {
                    console.log('✅ Using currentContent:', content.length, 'characters');
                    return content;
                }
            }
            
            // Fallback to editor
            const editor = document.getElementById('storyEditor');
            content = editor ? editor.value : '';
            if (content && content.trim().length > 0) {
                console.log('✅ Using storyEditor content:', content.length, 'characters');
                return content;
            }
            
            console.log('❌ No content found in any source');
            return '';
        }
        
        function getTextWithinLimits(text, maxTokens = 15000) {
            // Rough estimation: 1 token ≈ 4 characters for English text
            const maxChars = maxTokens * 4;
            
            if (text.length <= maxChars) {
                return text;
            }
            
            // If text is too long, truncate and add notice
            const truncatedText = text.substring(0, maxChars - 200);
            return truncatedText + "\n\n[Note: Text has been truncated to fit processing limits. Analysis covers the first portion of your story.]";
        }
        
        function hasMultipleChapters() {
            return storyData.chapters && storyData.chapters.length > 1;
        }
        
        // Utility Functions
        function showLoading(text = 'Processing...', animationType = 'book') {
            document.getElementById('loadingText').textContent = text;
            
            const bookLoader = document.querySelector('.book-loader');
            const spinnerLoader = document.querySelector('.loading-spinner');
            
            if (animationType === 'book') {
                bookLoader.style.display = 'block';
                spinnerLoader.style.display = 'none';
            } else {
                bookLoader.style.display = 'none';
                spinnerLoader.style.display = 'block';
            }
            
            document.getElementById('loadingOverlay').classList.remove('hidden');
        }
        
        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
        }
        
        function updateLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
        }
        
        // Initialize word count tracking and event listeners
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                const editor = document.getElementById('storyEditor');
                if (editor) {
                    // Real-time word count updates
                    editor.addEventListener('input', updateWordCount);
                    editor.addEventListener('keyup', updateWordCount);
                    editor.addEventListener('paste', () => setTimeout(updateWordCount, 10));
                    
                    // Initialize history with empty state
                    saveToHistory();
                    updateHistoryButtons();
                    
                    // Load any saved content
                    const savedContent = localStorage.getItem('authorr_story_content');
                    if (savedContent) {
                        editor.value = savedContent;
                        updateWordCount();
                        showStatusMessage('Previously saved content restored');
                    }
                }
                
                // Load saved story data
                const savedData = localStorage.getItem('authorr_story_data');
                if (savedData) {
                    try {
                        storyData = JSON.parse(savedData);
                        if (storyData.title) {
                            document.getElementById('bookTitle').value = storyData.title;
                        }
                    } catch (e) {
                        console.warn('Failed to load saved story data:', e);
                    }
                }
            }, 100);
        });

        // Real-time Word Count functionality
        function setupWordCount() {
            const storyOutline = document.getElementById('storyOutline');
            const wordCountDisplay = document.getElementById('outlineWordCount');
            
            if (storyOutline && wordCountDisplay) {
                storyOutline.addEventListener('input', function() {
                    const text = this.value.trim();
                    const wordCount = text === '' ? 0 : text.split(/\s+/).length;
                    wordCountDisplay.textContent = `${wordCount} words`;
                });
            }
        }

        // Voice Cloning Station Functions
        function handleVoiceDrop(event) {
            event.preventDefault();
            const files = event.dataTransfer.files;
            handleVoiceFiles(files);
        }
        
        function allowDrop(event) {
            event.preventDefault();
        }
        
        function handleVoiceFiles(files) {
            const validTypes = ['audio/mp3', 'audio/wav', 'audio/m4a'];
            const validFiles = Array.from(files).filter(file => 
                validTypes.includes(file.type) || 
                validTypes.some(type => file.name.toLowerCase().endsWith(type.split('/')[1]))
            );
            
            if (validFiles.length > 0) {
                console.log('Voice files selected:', validFiles.map(f => f.name));
                showNotification(`${validFiles.length} voice sample(s) selected for cloning`, 'success');
            } else {
                showNotification('Please select valid audio files (.mp3, .wav, .m4a)', 'error');
            }
        }
        
        function initiateVoiceClone() {
            const uploadInput = document.getElementById('voiceUpload');
            const files = uploadInput.files;
            
            if (files.length === 0) {
                showNotification('Please select voice samples first', 'error');
                return;
            }
            
            // Show progress animation
            const progressDiv = document.getElementById('cloningProgress');
            const progressBar = document.getElementById('cloningBar');
            const progressPercent = document.getElementById('cloningPercent');
            
            progressDiv.classList.remove('hidden');
            
            // Simulate cloning progress
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress > 100) progress = 100;
                
                progressBar.style.width = `${progress}%`;
                progressPercent.textContent = `${Math.round(progress)}%`;
                
                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        progressDiv.classList.add('hidden');
                        showNotification('Voice clone created successfully!', 'success');
                    }, 1000);
                }
            }, 500);
        }
        
        // Setup word count monitoring on page load
        document.addEventListener('DOMContentLoaded', function() {
            const voiceUpload = document.getElementById('voiceUpload');
            if (voiceUpload) {
                voiceUpload.addEventListener('change', function() {
                    handleVoiceFiles(this.files);
                });
            }
            
            // Setup word count monitoring
            setupWordCount();
        });

        // Platform Template Functions
        const platformDimensions = {
            'audible': { width: 2400, height: 2400, name: 'Audible' },
            'spotify': { width: 3000, height: 3000, name: 'Spotify' },
            'apple': { width: 3000, height: 3000, name: 'Apple Podcasts' },
            'google': { width: 2400, height: 2400, name: 'Google Play' },
            'overdrive': { width: 1800, height: 2700, name: 'OverDrive' },
            'universal': { width: 2400, height: 2400, name: 'Universal' }
        };

        function selectPlatformTemplate(platform) {
            const platformSelect = document.getElementById('selectedPlatform');
            const dimensionDisplay = document.getElementById('dimensionDisplay');
            
            if (platformSelect) {
                platformSelect.value = platform;
            }
            
            const dimensions = platformDimensions[platform];
            if (dimensionDisplay && dimensions) {
                dimensionDisplay.textContent = `${dimensions.width}×${dimensions.height}px`;
            }
            
            // Visual feedback
            document.querySelectorAll('.platform-template').forEach(btn => {
                btn.classList.remove('border-cyan-400', 'bg-cyan-900');
            });
            
            const selectedBtn = document.querySelector(`[onclick="selectPlatformTemplate('${platform}')"]`);
            if (selectedBtn) {
                selectedBtn.classList.add('border-cyan-400', 'bg-cyan-900');
            }
            
            showNotification(`Selected ${dimensions.name} template (${dimensions.width}×${dimensions.height}px)`, 'success');
        }

        // OpenAI DALL-E Cover Generation Functions
        async function generateAICover() {
            const apiKey = getOpenAIApiKey();
            if (!apiKey) {
                showNotification('Please configure your OpenAI API key in the Config section first', 'error');
                return;
            }

            const title = document.getElementById('coverTitle')?.value?.trim();
            const author = document.getElementById('coverAuthor')?.value?.trim();
            const subtitle = document.getElementById('coverSubtitle')?.value?.trim();
            const description = document.getElementById('coverDescription')?.value?.trim();
            const style = document.getElementById('coverStyle')?.value || 'modern';
            const artStyle = document.getElementById('artStyle')?.value || 'digital-art';
            const platform = document.getElementById('selectedPlatform')?.value || 'universal';
            const quality = document.getElementById('imageQuality')?.value || 'hd';

            if (!title) {
                showNotification('Please enter a book title', 'error');
                return;
            }

            if (!description) {
                showNotification('Please provide a visual description for the cover', 'error');
                return;
            }

            // Show progress
            const progressDiv = document.getElementById('coverGenerationProgress');
            const progressBar = document.getElementById('coverProgressBar');
            const stepText = document.getElementById('generationStep');
            const progressMessage = document.getElementById('progressMessage');
            
            progressDiv.classList.remove('hidden');
            
            const steps = [
                'Analyzing design requirements...',
                'Processing with DALL-E AI...',
                'Generating high-quality artwork...',
                'Optimizing for platform requirements...',
                'Finalizing cover design...'
            ];

            let currentStep = 0;
            const stepInterval = setInterval(() => {
                if (currentStep < steps.length) {
                    stepText.textContent = steps[currentStep];
                    progressBar.style.width = `${(currentStep + 1) * 20}%`;
                    currentStep++;
                }
            }, 2000);

            // Build comprehensive prompt
            const platformInfo = platformDimensions[platform];
            const prompt = buildCoverPrompt(title, author, subtitle, description, style, artStyle, platformInfo);

            try {
                progressMessage.textContent = 'Connecting to OpenAI DALL-E API...';
                
                const response = await fetch('https://api.openai.com/v1/images/generations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "dall-e-3",
                        prompt: prompt,
                        n: 1,
                        size: quality === 'hd' ? '1792x1024' : '1024x1024',
                        quality: quality,
                        style: 'vivid'
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API Error: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                const imageUrl = data.data[0].url;

                clearInterval(stepInterval);
                progressBar.style.width = '100%';
                stepText.textContent = 'Cover generated successfully!';

                setTimeout(() => {
                    progressDiv.classList.add('hidden');
                    displayGeneratedCover(imageUrl, platform);
                }, 1500);

            } catch (error) {
                clearInterval(stepInterval);
                progressDiv.classList.add('hidden');
                console.error('Cover generation error:', error);
                showNotification(`Failed to generate cover: ${error.message}`, 'error');
            }
        }

        function buildCoverPrompt(title, author, subtitle, description, style, artStyle, platformInfo) {
            let prompt = `Create a professional book cover in ${artStyle} style with ${style} aesthetic. `;
            prompt += `The book title is "${title}" by ${author}. `;
            
            if (subtitle) {
                prompt += `Subtitle: "${subtitle}". `;
            }
            
            prompt += `Visual description: ${description}. `;
            prompt += `The cover should be optimized for ${platformInfo.name} (${platformInfo.width}x${platformInfo.height} pixels). `;
            prompt += `Include clear, readable typography for the title and author name. `;
            prompt += `The design should be eye-catching, professional, and genre-appropriate. `;
            prompt += `Ensure high contrast and readability at thumbnail sizes. `;
            prompt += `No explicit content, copyright violations, or text overlay issues.`;

            return prompt;
        }

        function displayGeneratedCover(imageUrl, platform) {
            const coverPreview = document.getElementById('coverPreview');
            const generatedCover = document.getElementById('generatedCover');
            const placeholderPreview = document.getElementById('placeholderPreview');
            const dimensionDisplay = document.getElementById('dimensionDisplay');
            
            generatedCover.src = imageUrl;
            
            const dimensions = platformDimensions[platform];
            if (dimensionDisplay && dimensions) {
                dimensionDisplay.textContent = `${dimensions.width}×${dimensions.height}px`;
            }
            
            placeholderPreview.classList.add('hidden');
            coverPreview.classList.remove('hidden');
            
            showNotification('AI book cover generated successfully!', 'success');
        }

        async function regenerateAICover() {
            showNotification('Regenerating cover with new AI variations...', 'info');
            setTimeout(() => {
                generateAICover();
            }, 500);
        }

        async function createVariations() {
            const apiKey = getOpenAIApiKey();
            if (!apiKey) {
                showNotification('Please configure your OpenAI API key first', 'error');
                return;
            }

            const generatedCover = document.getElementById('generatedCover');
            if (!generatedCover.src) {
                showNotification('Please generate a cover first', 'error');
                return;
            }

            showNotification('Creating AI variations of your cover...', 'info');
            
            try {
                // Note: DALL-E 3 doesn't support variations, so we'll regenerate with slight prompt modifications
                const variations = [];
                const basePrompt = document.getElementById('coverDescription')?.value || '';
                
                const promptVariations = [
                    basePrompt + ' with warmer color palette',
                    basePrompt + ' with cooler tones',
                    basePrompt + ' with different composition'
                ];

                // Generate multiple variations (simplified for demo)
                for (let i = 0; i < 2; i++) {
                    // Simulate variation generation
                    setTimeout(() => {
                        addCoverVariation(generatedCover.src, i + 1);
                    }, (i + 1) * 1000);
                }
                
                document.getElementById('coverVariations').classList.remove('hidden');
                
            } catch (error) {
                console.error('Variation generation error:', error);
                showNotification('Failed to create variations', 'error');
            }
        }

        function addCoverVariation(imageUrl, index) {
            const variationsGrid = document.getElementById('variationsGrid');
            const variationDiv = document.createElement('div');
            variationDiv.className = 'cover-variation p-2 rounded-lg border border-theme cursor-pointer hover:border-cyan-400 transition-colors';
            variationDiv.innerHTML = `
                <img src="${imageUrl}" alt="Cover Variation ${index}" class="w-full rounded">
                <button onclick="selectVariation(this)" class="w-full mt-2 btn-secondary text-xs py-1">
                    Use This Version
                </button>
            `;
            variationsGrid.appendChild(variationDiv);
        }

        function selectVariation(button) {
            const img = button.parentElement.querySelector('img');
            const mainCover = document.getElementById('generatedCover');
            mainCover.src = img.src;
            showNotification('Cover variation selected!', 'success');
        }

        function downloadCover() {
            const coverImg = document.getElementById('generatedCover');
            if (!coverImg.src) {
                showNotification('No cover to download', 'error');
                return;
            }

            const platform = document.getElementById('selectedPlatform')?.value || 'universal';
            const title = document.getElementById('coverTitle')?.value || 'book-cover';
            
            downloadImage(coverImg.src, `${title}-${platform}-cover.png`);
            showNotification('Cover downloaded successfully!', 'success');
        }

        function downloadForPlatform(type) {
            const coverImg = document.getElementById('generatedCover');
            if (!coverImg.src) {
                showNotification('No cover to download', 'error');
                return;
            }

            const title = document.getElementById('coverTitle')?.value || 'book-cover';
            const filename = type === 'print' ? 
                `${title}-print-ready.png` : 
                `${title}-web-optimized.png`;
            
            downloadImage(coverImg.src, filename);
            showNotification(`${type === 'print' ? 'Print-ready' : 'Web-optimized'} cover downloaded!`, 'success');
        }

        function downloadImage(url, filename) {
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function setCoverAsMain() {
            const coverImg = document.getElementById('generatedCover');
            if (coverImg.src) {
                // Store the cover URL for use in other parts of the app
                localStorage.setItem('mainBookCover', coverImg.src);
                showNotification('Cover set as main book cover!', 'success');
            }
        }

        // Helper function to get OpenAI API key
        // Note: getOpenAIApiKey function is defined later in the file

        // OpenAI GPT-4 Writing Assistance Functions
        async function generateChapterPlan() {
            const apiKey = getOpenAIApiKey();
            if (!apiKey) {
                showNotification('Please configure your OpenAI API key in Config section first', 'error');
                return;
            }

            const title = document.getElementById('bookTitle')?.value?.trim();
            const outline = document.getElementById('storyOutline')?.value?.trim();
            const genre = document.getElementById('genre')?.value || 'fiction-literary';
            const tone = document.getElementById('tone')?.value || 'professional';
            const chapterCount = parseInt(document.getElementById('chapterCount')?.value || 10);
            const wordsPerChapter = parseInt(document.getElementById('wordsPerChapter')?.value || 1000);

            if (!title || !outline) {
                showNotification('Please fill in the book title and story outline', 'error');
                return;
            }

            showNotification('Generating AI chapter plan...', 'info');
            
            const prompt = `Create a detailed chapter plan for a ${genre} book titled "${title}".

Story Outline: ${outline}
Tone: ${tone}
Number of chapters: ${chapterCount}
Target words per chapter: ${wordsPerChapter}

Generate a comprehensive chapter plan with:
1. Chapter titles
2. Brief chapter summaries (2-3 sentences each)
3. Key plot points and character development
4. Pacing and story arc progression

IMPORTANT: Respond with ONLY valid JSON, no markdown formatting or explanations.

JSON Structure:
{
  "chapters": [
    {
      "number": 1,
      "title": "Chapter Title",
      "summary": "Chapter summary...",
      "keyPoints": ["Point 1", "Point 2"],
      "wordCount": ${wordsPerChapter}
    }
  ]
}`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        messages: [
                            {
                                role: "system",
                                content: "You are a professional book planning assistant. Create detailed, engaging chapter plans that follow proper story structure and pacing. Always respond with valid JSON only, no markdown formatting or code blocks."
                            },
                            {
                                role: "user",
                                content: prompt
                            }
                        ],
                        temperature: 0.7,
                        max_tokens: 2000
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API Error: ${response.status}`);
                }

                const data = await response.json();
                let content = data.choices[0].message.content;
                
                // Clean the response - remove markdown formatting
                content = content.replace(/```json\s*/gi, '').replace(/```\s*/gi, '').trim();
                
                // Additional cleaning for common AI response issues
                content = content.replace(/^Here's.*?:/gi, '').trim();
                content = content.replace(/^Based on.*?:/gi, '').trim();
                
                let chapterPlan;
                try {
                    chapterPlan = JSON.parse(content);
                } catch (parseError) {
                    console.error('JSON parsing failed, raw content:', content);
                    throw new Error('Invalid JSON response from AI. Please try again.');
                }
                
                displayChapterPlan(chapterPlan);
                showNotification('Chapter plan generated successfully!', 'success');
                
            } catch (error) {
                console.error('Chapter generation error:', error);
                showNotification(`Failed to generate chapters: ${error.message}`, 'error');
            }
        }

        function displayChapterPlan(chapterPlan) {
            const chaptersContainer = document.getElementById('chapterPlan');
            if (!chaptersContainer) {
                console.error('Chapter plan container not found');
                return;
            }

            chaptersContainer.innerHTML = '';
            storyData.chapters = chapterPlan.chapters;

            chapterPlan.chapters.forEach(chapter => {
                const chapterDiv = document.createElement('div');
                chapterDiv.className = 'chapter-card bg-theme-primary p-4 rounded-lg border border-theme';
                chapterDiv.id = `chapter-${chapter.number}`;
                chapterDiv.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <h3 class="font-bold text-lg editable-title" contenteditable="true" data-chapter="${chapter.number}">${chapter.number}. ${chapter.title}</h3>
                        <span class="text-xs text-theme-secondary">${chapter.wordCount} words</span>
                    </div>
                    <p class="text-sm text-theme-secondary mb-2 editable-summary" contenteditable="true" data-chapter="${chapter.number}">${chapter.summary}</p>
                    <div class="flex flex-wrap gap-1 mb-3">
                        ${chapter.keyPoints.map(point => 
                            `<span class="text-xs bg-cyan-900 text-cyan-300 px-2 py-1 rounded">${point}</span>`
                        ).join('')}
                    </div>
                    <div class="flex space-x-2">
                        <button onclick="generateChapterContent(${chapter.number})" class="btn-primary text-xs px-3 py-1 rounded">
                            <i class="fas fa-sync mr-1"></i>Regenerate Chapter
                        </button>
                        <button onclick="editChapter(${chapter.number})" class="btn-secondary text-xs px-3 py-1 rounded">
                            <i class="fas fa-edit mr-1"></i>Edit
                        </button>
                    </div>
                `;
                chaptersContainer.appendChild(chapterDiv);
            });
            
            // Enable the Generate All Chapters and Combine All buttons
            const generateAllBtn = document.getElementById('generateAllBtn');
            if (generateAllBtn) {
                generateAllBtn.disabled = false;
                generateAllBtn.classList.remove('opacity-50');
            }
            
            const combineAllBtn = document.getElementById('combineAllBtn');
            if (combineAllBtn) {
                combineAllBtn.disabled = false;
                combineAllBtn.classList.remove('opacity-50');
            }
        }

        // OpenAI TTS (Text-to-Speech) Functions
        async function generateFullNarration() {
            const apiKey = getOpenAIApiKey();
            if (!apiKey) {
                showNotification('Please configure your OpenAI API key first', 'error');
                return;
            }

            if (!storyData.chapters || storyData.chapters.length === 0) {
                showNotification('Please generate chapter content first', 'error');
                return;
            }

            const voice = document.getElementById('voiceSelection')?.value || 'alloy';
            const speed = parseFloat(document.getElementById('speechRate')?.value || 1.0);
            
            showNotification('Starting AI narration generation...', 'info');
            
            const progressDiv = document.getElementById('narrationProgress');
            const progressBar = document.getElementById('progressBar');
            const progressPercent = document.getElementById('progressPercent');
            
            progressDiv.classList.remove('hidden');
            
            try {
                const audioFiles = [];
                
                for (let i = 0; i < storyData.chapters.length; i++) {
                    const chapter = storyData.chapters[i];
                    
                    progressPercent.textContent = `${Math.round((i / storyData.chapters.length) * 100)}%`;
                    progressBar.style.width = `${(i / storyData.chapters.length) * 100}%`;
                    
                    if (chapter.content) {
                        const audioBlob = await generateChapterAudio(chapter.content, voice, speed, apiKey);
                        audioFiles.push({
                            chapter: i + 1,
                            title: chapter.title,
                            audioBlob: audioBlob,
                            url: URL.createObjectURL(audioBlob)
                        });
                        
                        displayAudioResult(audioFiles[audioFiles.length - 1]);
                    }
                }
                
                progressPercent.textContent = '100%';
                progressBar.style.width = '100%';
                
                setTimeout(() => {
                    progressDiv.classList.add('hidden');
                    showNotification('All chapters narrated successfully!', 'success');
                }, 1000);
                
            } catch (error) {
                progressDiv.classList.add('hidden');
                console.error('Narration error:', error);
                showNotification(`Narration failed: ${error.message}`, 'error');
            }
        }

        async function generateChapterAudio(text, voice, speed, apiKey) {
            const response = await fetch('https://api.openai.com/v1/audio/speech', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: "tts-1-hd",
                    input: text,
                    voice: voice,
                    speed: speed
                })
            });

            if (!response.ok) {
                throw new Error(`TTS API Error: ${response.status}`);
            }

            return await response.blob();
        }

        function displayAudioResult(audioData) {
            const resultsContainer = document.getElementById('audioResults');
            const audioDiv = document.createElement('div');
            audioDiv.className = 'audio-result bg-theme-primary p-4 rounded-lg border border-theme';
            audioDiv.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <h4 class="font-semibold">Chapter ${audioData.chapter}: ${audioData.title}</h4>
                    <span class="text-xs text-theme-secondary">Generated</span>
                </div>
                <audio controls class="w-full mb-2">
                    <source src="${audioData.url}" type="audio/mpeg">
                </audio>
                <div class="flex space-x-2">
                    <button onclick="downloadAudio('${audioData.url}', 'chapter-${audioData.chapter}')" class="btn-secondary text-xs px-3 py-1 rounded">
                        <i class="fas fa-download mr-1"></i>Download
                    </button>
                    <button onclick="regenerateChapterAudio(${audioData.chapter})" class="btn-secondary text-xs px-3 py-1 rounded">
                        <i class="fas fa-sync mr-1"></i>Regenerate
                    </button>
                </div>
            `;
            resultsContainer.appendChild(audioDiv);
        }

        function downloadAudio(url, filename) {
            const link = document.createElement('a');
            link.href = url;
            link.download = `${filename}.mp3`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Enhanced Chapter Content Generation
        async function generateChapterContent(chapterNumber) {
            console.log(`📝 Generating new chapter ${chapterNumber} content - clearing old dialogue data...`);
            
            // Clear dialogue data when generating new content
            clearAllDialogueData(true);
            
            const apiKey = getOpenAIApiKey();
            if (!apiKey) {
                showNotification('Please configure your OpenAI API key first', 'error');
                return;
            }

            const chapter = storyData.chapters.find(c => c.number === chapterNumber);
            if (!chapter) return;

            showNotification(`Generating content for Chapter ${chapterNumber}...`, 'info');

            const prompt = `Write the full content for this chapter of the book "${storyData.title}".

Chapter ${chapter.number}: ${chapter.title}
Summary: ${chapter.summary}
Key Points: ${chapter.keyPoints.join(', ')}
Target Word Count: ${chapter.wordCount}
Genre: ${document.getElementById('genre')?.value}
Tone: ${document.getElementById('tone')?.value}

Write engaging, well-structured prose that:
1. Follows the chapter summary and incorporates all key points
2. Maintains consistent tone and style
3. Includes dialogue, descriptions, and narrative flow
4. Meets the target word count
5. Ends with a natural transition to the next chapter

Format as clean, readable text ready for narration.`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        messages: [
                            {
                                role: "system", 
                                content: "You are a professional author and storyteller. Write compelling, well-crafted chapter content that engages readers and flows naturally."
                            },
                            {
                                role: "user",
                                content: prompt
                            }
                        ],
                        temperature: 0.8,
                        max_tokens: 4000
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API Error: ${response.status}`);
                }

                const data = await response.json();
                chapter.content = data.choices[0].message.content;
                
                updateChapterDisplay(chapterNumber);
                showNotification(`Chapter ${chapterNumber} content generated!`, 'success');
                
            } catch (error) {
                console.error('Content generation error:', error);
                showNotification(`Failed to generate content: ${error.message}`, 'error');
            }
        }

        function updateChapterDisplay(chapterNumber) {
            const chapterCards = document.querySelectorAll('.chapter-card');
            const targetCard = chapterCards[chapterNumber - 1];
            
            if (targetCard) {
                const generateBtn = targetCard.querySelector('button');
                generateBtn.innerHTML = '<i class="fas fa-check mr-1"></i>Content Ready';
                generateBtn.classList.remove('btn-primary');
                generateBtn.classList.add('btn-success');
                generateBtn.disabled = true;
            }
        }

        // Config Page Functions
        function saveSettings() {
            const apiKey = document.getElementById('openaiKey')?.value?.trim();
            const elevenlabsKey = document.getElementById('elevenlabsKey')?.value?.trim();
            const model = document.getElementById('modelSelection')?.value;
            const autoSave = document.getElementById('autoSave')?.checked;
            
            if (apiKey) {
                localStorage.setItem('openaiApiKey', apiKey);
            }
            if (elevenlabsKey) {
                localStorage.setItem('elevenlabsApiKey', elevenlabsKey);
            }
            if (model) {
                localStorage.setItem('selectedModel', model);
            }
            localStorage.setItem('autoSave', autoSave);
            
            showNotification('Settings saved successfully!', 'success');
            
            // Mask the API keys display for security
            const keyInput = document.getElementById('openaiKey');
            if (keyInput && apiKey) {
                keyInput.value = '••••••••••••••••••••••••••••••••••••••••••••••••••••' + apiKey.slice(-4);
            }
            
            const elevenlabsInput = document.getElementById('elevenlabsKey');
            if (elevenlabsInput && elevenlabsKey) {
                elevenlabsInput.value = '••••••••••••••••••••••••••••••••••••••••••••••••••••' + elevenlabsKey.slice(-4);
            }
        }

        function loadSettings() {
            const apiKey = localStorage.getItem('openaiApiKey');
            const elevenlabsKey = localStorage.getItem('elevenlabsApiKey');
            const model = localStorage.getItem('selectedModel');
            const autoSave = localStorage.getItem('autoSave');
            
            if (apiKey) {
                const keyInput = document.getElementById('openaiKey');
                if (keyInput) {
                    keyInput.value = '••••••••••••••••••••••••••••••••••••••••••••••••••••' + apiKey.slice(-4);
                }
            }
            
            if (elevenlabsKey) {
                const elevenlabsInput = document.getElementById('elevenlabsKey');
                if (elevenlabsInput) {
                    elevenlabsInput.value = '••••••••••••••••••••••••••••••••••••••••••••••••••••' + elevenlabsKey.slice(-4);
                }
            }
            
            if (model) {
                const modelSelect = document.getElementById('modelSelection');
                if (modelSelect) {
                    modelSelect.value = model;
                }
            }
            
            if (autoSave !== null) {
                const autoSaveCheckbox = document.getElementById('autoSave');
                if (autoSaveCheckbox) {
                    autoSaveCheckbox.checked = autoSave === 'true';
                }
            }
        }

        async function testApiConnection() {
            const apiKey = getOpenAIApiKey();
            if (!apiKey) {
                showNotification('Please enter your OpenAI API key first', 'error');
                return;
            }

            showNotification('Testing API connection...', 'info');

            try {
                const response = await fetch('https://api.openai.com/v1/models', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    showNotification('✅ API connection successful!', 'success');
                } else {
                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                showNotification(`❌ API connection failed: ${error.message}`, 'error');
            }
        }

        // Text Drag & Drop Functions
        function handleTextDrop(event) {
            event.preventDefault();
            const files = event.dataTransfer.files;
            const text = event.dataTransfer.getData('text/plain');
            
            if (files.length > 0) {
                // Handle file drop
                const file = files[0];
                if (file.type === 'text/plain' || file.name.endsWith('.txt')) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const textArea = document.getElementById('cloneTextInput');
                        if (textArea) {
                            textArea.value = e.target.result;
                            updateCharCount();
                        }
                        showNotification(`Text file "${file.name}" loaded successfully!`, 'success');
                    };
                    reader.readAsText(file);
                } else {
                    showNotification('Please drop a .txt file', 'error');
                }
            } else if (text) {
                // Handle text drop
                const textArea = document.getElementById('cloneTextInput');
                if (textArea) {
                    textArea.value = text;
                    updateCharCount();
                }
                showNotification('Text added successfully!', 'success');
            }
        }

        function updateCharCount() {
            const textArea = document.getElementById('cloneTextInput');
            const charCount = document.getElementById('textCharCount');
            
            if (textArea && charCount) {
                const text = textArea.value;
                charCount.textContent = `${text.length} characters`;
            }
        }

        async function previewCloneText() {
            const text = document.getElementById('cloneTextInput')?.value?.trim();
            if (!text) {
                showNotification('Please enter some text to preview', 'error');
                return;
            }

            const apiKey = getOpenAIApiKey();
            if (!apiKey) {
                showNotification('Please configure your OpenAI API key first', 'error');
                return;
            }

            showNotification('Generating voice preview...', 'info');

            try {
                const voice = document.getElementById('voiceSelection')?.value || 'alloy';
                const speed = parseFloat(document.getElementById('speechRate')?.value || 1.0);
                
                const audioBlob = await generateChapterAudio(text, voice, speed, apiKey);
                const audioUrl = URL.createObjectURL(audioBlob);
                
                // Play the preview
                const audio = new Audio(audioUrl);
                audio.play();
                
                showNotification('Voice preview generated successfully!', 'success');
            } catch (error) {
                showNotification(`Preview failed: ${error.message}`, 'error');
            }
        }

        // Voice Preview Functions
        async function previewSelectedVoice() {
            const voiceSelect = document.getElementById('voiceSelection');
            const selectedOption = voiceSelect.options[voiceSelect.selectedIndex];
            
            if (!selectedOption) {
                showNotification('Please select a voice first', 'error');
                return;
            }

            const provider = selectedOption.dataset.provider;
            const voiceId = selectedOption.dataset.voice;
            const voiceName = selectedOption.textContent;
            
            const previewText = `Hello, this is a preview of the ${voiceName} voice. This voice will be used to narrate your audiobook with professional quality and clarity.`;

            showNotification(`Generating ${voiceName} voice preview...`, 'info');

            try {
                let audioBlob;
                
                if (provider === 'openai') {
                    const apiKey = getOpenAIApiKey();
                    if (!apiKey) {
                        showNotification('Please configure your OpenAI API key first', 'error');
                        return;
                    }
                    audioBlob = await generateChapterAudio(previewText, voiceId, 1.0, apiKey);
                } else if (provider === 'elevenlabs') {
                    const apiKey = getElevenLabsApiKey();
                    if (!apiKey) {
                        showNotification('Please configure your ElevenLabs API key first', 'error');
                        return;
                    }
                    audioBlob = await generateElevenLabsAudio(previewText, voiceId, apiKey);
                } else {
                    showNotification('Unknown voice provider', 'error');
                    return;
                }

                const audioUrl = URL.createObjectURL(audioBlob);
                
                const previewPlayer = document.getElementById('voicePreviewPlayer');
                const audioSource = document.getElementById('voicePreviewSource');
                
                audioSource.src = audioUrl;
                previewPlayer.classList.remove('hidden');
                
                // Auto-play the preview
                const audioElement = previewPlayer.querySelector('audio');
                audioElement.load();
                audioElement.play();
                
                showNotification(`${voiceName} voice preview ready!`, 'success');
            } catch (error) {
                showNotification(`Voice preview failed: ${error.message}`, 'error');
            }
        }

        // Recording Functions
        let mediaRecorder;
        let recordedChunks = [];

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                mediaRecorder = new MediaRecorder(stream);
                recordedChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'audio/wav' });
                    const audioUrl = URL.createObjectURL(blob);
                    
                    const recordedAudio = document.getElementById('recordedAudio');
                    const audioSource = document.getElementById('recordedAudioSource');
                    
                    audioSource.src = audioUrl;
                    recordedAudio.classList.remove('hidden');
                    
                    // Stop all tracks to release the microphone
                    stream.getTracks().forEach(track => track.stop());
                    
                    showNotification('Recording saved successfully!', 'success');
                };

                mediaRecorder.start();
                
                // Update UI
                document.getElementById('recordBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('recordingIndicator').classList.remove('hidden');
                document.getElementById('recordingWave').classList.remove('hidden');
                
                showNotification('Recording started...', 'info');
                
            } catch (error) {
                showNotification(`Recording failed: ${error.message}`, 'error');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                
                // Update UI
                document.getElementById('recordBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('recordingIndicator').classList.add('hidden');
                document.getElementById('recordingWave').classList.add('hidden');
            }
        }

        // Enhanced getOpenAI ApiKey function  
        function getOpenAIApiKey() {
            const storedKey = localStorage.getItem('openaiApiKey');
            if (!storedKey) {
                console.log('❌ No OpenAI API key in localStorage');
                return null;
            }
            if (storedKey.startsWith('••••')) {
                console.log('❌ OpenAI API key is masked - user needs to re-enter it');
                // Don't show notification during generation, just return null
                return null;
            }
            console.log('✅ OpenAI API key retrieved successfully');
            return storedKey;
        }

        // ElevenLabs API key function
        function getElevenLabsApiKey() {
            const storedKey = localStorage.getItem('elevenlabsApiKey');
            if (storedKey && storedKey.startsWith('••••')) {
                // If the key is masked, we need the user to re-enter it
                return null;
            }
            return storedKey;
        }

        // ============ ELEVENLABS API INTEGRATION ============

        async function fetchElevenLabsVoices() {
            const apiKey = getElevenLabsApiKey();
            if (!apiKey) {
                return [];
            }

            try {
                const response = await fetch('https://api.elevenlabs.io/v1/voices', {
                    method: 'GET',
                    headers: {
                        'xi-api-key': apiKey,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    console.error('ElevenLabs API error:', response.status);
                    return [];
                }

                const data = await response.json();
                return data.voices || [];
            } catch (error) {
                console.error('Failed to fetch ElevenLabs voices:', error);
                return [];
            }
        }

        async function generateElevenLabsAudio(text, voiceId, apiKey) {
            const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
                method: 'POST',
                headers: {
                    'xi-api-key': apiKey,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    text: text,
                    model_id: "eleven_monolingual_v1",
                    voice_settings: {
                        stability: 0.5,
                        similarity_boost: 0.75
                    }
                })
            });

            if (!response.ok) {
                throw new Error(`ElevenLabs API Error: ${response.status}`);
            }

            return await response.blob();
        }

        async function populateVoiceOptions() {
            const voiceSelect = document.getElementById('voiceSelection');
            if (!voiceSelect) return;

            // Clear existing options
            voiceSelect.innerHTML = '';

            // Add OpenAI voices
            const openaiVoices = [
                { id: 'openai_alloy', name: 'Alloy - Balanced, Clear', provider: 'openai', voice: 'alloy' },
                { id: 'openai_echo', name: 'Echo - Male, Authoritative', provider: 'openai', voice: 'echo' },
                { id: 'openai_fable', name: 'Fable - Warm, Storytelling', provider: 'openai', voice: 'fable' },
                { id: 'openai_onyx', name: 'Onyx - Deep, Professional', provider: 'openai', voice: 'onyx' },
                { id: 'openai_nova', name: 'Nova - Female, Engaging', provider: 'openai', voice: 'nova' },
                { id: 'openai_shimmer', name: 'Shimmer - Soft, Gentle', provider: 'openai', voice: 'shimmer' }
            ];

            // Add OpenAI section header
            const openaiOptgroup = document.createElement('optgroup');
            openaiOptgroup.label = '🤖 OpenAI Voices';
            voiceSelect.appendChild(openaiOptgroup);

            openaiVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.id;
                option.textContent = voice.name;
                option.dataset.provider = voice.provider;
                option.dataset.voice = voice.voice;
                openaiOptgroup.appendChild(option);
            });

            // Add ElevenLabs voices if API key is available
            const elevenlabsVoices = await fetchElevenLabsVoices();
            if (elevenlabsVoices.length > 0) {
                const elevenlabsOptgroup = document.createElement('optgroup');
                elevenlabsOptgroup.label = '🎭 ElevenLabs Voices';
                voiceSelect.appendChild(elevenlabsOptgroup);

                elevenlabsVoices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = `elevenlabs_${voice.voice_id}`;
                    option.textContent = `${voice.name} - ${voice.labels?.accent || 'Professional'}`;
                    option.dataset.provider = 'elevenlabs';
                    option.dataset.voice = voice.voice_id;
                    elevenlabsOptgroup.appendChild(option);
                });
            }

            // Select first OpenAI voice by default
            if (voiceSelect.options.length > 0) {
                voiceSelect.selectedIndex = 0;
            }
        }

        // ============ DIALOGUE-SPECIFIC VOICE ASSIGNMENT ============

        let dialogueData = {
            characters: [],
            dialogueSections: [],
            voiceAssignments: {}
        };

        // Content status functions
        function refreshContentStatus() {
            updateContentStatus();
        }
        
        function updateContentStatus() {
            const statusIcon = document.getElementById('contentStatusIcon');
            const statusText = document.getElementById('contentStatusText');
            const previewToggle = document.getElementById('contentPreviewToggle');
            
            // Get content from all chapters using the same function as dialogue scanning
            const content = getAllChaptersText();
            const chapterCount = storyData.chapters ? storyData.chapters.length : 0;
            const contentSource = chapterCount > 1 ? `${chapterCount} Chapters` : 
                                 chapterCount === 1 ? '1 Chapter' : 
                                 'Story Editor';
            
            if (!content.trim()) {
                statusIcon.className = 'w-3 h-3 rounded-full bg-red-400';
                statusText.textContent = 'No story content found. Please create or combine chapters first.';
                previewToggle.classList.add('hidden');
                return;
            }
            
            const wordCount = content.trim().split(/\s+/).length;
            const charCount = content.length;
            // Enhanced dialogue detection (same patterns as scanForDialogue)
            const hasDialogue = content.includes('"') || content.includes('"') || content.includes('"') ||
                               content.match(/^[A-Z][a-zA-Z\s]+?:\s*["""]/m) ||
                               /\b(said|asked|replied|whispered|shouted|muttered|exclaimed)\b.*?["""]/i.test(content) ||
                               /["""']([^"""']{3,})["""']/g.test(content);
            
            statusIcon.className = 'w-3 h-3 rounded-full bg-green-400';
            statusText.innerHTML = `
                <div><strong>Source:</strong> ${contentSource}</div>
                <div><strong>Length:</strong> ${wordCount} words, ${charCount} characters</div>
                <div><strong>Dialogue:</strong> ${hasDialogue ? '✅ Detected' : '❌ None found'}</div>
            `;
            previewToggle.classList.remove('hidden');
            
            // Store the FULL content for dialogue scanning and narration (never truncated)
            const previousContent = storyData.currentContent;
            storyData.currentContent = content;
            
            console.log('💾 STORING FULL CONTENT:');
            console.log('- Previous content length:', (previousContent || '').length);
            console.log('- New full content length:', content.length);
            console.log('- Content stored in storyData.currentContent');
            
            // Also update combined content if we have chapters
            if (storyData.chapters && storyData.chapters.length > 0) {
                storyData.combinedContent = content;
            }
            
            // Clear dialogue data if content has changed to prevent stale results
            if (previousContent && previousContent !== content) {
                console.log('Content changed - clearing cached dialogue data');
                dialogueData.characters = [];
                dialogueData.dialogueSections = [];
                dialogueData.voiceAssignments = {};
                
                // Hide dialogue sections since they're now stale
                const dialogueAssignments = document.getElementById('dialogueAssignments');
                const dialoguePreview = document.getElementById('dialoguePreview');
                if (dialogueAssignments) dialogueAssignments.classList.add('hidden');
                if (dialoguePreview) dialoguePreview.classList.add('hidden');
            }
        }
        
        function toggleContentPreview() {
            const preview = document.getElementById('contentPreview');
            const previewText = document.getElementById('contentPreviewText');
            
            if (preview.classList.contains('hidden')) {
                const content = storyData.currentContent || '';
                if (content) {
                    // Show first 1000 characters
                    const truncated = content.length > 1000 ? content.substring(0, 1000) + '\n\n... [Content truncated. Full content will be used for dialogue scanning.]' : content;
                    previewText.textContent = truncated;
                    preview.classList.remove('hidden');
                }
            } else {
                preview.classList.add('hidden');
            }
        }
        
        function clearPreviewContent() {
            // Clear preview content display
            const preview = document.getElementById('contentPreview');
            const previewText = document.getElementById('contentPreviewText');
            
            preview.classList.add('hidden');
            previewText.textContent = '';
            
            // FORCE CLEAR ALL dialogue data completely
            dialogueData.characters = [];
            dialogueData.dialogueSections = [];
            dialogueData.voiceAssignments = {};
            
            // Hide AND completely clear dialogue assignment sections
            const dialogueAssignments = document.getElementById('dialogueAssignments');
            const dialoguePreview = document.getElementById('dialoguePreview');
            const characterVoiceList = document.getElementById('characterVoiceList');
            const dialogueList = document.getElementById('dialogueList');
            
            if (dialogueAssignments) dialogueAssignments.classList.add('hidden');
            if (dialoguePreview) dialoguePreview.classList.add('hidden');
            if (characterVoiceList) characterVoiceList.innerHTML = '';
            if (dialogueList) dialogueList.innerHTML = '';
            
            // Clear ALL content caches to force refresh from chapters
            storyData.currentContent = null;
            storyData.combinedContent = null;
            
            // Update status to reflect cleared state
            updateStoryStatus();
            
            showNotification('All content and dialogue data cleared. Click "Scan Story for Dialogue" for fresh scan.', 'info');
            console.log('=== COMPLETE CLEAR ===');
            console.log('All preview content and dialogue data forcibly cleared');
        }

        // Update story generation status indicators
        function updateStoryStatus() {
            const hasTitle = storyData.title && storyData.title.length > 0;
            const hasChapters = storyData.chapters && storyData.chapters.length > 0;
            const hasContent = storyData.combinedContent && storyData.combinedContent.length > 0;
            
            // Update status indicators
            const titleStatus = document.getElementById('titleStatus');
            const chaptersStatus = document.getElementById('chaptersStatus');
            const contentStatus = document.getElementById('contentStatus');
            
            if (titleStatus) {
                titleStatus.className = hasTitle ? 'text-green-400' : 'text-gray-400';
                titleStatus.textContent = hasTitle ? '✓' : '○';
            }
            
            if (chaptersStatus) {
                chaptersStatus.className = hasChapters ? 'text-green-400' : 'text-gray-400';
                chaptersStatus.textContent = hasChapters ? '✓' : '○';
            }
            
            if (contentStatus) {
                contentStatus.className = hasContent ? 'text-green-400' : 'text-gray-400';
                contentStatus.textContent = hasContent ? '✓' : '○';
            }
            
            // Update button states
            const scanBtn = document.getElementById('scanDialogueBtn');
            const generateNarrationBtn = document.getElementById('generateNarrationBtn');
            
            if (scanBtn) {
                scanBtn.disabled = !hasContent;
                if (hasContent) {
                    scanBtn.classList.remove('opacity-50');
                } else {
                    scanBtn.classList.add('opacity-50');
                }
            }
            
            if (generateNarrationBtn) {
                generateNarrationBtn.disabled = !hasContent;
                if (hasContent) {
                    generateNarrationBtn.classList.remove('opacity-50');
                } else {
                    generateNarrationBtn.classList.add('opacity-50');
                }
            }
        }

        // Helper function to validate character names
        function isValidCharacterName(name) {
            if (!name || typeof name !== 'string') return false;
            
            const cleaned = name.trim();
            console.log(`🔍 Validating character name: "${cleaned}"`);
            
            // Reject if empty or too short/long
            if (cleaned.length < 2 || cleaned.length > 25) {
                console.log(`❌ Invalid length: ${cleaned.length} chars`);
                return false;
            }
            
            // Must start with capital letter and contain only letters/spaces/hyphens/apostrophes
            if (!/^[A-Z][a-zA-Z\s\-']*$/.test(cleaned)) {
                console.log(`❌ Invalid format: "${cleaned}"`);
                return false;
            }
            
            // Check each word individually
            const words = cleaned.split(/\s+/);
            for (const word of words) {
                if (word.length < 1) continue;
                
                // Each word should start with capital
                if (!/^[A-Z]/.test(word)) {
                    console.log(`❌ Word doesn't start with capital: "${word}"`);
                    return false;
                }
                
                // Reject obvious dialogue words
                const invalidWords = [
                    'What', 'How', 'Why', 'When', 'Where', 'Who',
                    'Come', 'Well', 'Sure', 'Only', 'The', 'And', 'But', 'Then', 'There', 'This', 'That',
                    'Chapter', 'Said', 'Asked', 'Replied', 'Whispered', 'Shouted', 'Called',
                    'He', 'She', 'They', 'It', 'His', 'Her', 'Their', 'Its',
                    'Kind', 'All', 'Whatever', 'Was', 'Were', 'Been', 'Being'
                ];
                
                if (invalidWords.includes(word)) {
                    console.log(`❌ Contains invalid word: "${word}"`);
                    return false;
                }
            }
            
            // Enhanced dialogue pattern rejection
            const dialogueIndicators = [
                'what kind of', 'come on', 'what\'s all', 'well whatever', 'well then',
                'who was', 'the kind that', 'sure it is', 'only tom\'s', 'only he',
                'he said', 'she said', 'asked jake', 'replied with', 'whispered to',
                'but then', 'and then', 'this is', 'that was', 'there is', 'there was',
                'how do', 'why did', 'when will', 'where are', 'who is'
            ];
            
            const lowerName = cleaned.toLowerCase();
            for (const indicator of dialogueIndicators) {
                if (lowerName.includes(indicator)) {
                    console.log(`❌ Contains dialogue indicator: "${indicator}"`);
                    return false;
                }
            }
            
            // Reject if contains punctuation that indicates dialogue/narrative
            if (/[.!?,;:'"\"]+/.test(cleaned)) {
                console.log(`❌ Contains dialogue punctuation`);
                return false;
            }
            
            // Reject sentence starters and questions
            const sentenceStarters = [
                /^what\s/i, /^how\s/i, /^why\s/i, /^when\s/i, /^where\s/i, /^who\s/i,
                /^the\s/i, /^and\s/i, /^but\s/i, /^then\s/i, /^there\s/i, /^this\s/i, /^that\s/i
            ];
            
            for (const starter of sentenceStarters) {
                if (starter.test(cleaned)) {
                    console.log(`❌ Starts like sentence: "${cleaned}"`);
                    return false;
                }
            }
            
            console.log(`✅ Valid character name: "${cleaned}"`);
            return true;
        }

        // Helper function to check if text looks like narrative
        function isNarrativeText(character) {
            const lower = character.toLowerCase();
            const narrativeWords = ['he', 'she', 'they', 'it', 'the', 'and', 'but', 'then', 'said', 'asked', 'chapter'];
            return narrativeWords.some(word => lower.includes(word)) || 
                   character.length < 2 || 
                   character.length > 25 ||
                   !/^[A-Z][a-zA-Z\s]*$/.test(character);
        }
        
        // Helper function to completely clear all dialogue data and UI
        function clearAllDialogueData(force = false) {
            console.log('🧹 CLEARING ALL DIALOGUE DATA' + (force ? ' (FORCED)' : ''));
            
            // Clear data objects
            dialogueData.characters = [];
            dialogueData.dialogueSections = [];
            dialogueData.voiceAssignments = {};
            
            // Clear UI elements
            const dialogueAssignments = document.getElementById('dialogueAssignments');
            const dialoguePreview = document.getElementById('dialoguePreview');
            const characterVoiceList = document.getElementById('characterVoiceList');
            const dialogueList = document.getElementById('dialogueList');
            const multiVoiceResults = document.getElementById('multiVoiceResults');
            
            [dialogueAssignments, dialoguePreview].forEach(element => {
                if (element) {
                    element.classList.add('hidden');
                    element.style.display = 'none';
                }
            });
            
            [characterVoiceList, dialogueList, multiVoiceResults].forEach(element => {
                if (element) {
                    element.innerHTML = '';
                    element.textContent = '';
                    while (element.firstChild) {
                        element.removeChild(element.firstChild);
                    }
                }
            });
            
            // Remove any voice selection dropdowns
            const voiceSelects = document.querySelectorAll('select[id^="voice-"]');
            voiceSelects.forEach(select => select.remove());
            
            // Remove any dialogue audio elements
            const audioElements = document.querySelectorAll('audio[data-dialogue]');
            audioElements.forEach(audio => audio.remove());
            
            console.log('✅ ALL DIALOGUE DATA CLEARED');
        }

        // Helper function to check if quoted text is actual dialogue vs narrative description
        function isActualDialogue(text) {
            const lower = text.toLowerCase();
            
            // Narrative indicators (NOT dialogue)
            const narrativeIndicators = [
                'laughter filled', 'they had spent', 'hours talking', 'the space around',
                'he walked', 'she moved', 'they went', 'it was', 'there was', 'there were',
                'the room', 'the house', 'the street', 'the door', 'the window',
                'morning came', 'evening fell', 'night approached', 'sun rose', 'sun set',
                'time passed', 'minutes later', 'hours passed', 'days went by',
                'meanwhile', 'suddenly', 'eventually', 'finally', 'afterwards'
            ];
            
            // Check for narrative patterns
            if (narrativeIndicators.some(indicator => lower.includes(indicator))) {
                return false;
            }
            
            // Very long descriptions are usually narrative
            if (text.length > 200) {
                return false;
            }
            
            // Third person pronouns at start usually indicate narrative
            if (/^(he|she|they|it|the)\s/i.test(text)) {
                return false;
            }
            
            // Dialogue indicators (likely to be spoken)
            const dialogueIndicators = [
                /^(yes|no|okay|ok|sure|maybe|perhaps|well|oh|ah|um|hmm)/i,
                /^(hello|hi|hey|goodbye|bye|thanks|please|sorry)/i,
                /^(what|where|when|why|how|who)/i,
                /\?$/, // Questions
                /!$/, // Exclamations
                /^(i|you|we|my|your|our)/i, // First/second person
                /^(let's|don't|can't|won't|shouldn't)/i // Contractions
            ];
            
            // Check for dialogue patterns
            if (dialogueIndicators.some(pattern => 
                typeof pattern === 'string' ? lower.includes(pattern) : pattern.test(text)
            )) {
                return true;
            }
            
            // Short text without narrative indicators is likely dialogue
            return text.length < 100;
        }

        async function scanToNarration() {
            console.log('🎙️ Starting narration scan...');
            
            // Get full story content
            let content = getFullStoryContent();
            if (!content || content.trim().length === 0) {
                console.log('❌ No content to scan for narration');
                showNotification('No story content available for narration.', 'error');
                return;
            }
            
            console.log(`📝 Content validation: ${content.length} characters available`);
            console.log('📖 Content preview:', content.substring(0, 200) + '...');
            
            const chapterInfo = hasMultipleChapters() ? 
                `Preparing ${storyData.chapters.length} chapters for narration...` :
                'Preparing story for narration...';
            
            showLoading(chapterInfo);
            
            try {
                // Store the full content for narration
                storyData.currentContent = content;
                
                // Calculate story statistics
                const wordCount = content.split(/\s+/).length;
                const charCount = content.length;
                const estimatedDuration = Math.round(wordCount / 2.5); // ~2.5 words per second average speaking rate
                
                console.log('📊 Story statistics:');
                console.log(`- Word count: ${wordCount}`);
                console.log(`- Character count: ${charCount}`);
                console.log(`- Estimated duration: ${Math.floor(estimatedDuration / 60)}:${(estimatedDuration % 60).toString().padStart(2, '0')} minutes`);
                
                hideLoading();
                
                // Display narration preview
                displayNarrationPreview(content, { wordCount, charCount, estimatedDuration });
                showNotification(`✅ Story prepared for narration! ${wordCount.toLocaleString()} words ready for narrator.`, 'success');
            } catch (error) {
                console.error('❌ Narration scan error:', error);
                hideLoading();
                showNotification(`Failed to prepare narration: ${error.message}`, 'error');
            }
        }
        
        // Helper function to extract character from context for standalone dialogue
        function extractCharacterFromContext(match, content, lines) {
            const matchPosition = match.index;
            const matchText = match[0];
            
            // Find the line containing this match
            let currentPos = 0;
            for (let i = 0; i < lines.length; i++) {
                const lineLength = lines[i].length + 1; // +1 for newline
                if (currentPos + lineLength > matchPosition) {
                    // Found the line, now look for character names in surrounding lines
                    const contextRange = 3; // Look 3 lines before and after
                    const startLine = Math.max(0, i - contextRange);
                    const endLine = Math.min(lines.length - 1, i + contextRange);
                    
                    for (let j = startLine; j <= endLine; j++) {
                        const contextLine = lines[j];
                        
                        // Look for character indicators in nearby lines
                        const characterPatterns = [
                            /([A-Z][a-zA-Z\s\-']{1,24})\s+(?:said|asked|replied|whispered|shouted|walked|looked|turned|smiled|laughed|nodded|stood|sat)/i,
                            /^([A-Z][a-zA-Z\s\-']{1,24})\s*:/,
                            /([A-Z][a-zA-Z\s\-']{1,24})\s+(?:was|were|had|could|would|might)/i
                        ];
                        
                        for (const pattern of characterPatterns) {
                            const contextMatch = contextLine.match(pattern);
                            if (contextMatch && isValidCharacterName(contextMatch[1])) {
                                console.log(`🔍 Found context character: "${contextMatch[1]}" near dialogue`);
                                return contextMatch[1].trim();
                            }
                        }
                    }
                    break;
                }
                currentPos += lineLength;
            }
            
            return 'Unknown Speaker';
        }
        
        // Helper function to clean dialogue text
        function cleanDialogueText(dialogue) {
            if (!dialogue) return '';
            
            return dialogue
                .trim()
                .replace(/^["""]|["""]$/g, '') // Remove surrounding quotes
                .replace(/\s+/g, ' ') // Normalize whitespace
                .trim();
        }
        
        // Helper function to calculate confidence score
        function calculateConfidence(character, dialogue, patternIndex) {
            let confidence = 0.5; // Base confidence
            
            // Pattern-based confidence
            switch (patternIndex) {
                case 0: // Character said pattern
                case 1: // Said character pattern  
                    confidence = 0.9;
                    break;
                case 2: // Colon pattern
                    confidence = 0.8;
                    break;
                case 3: // Context-based
                    confidence = 0.6;
                    break;
                case 4: // Action tag pattern
                    confidence = 0.7;
                    break;
            }
            
            // Character name quality
            if (character && character !== 'Unknown Speaker') {
                if (character.length >= 2 && character.length <= 15) {
                    confidence += 0.1;
                }
                if (/^[A-Z][a-z]+$/.test(character)) {
                    confidence += 0.1; // Simple names are more reliable
                }
            }
            
            // Dialogue quality
            if (dialogue) {
                if (dialogue.length >= 10 && dialogue.length <= 100) {
                    confidence += 0.1; // Reasonable length dialogue
                }
                if (/[!?]/.test(dialogue)) {
                    confidence += 0.05; // Questions and exclamations are likely dialogue
                }
            }
            
            return Math.min(1.0, confidence);
        }
        
        function showDialogueDebugModal(content, lines) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-theme-secondary rounded-xl max-w-4xl max-h-[80vh] w-full flex flex-col border-2 border-theme">
                    <div class="flex items-center justify-between p-6 border-b border-theme">
                        <h3 class="text-xl font-bold text-yellow-400">
                            <i class="fas fa-bug mr-2"></i>Dialogue Scanning Debug
                        </h3>
                        <button onclick="this.closest('.fixed').remove()" class="text-theme-secondary hover:text-theme-primary">
                            <i class="fas fa-times text-xl"></i>
                        </button>
                    </div>
                    <div class="flex-1 p-6 overflow-y-auto">
                        <div class="space-y-4">
                            <div class="bg-theme-primary p-4 rounded-lg border border-theme">
                                <h4 class="font-medium text-cyan-400 mb-2">Content Statistics:</h4>
                                <div class="text-sm text-theme-secondary space-y-1">
                                    <div>Total length: ${content.length} characters</div>
                                    <div>Total lines: ${lines.length}</div>
                                    <div>Contains quotes (""): ${content.includes('"') ? 'Yes' : 'No'}</div>
                                    <div>Contains smart quotes (""): ${content.includes('"') || content.includes('"') ? 'Yes' : 'No'}</div>
                                    <div>Contains colons (:): ${content.includes(':') ? 'Yes' : 'No'}</div>
                                </div>
                            </div>
                            <div class="bg-theme-primary p-4 rounded-lg border border-theme">
                                <h4 class="font-medium text-cyan-400 mb-2">Content Preview (First 10 lines):</h4>
                                <pre class="text-xs text-theme-secondary whitespace-pre-wrap bg-theme-secondary p-2 rounded">${lines.slice(0, 10).join('\n')}</pre>
                            </div>
                        </div>
                    </div>
                    <div class="p-6 border-t border-theme">
                        <div class="text-sm text-theme-secondary mb-3">
                            <strong>Expected dialogue formats:</strong><br>
                            • Character: "Hello there!"<br>
                            • [John]: "How are you?"<br>
                            • MARY: "I'm fine, thanks!"<br>
                            • "Standalone dialogue"
                        </div>
                        <button onclick="this.closest('.fixed').remove()" class="btn-primary px-6 py-2 rounded-lg w-full">
                            Close Debug Info
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        async function detectCharacters(content) {
            try {
                const analysis = await callOpenAI([
                    {
                        role: "system",
                        content: "You are a character extraction specialist. Analyze this story text and identify ALL named characters. Find: 1) Anyone who speaks dialogue, 2) Named people mentioned by name, 3) Characters referenced by proper names. CRITICAL RULES: - Return ONLY real character names (Emily, Alex, Sarah, John, etc.) - NEVER use generic names like 'Character 1', 'Character 2', 'Speaker A' - If you find no real names, return empty array [] - Return ONLY a JSON array like [\"Emily\", \"Alex\", \"Dr. Smith\"] - No markdown, no extra text, just the JSON array"
                    },
                    {
                        role: "user",
                        content: `Analyze this text and identify all character names:\n\n${content.substring(0, 2000)}`
                    }
                ]);

                // Clean the response - remove markdown code blocks and extra formatting
                let cleanedResponse = analysis.trim();
                
                // Remove markdown code blocks (```json ... ```)
                cleanedResponse = cleanedResponse.replace(/```json\s*/g, '');
                cleanedResponse = cleanedResponse.replace(/```\s*/g, '');
                
                // Remove any leading/trailing non-JSON text
                const jsonMatch = cleanedResponse.match(/\[.*\]/s);
                if (jsonMatch) {
                    cleanedResponse = jsonMatch[0];
                }
                
                console.log('Raw AI response:', analysis);
                console.log('Cleaned for JSON parsing:', cleanedResponse);
                
                const characters = JSON.parse(cleanedResponse);
                return Array.isArray(characters) ? characters : [];
            } catch (error) {
                console.error('Character detection error:', error);
                console.error('Failed to parse AI response as JSON. Raw response was:', analysis);
                
                // Try to extract character names manually as fallback
                try {
                    // Look for proper names in the content (capitalized words that could be names)
                    const namePattern = /\b([A-Z][a-z]{2,15})\b/g;
                    const potentialNames = [...content.matchAll(namePattern)].map(match => match[1]);
                    
                    // Filter out common words that aren't names
                    const commonWords = ['The', 'And', 'But', 'When', 'Where', 'What', 'Who', 'How', 'Why', 'This', 'That', 'Then', 'They', 'There', 'She', 'Her', 'His', 'Him', 'Chapter', 'Story', 'Once', 'Upon', 'After', 'Before', 'During', 'While'];
                    const likelyNames = potentialNames.filter(name => 
                        !commonWords.includes(name) && 
                        name.length >= 3 && 
                        name.length <= 15
                    );
                    
                    // Remove duplicates and take top candidates
                    const uniqueNames = [...new Set(likelyNames)].slice(0, 5);
                    console.log('Extracted potential character names:', uniqueNames);
                    
                    if (uniqueNames.length > 0) {
                        return uniqueNames;
                    }
                    
                    // If still no names found, try to parse JSON-like strings from AI response
                    const matches = analysis.match(/"([^"]+)"/g);
                    if (matches) {
                        const extractedChars = matches.map(match => match.replace(/"/g, ''))
                            .filter(char => !char.toLowerCase().includes('character') && !char.toLowerCase().includes('speaker'));
                        console.log('Extracted characters manually (filtered):', extractedChars);
                        return extractedChars.length > 0 ? extractedChars : [];
                    }
                } catch (extractError) {
                    console.error('Manual extraction also failed:', extractError);
                }
                
                // Return empty array instead of generic names - let dialogue patterns extract speakers
                return [];
            }
        }

        function displayDialogueResults() {
            console.log('🎭 DISPLAYING DIALOGUE RESULTS - Narrator-only mode');
            console.log('📊 Data to display:', {
                characters: dialogueData.characters.length,
                dialogueSections: dialogueData.dialogueSections.length,
                characterList: dialogueData.characters
            });
            
            const dialoguePreview = document.getElementById('dialoguePreview');
            const dialogueList = document.getElementById('dialogueList');

            // Clear dialogue list
            if (dialogueList) {
                dialogueList.innerHTML = '';
                while (dialogueList.firstChild) {
                    dialogueList.removeChild(dialogueList.firstChild);
                }
            }
            
            console.log('✅ UI CLEARED - Ready for dialogue preview');

            // Show dialogue preview only (no character voice assignments)
            if (dialoguePreview) {
                dialoguePreview.classList.remove('hidden');
                dialoguePreview.style.display = '';
            }

            console.log('📝 Character voice assignments REMOVED - all dialogue uses narrator voice');
            console.log(`🎭 Characters detected (for reference): ${dialogueData.characters.join(', ')}`);
            
            // AUTO-ASSIGN all characters to narrator voice (no UI needed)
            dialogueData.voiceAssignments = {};
            dialogueData.characters.forEach(character => {
                dialogueData.voiceAssignments[character] = 'narrator'; // Will be replaced with actual narrator voice
            });
            dialogueData.voiceAssignments['Narrator'] = 'narrator'; // Will be replaced with actual narrator voice
            
            console.log('✅ All characters auto-assigned to narrator voice');
            
            // Populate dialogue preview (information only)
            dialogueData.dialogueSections.slice(0, 10).forEach((dialogue, index) => {
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'p-2 bg-theme-secondary rounded text-sm border-l-4 border-green-500';
                
                // Create character header
                const characterHeader = document.createElement('div');
                characterHeader.className = 'font-medium text-green-400';
                characterHeader.textContent = `${dialogue.character || 'Unknown Speaker'} → Narrator Voice`;
                
                // Create dialogue text
                const dialogueText = document.createElement('div');
                dialogueText.className = 'text-theme-primary mt-1';
                dialogueText.textContent = `"${dialogue.text || 'No text'}"`;
                
                dialogueDiv.appendChild(characterHeader);
                dialogueDiv.appendChild(dialogueText);
                dialogueList.appendChild(dialogueDiv);
            });

            if (dialogueData.dialogueSections.length > 10) {
                const moreDiv = document.createElement('div');
                moreDiv.className = 'text-center text-sm text-theme-secondary';
                moreDiv.textContent = `... and ${dialogueData.dialogueSections.length - 10} more dialogue sections (all using narrator voice)`;
                dialogueList.appendChild(moreDiv);
            }

            // Enable multi-voice button (now narrator-only)
            const multiVoiceBtn = document.getElementById('multiVoiceBtn');
            if (multiVoiceBtn) {
                multiVoiceBtn.disabled = false;
                multiVoiceBtn.textContent = 'Generate Narration (Narrator Voice Only)';
            }
        }

        function displayNarrationPreview(content, stats) {
            console.log('🎙️ Displaying narration preview');
            
            const narrationPreview = document.getElementById('narrationPreview');
            const storyContentPreview = document.getElementById('storyContentPreview');
            const fullStoryStats = document.getElementById('fullStoryStats');
            const narratorVoiceSelect = document.getElementById('narratorVoiceSelect');
            
            if (!narrationPreview || !storyContentPreview || !fullStoryStats || !narratorVoiceSelect) {
                console.error('❌ Narration preview elements not found');
                return;
            }
            
            // Populate narrator voice options from main voice selector
            populateNarratorVoices();
            
            // Show story content preview (first 500 characters)
            const preview = content.length > 500 ? content.substring(0, 500) + '...' : content;
            storyContentPreview.textContent = preview;
            
            // Show story statistics
            const { wordCount, charCount, estimatedDuration } = stats;
            fullStoryStats.innerHTML = `
                <strong>Full Story:</strong> ${wordCount.toLocaleString()} words • ${charCount.toLocaleString()} characters • 
                ~${Math.floor(estimatedDuration / 60)}:${(estimatedDuration % 60).toString().padStart(2, '0')} minutes estimated
            `;
            
            // Show the narration preview section
            narrationPreview.classList.remove('hidden');
            
            // Enable the generate narration button
            const generateNarrationBtn = document.getElementById('generateNarrationBtn');
            if (generateNarrationBtn) {
                generateNarrationBtn.disabled = false;
            }
            
            console.log('✅ Narration preview displayed successfully');
        }
        
        function populateNarratorVoices() {
            const narratorVoiceSelect = document.getElementById('narratorVoiceSelect');
            const mainVoiceSelect = document.getElementById('voiceSelection');
            
            if (!narratorVoiceSelect || !mainVoiceSelect) return;
            
            // Clear existing options except the first one
            narratorVoiceSelect.innerHTML = '<option value="">Select narrator voice...</option>';
            
            // Copy options from main voice selector
            Array.from(mainVoiceSelect.children).forEach(child => {
                if (child.tagName === 'OPTGROUP') {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = child.label;
                    Array.from(child.children).forEach(option => {
                        const newOption = document.createElement('option');
                        newOption.value = option.value;
                        newOption.textContent = option.textContent;
                        newOption.dataset.provider = option.dataset.provider;
                        newOption.dataset.voice = option.dataset.voice;
                        optgroup.appendChild(newOption);
                    });
                    narratorVoiceSelect.appendChild(optgroup);
                } else if (child.tagName === 'OPTION' && child.value) {
                    const newOption = document.createElement('option');
                    newOption.value = child.value;
                    newOption.textContent = child.textContent;
                    newOption.dataset.provider = child.dataset.provider;
                    newOption.dataset.voice = child.dataset.voice;
                    narratorVoiceSelect.appendChild(newOption);
                }
            });
            
            // Enable preview button when voice is selected
            narratorVoiceSelect.addEventListener('change', function() {
                const previewBtn = document.getElementById('narratorPreviewBtn');
                if (previewBtn) {
                    previewBtn.disabled = !this.value;
                }
            });
        }
        
        function previewNarratorVoice() {
            const narratorVoiceSelect = document.getElementById('narratorVoiceSelect');
            const selectedVoice = narratorVoiceSelect.value;
            
            if (!selectedVoice) {
                showNotification('Please select a narrator voice first.', 'warning');
                return;
            }
            
            // Get a sample of the story text (first few sentences)
            const content = getFullStoryContent();
            if (!content) {
                showNotification('No story content available for preview.', 'error');
                return;
            }
            
            // Extract first 200 characters for preview
            let sampleText = content.substring(0, 200).trim();
            
            // Try to end at a sentence boundary
            const lastPeriod = sampleText.lastIndexOf('.');
            const lastExclamation = sampleText.lastIndexOf('!');
            const lastQuestion = sampleText.lastIndexOf('?');
            const lastSentenceEnd = Math.max(lastPeriod, lastExclamation, lastQuestion);
            
            if (lastSentenceEnd > 100) {
                sampleText = sampleText.substring(0, lastSentenceEnd + 1);
            } else {
                sampleText += '...';
            }
            
            console.log('🎙️ Previewing narrator voice:', selectedVoice);
            console.log('📝 Sample text:', sampleText.substring(0, 100) + '...');
            
            // Show loading state
            const previewBtn = document.getElementById('narratorPreviewBtn');
            const originalText = previewBtn.innerHTML;
            previewBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>Generating...';
            previewBtn.disabled = true;
            
            // Generate preview audio
            generatePreviewAudio(sampleText, selectedVoice)
                .then(audioBlob => {
                    if (audioBlob) {
                        playPreviewAudio(audioBlob);
                        showNotification('🎙️ Narrator voice preview generated!', 'success');
                    } else {
                        throw new Error('Failed to generate preview audio');
                    }
                })
                .catch(error => {
                    console.error('❌ Preview generation failed:', error);
                    showNotification(`Preview failed: ${error.message}`, 'error');
                })
                .finally(() => {
                    previewBtn.innerHTML = originalText;
                    previewBtn.disabled = false;
                });
        }
        
        async function generatePreviewAudio(text, voice) {
            try {
                const voiceInfo = voice.split('_');
                const provider = voiceInfo[0];
                const voiceId = voiceInfo[1];
                
                if (provider === 'openai') {
                    return await generateOpenAIAudio(text, voiceId);
                } else if (provider === 'elevenlabs') {
                    const apiKey = getElevenLabsApiKey();
                    if (!apiKey) {
                        throw new Error('ElevenLabs API key not configured');
                    }
                    return await generateElevenLabsAudio(text, voiceId, apiKey);
                } else {
                    throw new Error(`Unknown voice provider: ${provider}`);
                }
            } catch (error) {
                console.error('❌ Preview audio generation failed:', error);
                throw error;
            }
        }
        
        function playPreviewAudio(audioBlob) {
            // Remove any existing preview audio
            const existingPreview = document.getElementById('narratorVoicePreview');
            if (existingPreview) {
                existingPreview.remove();
            }
            
            // Create new audio element
            const audioUrl = URL.createObjectURL(audioBlob);
            const audioElement = document.createElement('audio');
            audioElement.id = 'narratorVoicePreview';
            audioElement.controls = true;
            audioElement.autoplay = true;
            audioElement.className = 'w-full mt-2';
            audioElement.src = audioUrl;
            
            // Add to narrator preview section
            const narratorPreviewBtn = document.getElementById('narratorPreviewBtn');
            if (narratorPreviewBtn && narratorPreviewBtn.parentNode) {
                narratorPreviewBtn.parentNode.appendChild(audioElement);
            }
            
            // Clean up URL after playing
            audioElement.addEventListener('ended', () => {
                setTimeout(() => {
                    URL.revokeObjectURL(audioUrl);
                }, 1000);
            });
        }

        /* REMOVED: Character voice assignment UI code - now using narrator-only mode */

        async function generateNarration() {
            console.log('🎙️ === NARRATION GENERATION START ===');
            
            // Get narrator voice from narrator voice selection (preferred) or main voice selection (fallback)
            const narratorVoiceSelect = document.getElementById('narratorVoiceSelect');
            const mainVoiceSelect = document.getElementById('voiceSelection');
            const narratorVoice = narratorVoiceSelect?.value || mainVoiceSelect?.value;
            
            console.log('Narrator voice selected:', narratorVoice);
            
            if (!narratorVoice) {
                console.log('❌ No narrator voice selected');
                showNotification('Please select a narrator voice from the main voice selection dropdown first.', 'error');
                return;
            }
            
            console.log('✅ Using narrator voice for ALL content (dialogue and narrative)');
            
            // Check if API key is available
            const apiKey = getOpenAIApiKey();
            if (!apiKey) {
                console.log('❌ No OpenAI API key found');
                showNotification('Please configure your OpenAI API key in Settings first.', 'error');
                return;
            }
            console.log('✅ OpenAI API key found');
            
            showLoading('Generating narration (narrator voice only)...');
            
            try {
                // ENSURE FULL CONTENT - use the dedicated function that guarantees full content
                let content = getFullStoryContent();
                
                if (!content.trim()) {
                    throw new Error('No story content to narrate');
                }
                
                console.log('🎙️ NARRATOR-ONLY GENERATION - Using FULL content:', content.length, 'characters');

                // Check if content needs chunking (OpenAI TTS limit is 4096 characters)
                const MAX_TTS_CHARS = 4000; // Leave some buffer
                let audioBlobs = [];
                
                if (content.length <= MAX_TTS_CHARS) {
                    // Single chunk - process normally
                    console.log('📝 Content fits in single chunk, processing normally');
                    
                    try {
                        const audioBlob = await generateSegmentAudio({
                            type: 'all_content',
                            text: content,
                            voice: narratorVoice,
                            character: 'Narrator'
                        });
                        
                        if (audioBlob) {
                            audioBlobs.push({
                                blob: audioBlob,
                                segment: {
                                    type: 'all_content',
                                    text: content,
                                    voice: narratorVoice,
                                    character: 'Narrator'
                                }
                            });
                        }
                    } catch (audioError) {
                        throw new Error(`Single chunk generation failed: ${audioError.message}`);
                    }
                } else {
                    // Multiple chunks needed
                    console.log('📚 Content too long, splitting into chunks...');
                    const textChunks = splitTextIntoChunks(content, MAX_TTS_CHARS);
                    console.log(`📝 Split into ${textChunks.length} chunks`);
                    
                    // Process each chunk
                    for (let i = 0; i < textChunks.length; i++) {
                        const chunk = textChunks[i];
                        console.log(`🎙️ Processing chunk ${i + 1}/${textChunks.length} (${chunk.length} characters)`);
                        
                        try {
                            const audioBlob = await generateSegmentAudio({
                                type: 'chunk',
                                text: chunk,
                                voice: narratorVoice,
                                character: 'Narrator',
                                chunkIndex: i + 1,
                                totalChunks: textChunks.length
                            });
                            
                            if (audioBlob) {
                                audioBlobs.push({
                                    blob: audioBlob,
                                    segment: {
                                        type: 'chunk',
                                        text: chunk,
                                        voice: narratorVoice,
                                        character: 'Narrator',
                                        chunkIndex: i + 1,
                                        totalChunks: textChunks.length
                                    }
                                });
                                console.log(`✅ Chunk ${i + 1} generated successfully`);
                            } else {
                                throw new Error(`Failed to generate chunk ${i + 1}`);
                            }
                        } catch (chunkError) {
                            console.error(`❌ Chunk ${i + 1} generation failed:`, chunkError);
                            throw new Error(`Chunk ${i + 1} generation failed: ${chunkError.message}`);
                        }
                    }
                }
                
                // Display results
                if (audioBlobs.length > 0) {
                    console.log(`✅ Generated ${audioBlobs.length} audio segments successfully`);
                    displayNarratorOnlyResults(audioBlobs);
                    hideLoading();
                    
                    if (audioBlobs.length === 1) {
                        showNotification('✅ Narrator-only narration generated successfully!', 'success');
                    } else {
                        showNotification(`✅ Narrator-only narration generated successfully! (${audioBlobs.length} segments)`, 'success');
                    }
                } else {
                    throw new Error('No audio segments were generated');
                }
                
            } catch (error) {
                console.error('Multi-voice generation error:', error);
                showNotification(`Failed to generate multi-voice narration: ${error.message}`, 'error');
                hideLoading();
            }
        }

        // Function to split text into chunks while preserving sentence boundaries
        function splitTextIntoChunks(text, maxChunkSize) {
            const chunks = [];
            let currentChunk = '';
            
            // Split by paragraphs first to maintain natural breaks
            const paragraphs = text.split(/\n\s*\n/);
            
            for (let paragraph of paragraphs) {
                paragraph = paragraph.trim();
                if (!paragraph) continue;
                
                // If paragraph fits in current chunk, add it
                if (currentChunk.length + paragraph.length + 2 <= maxChunkSize) {
                    if (currentChunk) currentChunk += '\n\n';
                    currentChunk += paragraph;
                } else {
                    // Save current chunk if it has content
                    if (currentChunk) {
                        chunks.push(currentChunk.trim());
                        currentChunk = '';
                    }
                    
                    // If paragraph is too long, split by sentences
                    if (paragraph.length > maxChunkSize) {
                        const sentences = paragraph.split(/(?<=[.!?])\s+/);
                        
                        for (let sentence of sentences) {
                            if (currentChunk.length + sentence.length + 1 <= maxChunkSize) {
                                if (currentChunk) currentChunk += ' ';
                                currentChunk += sentence;
                            } else {
                                // Save current chunk
                                if (currentChunk) {
                                    chunks.push(currentChunk.trim());
                                    currentChunk = '';
                                }
                                
                                // If sentence is still too long, split by words
                                if (sentence.length > maxChunkSize) {
                                    const words = sentence.split(' ');
                                    for (let word of words) {
                                        if (currentChunk.length + word.length + 1 <= maxChunkSize) {
                                            if (currentChunk) currentChunk += ' ';
                                            currentChunk += word;
                                        } else {
                                            if (currentChunk) {
                                                chunks.push(currentChunk.trim());
                                            }
                                            currentChunk = word;
                                        }
                                    }
                                } else {
                                    currentChunk = sentence;
                                }
                            }
                        }
                    } else {
                        currentChunk = paragraph;
                    }
                }
            }
            
            // Add final chunk if it has content
            if (currentChunk.trim()) {
                chunks.push(currentChunk.trim());
            }
            
            console.log(`📚 Text split into ${chunks.length} chunks:`);
            chunks.forEach((chunk, i) => {
                console.log(`  Chunk ${i + 1}: ${chunk.length} characters`);
            });
            
            return chunks;
        }

        async function generateSegmentAudio(segment) {
            const voiceInfo = segment.voice.split('_');
            const provider = voiceInfo[0];
            const voiceId = voiceInfo[1];
            
            if (provider === 'openai') {
                return await generateOpenAIAudio(segment.text, voiceId);
            } else if (provider === 'elevenlabs') {
                const apiKey = getElevenLabsApiKey();
                if (!apiKey) {
                    throw new Error('ElevenLabs API key not configured');
                }
                return await generateElevenLabsAudio(segment.text, voiceId, apiKey);
            } else {
                throw new Error(`Unknown voice provider: ${provider}`);
            }
        }

        async function generateOpenAIAudio(text, voice) {
            console.log(`🎙️ Generating OpenAI audio: voice="${voice}", text="${text.substring(0, 50)}..."`);
            
            const apiKey = getOpenAIApiKey();
            if (!apiKey) {
                console.log('❌ No OpenAI API key found');
                throw new Error('OpenAI API key not configured');
            }
            
            console.log('✅ API key found, making request to OpenAI...');

            const requestBody = {
                model: 'tts-1-hd',
                input: text,
                voice: voice,
                response_format: 'mp3'
            };
            
            console.log('Request payload:', requestBody);

            const response = await fetch('https://api.openai.com/v1/audio/speech', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            console.log(`OpenAI API Response: ${response.status} ${response.statusText}`);

            if (!response.ok) {
                const errorText = await response.text();
                console.log('❌ OpenAI API Error response:', errorText);
                throw new Error(`OpenAI TTS API Error: ${response.status} - ${errorText}`);
            }

            const blob = await response.blob();
            console.log(`✅ Audio blob received: ${blob.size} bytes, type: ${blob.type}`);
            return blob;
        }
        
        // DEBUG: Simple TTS test function for console testing
        async function debugTestTTS() {
            console.log('🧪 Starting TTS Debug Test...');
            try {
                const testText = "Hello, this is a test of the text to speech system.";
                const testVoice = "alloy";
                
                console.log(`Testing with text: "${testText}"`);
                console.log(`Testing with voice: "${testVoice}"`);
                
                const blob = await generateOpenAIAudio(testText, testVoice);
                
                if (blob && blob.size > 0) {
                    console.log('🎉 TTS Test SUCCESSFUL!');
                    console.log(`Blob size: ${blob.size} bytes`);
                    console.log(`Blob type: ${blob.type}`);
                    
                    // Create audio element to test playback
                    const audio = document.createElement('audio');
                    audio.controls = true;
                    audio.src = URL.createObjectURL(blob);
                    document.body.appendChild(audio);
                    console.log('🎵 Audio element added to page - check for audio controls');
                    
                    return blob;
                } else {
                    console.log('❌ TTS Test FAILED - No blob or empty blob');
                    return null;
                }
            } catch (error) {
                console.error('❌ TTS Test FAILED with error:', error);
                return null;
            }
        }
        
        // DEBUG: Test complete multi-voice pipeline with simple content
        async function debugTestMultiVoice() {
            console.log('🧪 Starting Multi-Voice Debug Test...');
            
            // Set up test story content
            const testContent = `Sarah walked into the coffee shop.

"Welcome!" called the barista.

"Thanks," Sarah replied.`;
            
            // Set up minimal dialogue data
            window.dialogueData = {
                characters: ['Sarah', 'Barista', 'Narrator'],
                voiceAssignments: {
                    'Sarah': 'openai_nova',
                    'Barista': 'openai_echo', 
                    'Narrator': 'openai_alloy'
                },
                dialogueSections: [
                    { character: 'Sarah', text: 'Thanks', line: 3 }
                ]
            };
            
            // Set test content
            window.storyData = window.storyData || {};
            window.storyData.currentContent = testContent;
            
            console.log('Test setup complete. Dialogue data:', dialogueData);
            
            // Call the multi-voice function
            try {
                await generateMultiVoiceNarration();
                console.log('🎉 Multi-voice test completed - check results above');
            } catch (error) {
                console.error('❌ Multi-voice test failed:', error);
            }
        }
        
        // DEBUG: Simple test to see what happens when generateSegmentAudio fails
        async function debugTestSegmentGeneration() {
            console.log('🧪 Testing individual segment generation...');
            
            const testSegment = {
                type: 'dialogue',
                text: 'Hello, this is a test.',
                voice: 'openai_alloy',
                character: 'TestCharacter'
            };
            
            console.log('Testing segment:', testSegment);
            
            try {
                const result = await generateSegmentAudio(testSegment);
                console.log('✅ Segment generation result:', result);
                return result;
            } catch (error) {
                console.error('❌ Segment generation failed:', error);
                return null;
            }
        }

        function displayMultiVoiceResults(audioFiles, assignments, failedSegments = []) {
            const narrationResults = document.getElementById('narrationResults');
            if (!narrationResults) return;

            let resultsHTML = `
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                    <h3 class="text-xl font-bold mb-4 text-green-400">
                        <i class="fas fa-theater-masks mr-2"></i>Multi-Voice Narration Generated
                    </h3>
                    
                    <div class="mb-4 p-3 bg-theme-primary rounded-lg border border-theme">
                        <h4 class="font-semibold mb-2 text-cyan-400">Voice Assignments Used:</h4>
                        <div class="text-sm space-y-1">
            `;
            
            Object.entries(assignments).forEach(([character, voice]) => {
                const voiceDisplay = voice.replace('openai_', 'OpenAI: ').replace('elevenlabs_', 'ElevenLabs: ');
                resultsHTML += `<div>• <span class="text-cyan-300">${character}:</span> ${voiceDisplay}</div>`;
            });
            
            resultsHTML += `
                        </div>
                    </div>
                    
                    <div class="space-y-3 max-h-60 overflow-y-auto">
            `;
            
            audioFiles.forEach((audioFile, index) => {
                const audioUrl = URL.createObjectURL(audioFile.blob);
                const segment = audioFile.segment;
                const truncatedText = segment.text.length > 100 ? segment.text.substring(0, 100) + '...' : segment.text;
                
                resultsHTML += `
                    <div class="bg-theme-primary p-3 rounded-lg border border-theme">
                        <div class="flex justify-between items-start mb-2">
                            <div class="flex-1">
                                <div class="font-medium text-cyan-400">${segment.character} (${segment.type})</div>
                                <div class="text-xs text-theme-secondary mt-1">"${truncatedText}"</div>
                            </div>
                        </div>
                        <div class="flex items-center space-x-2">
                            <audio controls class="flex-1 h-8">
                                <source src="${audioUrl}" type="audio/mp3">
                                Your browser does not support the audio element.
                            </audio>
                            <button onclick="downloadAudio('${audioUrl}', '${segment.character}_${index + 1}.mp3')" 
                                    class="text-cyan-400 hover:text-cyan-300 p-1">
                                <i class="fas fa-download"></i>
                            </button>
                        </div>
                    </div>
                `;
            });
            
            resultsHTML += `
                    </div>
            `;
            
            // Add failed segments section if any
            if (failedSegments.length > 0) {
                resultsHTML += `
                    <div class="mt-4 bg-red-900 bg-opacity-20 border border-red-600 rounded-lg p-4">
                        <h4 class="font-medium text-red-400 mb-2">⚠️ Failed Segments (${failedSegments.length}):</h4>
                        <div class="text-sm text-red-300 space-y-1">
                `;
                failedSegments.forEach(failed => {
                    resultsHTML += `<div>• ${failed.character}: ${failed.error}</div>`;
                });
                resultsHTML += `
                        </div>
                    </div>
                `;
            }
            
            resultsHTML += `
                    <div class="mt-4 text-center">
                        <div class="bg-theme-primary p-3 rounded-lg mb-3 text-sm">
                            📊 <strong>Generation Summary:</strong> ${audioFiles.length} successful, ${failedSegments.length} failed
                        </div>
                        <div class="space-y-2">
                            <button onclick="createStereoMix()" class="btn-primary px-6 py-2 rounded-lg w-full">
                                <i class="fas fa-headphones mr-2"></i>Create Stereo Mix (Characters Positioned)
                            </button>
                            <button onclick="combineAllAudioSegments()" class="btn-secondary px-6 py-2 rounded-lg w-full">
                                <i class="fas fa-magic mr-2"></i>Combine Into Final Audiobook
                            </button>
                            <button onclick="openAudioDAW()" class="btn-secondary px-6 py-2 rounded-lg w-full">
                                <i class="fas fa-sliders-h mr-2"></i>Open Audio DAW
                            </button>
                            <button onclick="downloadAllMultiVoiceAudio()" class="btn-outline px-6 py-2 rounded-lg w-full">
                                <i class="fas fa-download mr-2"></i>Download Individual Segments
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            narrationResults.innerHTML = resultsHTML;
        }

        function displayNarratorOnlyResults(audioFiles) {
            const narrationResults = document.getElementById('narrationResults');
            if (!narrationResults) return;

            // Calculate total content stats from all segments
            let totalWordCount = 0;
            let totalCharCount = 0;
            const voiceName = audioFiles[0]?.segment?.voice || 'Unknown';
            
            audioFiles.forEach(audioFile => {
                const segment = audioFile.segment;
                totalWordCount += segment.text.split(/\s+/).length;
                totalCharCount += segment.text.length;
            });
            
            const estimatedDuration = Math.round(totalWordCount / 2.5);
            const isMultipleChunks = audioFiles.length > 1;

            let audioSectionsHTML = '';
            
            if (isMultipleChunks) {
                // Multiple chunks - display each segment
                audioSectionsHTML = audioFiles.map((audioFile, index) => {
                    const audioUrl = URL.createObjectURL(audioFile.blob);
                    const segment = audioFile.segment;
                    const chunkWords = segment.text.split(/\s+/).length;
                    const chunkDuration = Math.round(chunkWords / 2.5);
                    
                    return `
                        <div class="bg-theme-primary p-4 rounded-lg border border-theme mb-3">
                            <div class="flex justify-between items-center mb-3">
                                <div class="font-medium text-cyan-400">Part ${index + 1} of ${audioFiles.length} (${chunkWords.toLocaleString()} words)</div>
                                <button onclick="downloadAudio('${audioUrl}', 'narrator_audiobook_part${index + 1}.mp3')" 
                                        class="text-cyan-400 hover:text-cyan-300 p-2 bg-theme-secondary rounded-lg">
                                    <i class="fas fa-download mr-1"></i> Download
                                </button>
                            </div>
                            <audio controls class="w-full mb-2">
                                <source src="${audioUrl}" type="audio/mp3">
                                Your browser does not support the audio element.
                            </audio>
                            <div class="text-xs text-theme-secondary">
                                Duration: ~${Math.floor(chunkDuration / 60)}:${(chunkDuration % 60).toString().padStart(2, '0')} minutes
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                // Single chunk - display normally
                const audioFile = audioFiles[0];
                const audioUrl = URL.createObjectURL(audioFile.blob);
                
                audioSectionsHTML = `
                    <div class="bg-theme-primary p-4 rounded-lg border border-theme mb-4">
                        <div class="flex justify-between items-center mb-3">
                            <div class="font-medium text-cyan-400">Complete Audiobook (Narrator Voice)</div>
                            <button onclick="downloadAudio('${audioUrl}', 'narrator_audiobook.mp3')" 
                                    class="text-cyan-400 hover:text-cyan-300 p-2 bg-theme-secondary rounded-lg">
                                <i class="fas fa-download mr-1"></i> Download
                            </button>
                        </div>
                        <audio controls class="w-full mb-3">
                            <source src="${audioUrl}" type="audio/mp3">
                            Your browser does not support the audio element.
                        </audio>
                        <div class="text-xs text-theme-secondary">
                            All content (narrative and dialogue) narrated by the selected narrator voice
                        </div>
                    </div>
                `;
            }

            const resultsHTML = `
                <div class="bg-theme-secondary p-6 rounded-xl border-2 border-theme">
                    <h3 class="text-xl font-bold mb-4 text-green-400">
                        <i class="fas fa-microphone mr-2"></i>Narrator-Only Audiobook Generated
                    </h3>
                    
                    <div class="mb-4 p-3 bg-theme-primary rounded-lg border border-theme">
                        <h4 class="font-semibold mb-2 text-cyan-400">Content Statistics:</h4>
                        <div class="text-sm space-y-1">
                            <div>• <span class="text-cyan-300">Voice:</span> ${voiceName.replace('openai_', 'OpenAI ').replace('elevenlabs_', 'ElevenLabs ')}</div>
                            <div>• <span class="text-cyan-300">Words:</span> ${totalWordCount.toLocaleString()}</div>
                            <div>• <span class="text-cyan-300">Characters:</span> ${totalCharCount.toLocaleString()}</div>
                            <div>• <span class="text-cyan-300">Estimated Duration:</span> ~${Math.floor(estimatedDuration / 60)}:${(estimatedDuration % 60).toString().padStart(2, '0')} minutes</div>
                            ${isMultipleChunks ? `<div>• <span class="text-cyan-300">Parts:</span> ${audioFiles.length} segments</div>` : ''}
                        </div>
                    </div>
                    
                    ${audioSectionsHTML}
                    
                    <div class="text-center">
                        <div class="bg-green-900 bg-opacity-20 border border-green-600 rounded-lg p-3 mb-4 text-sm">
                            ✅ <strong>Success:</strong> ${isMultipleChunks ? 'Multi-part' : 'Single'} narrator audiobook generated successfully
                        </div>
                        ${isMultipleChunks ? `
                            <div class="bg-blue-900 bg-opacity-20 border border-blue-600 rounded-lg p-3 mb-4 text-sm">
                                ℹ️ <strong>Note:</strong> Story was split into ${audioFiles.length} parts due to length. Play them in sequence for the complete audiobook.
                            </div>
                        ` : ''}
                        <div class="space-y-2">
                            <button onclick="openAudioDAW()" class="btn-secondary px-6 py-2 rounded-lg w-full">
                                <i class="fas fa-sliders-h mr-2"></i>Open Audio DAW
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            narrationResults.innerHTML = resultsHTML;
        }

        // Combine All Chapters function
        async function combineAllChapters() {
            if (!storyData.chapters || storyData.chapters.length === 0) {
                showNotification('No chapters found. Please generate chapters first.', 'warning');
                return;
            }
            
            showLoading('Combining all chapters into one document...');
            
            try {
                let combinedContent = '';
                let hasContent = false;
                
                // Add book title
                const bookTitle = document.getElementById('bookTitle')?.value || storyData.title || 'Untitled Book';
                combinedContent += `# ${bookTitle}\n\n`;
                
                // Combine all chapters
                for (let i = 0; i < storyData.chapters.length; i++) {
                    const chapter = storyData.chapters[i];
                    
                    // Add chapter header
                    combinedContent += `## Chapter ${chapter.number}: ${chapter.title}\n\n`;
                    
                    // Add chapter content if it exists
                    if (chapter.content && chapter.content.trim()) {
                        combinedContent += chapter.content + '\n\n';
                        hasContent = true;
                    } else {
                        // Generate chapter content if it doesn't exist
                        updateLoadingText(`Generating content for Chapter ${chapter.number}...`);
                        try {
                            const content = await generateSingleChapterContent(chapter);
                            if (content && content.trim()) {
                                combinedContent += content + '\n\n';
                                hasContent = true;
                                // Store generated content
                                chapter.content = content;
                            } else {
                                combinedContent += `[Chapter ${chapter.number} content will be generated here]\n\n`;
                            }
                        } catch (error) {
                            console.error(`Failed to generate Chapter ${chapter.number}:`, error);
                            combinedContent += `[Error generating Chapter ${chapter.number}: ${error.message}]\n\n`;
                        }
                    }
                }
                
                if (!hasContent) {
                    throw new Error('No chapter content available to combine');
                }
                
                // Store the combined content
                storyData.combinedContent = combinedContent;
                storyData.currentContent = combinedContent;
                
                // Display in the story editor
                const storyEditor = document.getElementById('storyEditor');
                if (storyEditor) {
                    storyEditor.value = combinedContent;
                    updateWordCount(); // Update word count display
                }
                
                hideLoading();
                showNotification(`Successfully combined ${storyData.chapters.length} chapters! Ready for narration.`, 'success');
                
                // Show preview modal
                showCombinedPreview(combinedContent, bookTitle);
                
            } catch (error) {
                console.error('Combine chapters error:', error);
                hideLoading();
                showNotification(`Failed to combine chapters: ${error.message}`, 'error');
            }
        }
        
        function showCombinedPreview(content, title) {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-theme-secondary rounded-xl max-w-4xl max-h-[80vh] w-full flex flex-col border-2 border-theme">
                    <div class="flex items-center justify-between p-6 border-b border-theme">
                        <h3 class="text-xl font-bold text-cyan-400">
                            <i class="fas fa-book mr-2"></i>Combined Book Preview: ${title}
                        </h3>
                        <button onclick="this.closest('.fixed').remove()" class="text-theme-secondary hover:text-theme-primary">
                            <i class="fas fa-times text-xl"></i>
                        </button>
                    </div>
                    <div class="flex-1 p-6 overflow-y-auto">
                        <div class="bg-theme-primary p-4 rounded-lg border border-theme">
                            <pre class="whitespace-pre-wrap text-sm font-mono text-theme-primary">${content.substring(0, 5000)}${content.length > 5000 ? '\n\n... [Content truncated for preview. Full content is available in the editor.]' : ''}</pre>
                        </div>
                    </div>
                    <div class="p-6 border-t border-theme">
                        <div class="flex space-x-3 justify-center">
                            <button onclick="downloadCombinedBook()" class="btn-primary px-6 py-2 rounded-lg">
                                <i class="fas fa-download mr-2"></i>Download as Text File
                            </button>
                            <button onclick="showPage('narration'); this.closest('.fixed').remove()" class="btn-secondary px-6 py-2 rounded-lg">
                                <i class="fas fa-microphone mr-2"></i>Create Narration
                            </button>
                            <button onclick="this.closest('.fixed').remove()" class="btn-gray px-6 py-2 rounded-lg">
                                Close Preview
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function downloadCombinedBook() {
            const content = storyData.combinedContent || storyData.currentContent;
            const title = document.getElementById('bookTitle')?.value || storyData.title || 'Untitled Book';
            
            if (!content) {
                showNotification('No combined content to download', 'error');
                return;
            }
            
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${title.replace(/[^a-zA-Z0-9]/g, '_')}_Complete_Book.txt`;
            link.click();
            URL.revokeObjectURL(url);
            
            showNotification('Combined book downloaded!', 'success');
        }

        // Character voice preview function
        async function previewCharacterVoice(characterName, selectId) {
            const selectElement = document.getElementById(selectId);
            const voiceValue = selectElement?.value;
            
            if (!voiceValue) {
                showNotification('Please select a voice first.', 'warning');
                return;
            }
            
            // Get sample text for this character
            let previewText;
            if (characterName === 'Narrator') {
                const content = storyData.currentContent || document.getElementById('storyEditor')?.value || '';
                // Get clean narrative text for narrator preview
                previewText = content
                    .replace(/["""'][^"""']*["""']/g, '')
                    .replace(/\b[A-Z][a-zA-Z\s]{1,25}\s+(said|asked|replied|whispered|called|shouted|exclaimed|muttered)[^.!?]*[.!?]/gi, '')
                    .replace(/^\s*[A-Z][a-zA-Z\s]{1,25}\s*:\s*.*/gm, '')
                    .replace(/\s+/g, ' ')
                    .trim()
                    .substring(0, 100);
                if (!previewText) previewText = "This is a sample of the narrator's voice speaking the story text.";
            } else {
                const characterDialogue = dialogueData.dialogueSections.find(d => d.character === characterName);
                previewText = characterDialogue ? characterDialogue.text : `Hello, this is ${characterName} speaking.`;
            }
            
            // Parse provider and voice ID
            const [provider, voiceId] = voiceValue.split('_');
            
            try {
                showLoading(`Previewing ${characterName}'s voice...`);
                
                let audioBlob;
                if (provider === 'openai') {
                    audioBlob = await generateOpenAIAudio(previewText, voiceId);
                } else if (provider === 'elevenlabs') {
                    const apiKey = getElevenLabsApiKey();
                    if (!apiKey) {
                        showNotification('Please configure your ElevenLabs API key first', 'error');
                        hideLoading();
                        return;
                    }
                    audioBlob = await generateElevenLabsAudio(previewText, voiceId, apiKey);
                }
                
                if (audioBlob) {
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    
                    audio.onloadeddata = () => {
                        hideLoading();
                        audio.play();
                        showNotification(`Playing ${characterName}'s voice preview`, 'success');
                    };
                    
                    audio.onerror = () => {
                        hideLoading();
                        showNotification('Failed to play voice preview', 'error');
                    };
                } else {
                    hideLoading();
                    showNotification('Failed to generate voice preview', 'error');
                }
                
            } catch (error) {
                console.error('Voice preview error:', error);
                hideLoading();
                showNotification(`Failed to preview voice: ${error.message}`, 'error');
            }
        }

        // Multi-voice audio download functions
        function downloadAllMultiVoiceAudio() {
            const audioElements = document.querySelectorAll('#narrationResults audio');
            audioElements.forEach((audio, index) => {
                const audioUrl = audio.querySelector('source').src;
                const character = audio.closest('.bg-theme-primary').querySelector('.text-cyan-400').textContent.split(' (')[0];
                downloadAudio(audioUrl, `${character}_segment_${index + 1}.mp3`);
            });
            showNotification(`Downloading ${audioElements.length} audio segments...`, 'success');
        }

        function downloadAudio(audioUrl, filename) {
            const link = document.createElement('a');
            link.href = audioUrl;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // =====================================================
        // COMPREHENSIVE AUDIO DAW SYSTEM
        // =====================================================
        
        let audioDAW = {
            context: null,
            tracks: {},
            isPlaying: false,
            currentTime: 0,
            totalDuration: 0,
            timeline: null,
            canvas: null,
            ctx: null,
            playbackRate: 1,
            zoomLevel: 1,
            isDragging: false,
            dragStartX: 0,
            timelineWidth: 0,
            masterGain: null,
            playbackStartTime: 0,
            animationId: null,
            multiPartBuffers: [],  // For storing multi-part narration
            trackElements: {}      // For storing draggable track elements
        };

        // Combine all audio segments into final audiobook
        async function combineAllAudioSegments() {
            const audioElements = document.querySelectorAll('#narrationResults audio');
            if (audioElements.length === 0) {
                showNotification('No audio segments found to combine.', 'warning');
                return;
            }

            showLoading('Combining audio segments into final audiobook...');

            try {
                // Initialize Web Audio API
                if (!audioDAW.context) {
                    audioDAW.context = new (window.AudioContext || window.webkitAudioContext)();
                }

                const audioBuffers = [];
                let totalDuration = 0;

                // Load and decode all audio segments
                for (let i = 0; i < audioElements.length; i++) {
                    const audioElement = audioElements[i];
                    const audioUrl = audioElement.querySelector('source').src;
                    
                    updateLoadingText(`Loading segment ${i + 1}/${audioElements.length}...`);
                    
                    try {
                        const response = await fetch(audioUrl);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await audioDAW.context.decodeAudioData(arrayBuffer);
                        
                        audioBuffers.push(audioBuffer);
                        totalDuration += audioBuffer.duration;
                    } catch (error) {
                        console.error(`Failed to load segment ${i + 1}:`, error);
                        showNotification(`Warning: Could not load segment ${i + 1}`, 'warning');
                    }
                }

                if (audioBuffers.length === 0) {
                    throw new Error('No audio segments could be loaded');
                }

                updateLoadingText('Combining audio segments...');

                // Create combined audio buffer
                const sampleRate = audioBuffers[0].sampleRate;
                const numberOfChannels = audioBuffers[0].numberOfChannels;
                const totalSamples = Math.floor(totalDuration * sampleRate);
                
                const combinedBuffer = audioDAW.context.createBuffer(numberOfChannels, totalSamples, sampleRate);

                let currentOffset = 0;
                for (const buffer of audioBuffers) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        const channelData = combinedBuffer.getChannelData(channel);
                        const sourceData = buffer.getChannelData(channel);
                        
                        for (let i = 0; i < sourceData.length; i++) {
                            if (currentOffset + i < totalSamples) {
                                channelData[currentOffset + i] = sourceData[i];
                            }
                        }
                    }
                    currentOffset += buffer.length;
                }

                // Convert to downloadable format
                updateLoadingText('Encoding final audiobook...');
                const audioBlob = await audioBufferToBlob(combinedBuffer);
                
                // Create download
                const bookTitle = document.getElementById('bookTitle')?.value || 'Audiobook';
                const fileName = `${bookTitle.replace(/[^a-zA-Z0-9]/g, '_')}_Complete.wav`;
                
                const downloadUrl = URL.createObjectURL(audioBlob);
                const link = document.createElement('a');
                link.href = downloadUrl;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                hideLoading();
                showNotification(`✅ Final audiobook created! Duration: ${formatTime(totalDuration)}`, 'success');
                
                // Also offer to open in DAW
                setTimeout(() => {
                    if (confirm('Would you like to open the combined audio in the Audio DAW for further editing?')) {
                        openAudioDAW();
                    }
                }, 1000);

            } catch (error) {
                console.error('Audio combination error:', error);
                hideLoading();
                showNotification(`Failed to combine audio: ${error.message}`, 'error');
            }
        }

        // NEW: Create stereo mix with character voice positioning
        async function createStereoMix() {
            const audioElements = document.querySelectorAll('#narrationResults audio');
            if (audioElements.length === 0) {
                showNotification('No audio segments found to mix', 'error');
                return;
            }

            showLoading('Creating stereo mix with character positioning...');

            try {
                // Initialize Web Audio API
                if (!audioDAW.context) {
                    audioDAW.context = new (window.AudioContext || window.webkitAudioContext)();
                }

                const audioBuffers = [];
                const characterPositions = new Map();
                let totalDuration = 0;

                // Assign stereo positions to characters
                const characters = Array.from(new Set(Array.from(audioElements).map((audio, index) => {
                    const segment = document.querySelectorAll('#narrationResults .font-semibold.text-cyan-400')[index];
                    return segment ? segment.textContent : 'Unknown';
                })));
                
                // Position characters across stereo field
                characters.forEach((char, index) => {
                    if (char === 'Narrator') {
                        characterPositions.set(char, 0); // Center
                    } else {
                        // Alternate characters left (-0.7) and right (0.7)
                        characterPositions.set(char, index % 2 === 0 ? -0.7 : 0.7);
                    }
                });

                console.log('Character stereo positions:', Object.fromEntries(characterPositions));

                // Load and decode all audio segments with positioning
                for (let i = 0; i < audioElements.length; i++) {
                    const audioElement = audioElements[i];
                    const audioUrl = audioElement.querySelector('source').src;
                    const character = document.querySelectorAll('#narrationResults .font-semibold.text-cyan-400')[i]?.textContent || 'Unknown';
                    const position = characterPositions.get(character) || 0;
                    
                    updateLoadingText(`Loading ${character} (${i + 1}/${audioElements.length})...`);
                    
                    try {
                        const response = await fetch(audioUrl);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await audioDAW.context.decodeAudioData(arrayBuffer);
                        
                        audioBuffers.push({
                            buffer: audioBuffer,
                            character: character,
                            position: position
                        });
                        totalDuration += audioBuffer.duration;
                        
                        console.log(`✅ Loaded ${character} with position ${position}`);
                    } catch (error) {
                        console.error(`Failed to load segment ${i + 1}:`, error);
                        showNotification(`Warning: Could not load ${character} segment`, 'warning');
                    }
                }

                if (audioBuffers.length === 0) {
                    throw new Error('No audio segments could be loaded');
                }

                updateLoadingText('Creating stereo mix...');

                // Create stereo mix buffer (force 2 channels for proper stereo)
                const sampleRate = audioBuffers[0].buffer.sampleRate;
                const totalSamples = Math.floor(totalDuration * sampleRate);
                const stereoBuffer = audioDAW.context.createBuffer(2, totalSamples, sampleRate);
                
                const leftChannel = stereoBuffer.getChannelData(0);
                const rightChannel = stereoBuffer.getChannelData(1);

                let currentOffset = 0;
                for (const {buffer, character, position} of audioBuffers) {
                    // Calculate left/right gains based on position (-1 = full left, 1 = full right, 0 = center)
                    const leftGain = position <= 0 ? 1 : 1 - position;
                    const rightGain = position >= 0 ? 1 : 1 + position;
                    
                    console.log(`Mixing ${character}: position=${position}, leftGain=${leftGain.toFixed(2)}, rightGain=${rightGain.toFixed(2)}`);
                    
                    // Mix source audio into stereo channels with positioning
                    const sourceChannel = buffer.getChannelData(0); // Use first channel of source
                    
                    for (let i = 0; i < sourceChannel.length && currentOffset + i < totalSamples; i++) {
                        const sample = sourceChannel[i];
                        leftChannel[currentOffset + i] += sample * leftGain;
                        rightChannel[currentOffset + i] += sample * rightGain;
                    }
                    
                    currentOffset += buffer.length;
                }

                // Normalize to prevent clipping
                let maxSample = 0;
                for (let i = 0; i < totalSamples; i++) {
                    maxSample = Math.max(maxSample, Math.abs(leftChannel[i]), Math.abs(rightChannel[i]));
                }
                
                if (maxSample > 0.95) {
                    const normalizeFactor = 0.95 / maxSample;
                    for (let i = 0; i < totalSamples; i++) {
                        leftChannel[i] *= normalizeFactor;
                        rightChannel[i] *= normalizeFactor;
                    }
                    console.log(`Normalized audio by factor ${normalizeFactor.toFixed(3)}`);
                }

                // Convert to downloadable format
                updateLoadingText('Encoding stereo audiobook...');
                const audioBlob = await audioBufferToWavBlob(stereoBuffer);
                
                // Create download
                const bookTitle = document.getElementById('bookTitle')?.value || 'Audiobook';
                const fileName = `${bookTitle.replace(/[^a-zA-Z0-9]/g, '_')}_Stereo_Mix.wav`;
                
                const downloadUrl = URL.createObjectURL(audioBlob);
                const link = document.createElement('a');
                link.href = downloadUrl;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                hideLoading();
                showNotification(`✅ Stereo mix created! Characters positioned across stereo field. Duration: ${formatTime(totalDuration)}`, 'success');
                
                console.log('Stereo mix complete:', {
                    duration: totalDuration,
                    channels: 2,
                    sampleRate: sampleRate,
                    characterPositions: Object.fromEntries(characterPositions)
                });

            } catch (error) {
                console.error('Stereo mix error:', error);
                hideLoading();
                showNotification(`Failed to create stereo mix: ${error.message}`, 'error');
            }
        }

        // Convert AudioBuffer to Blob (WAV format)
        async function audioBufferToBlob(audioBuffer) {
            return audioBufferToWavBlob(audioBuffer);
        }

        // Convert AudioBuffer to WAV Blob
        function audioBufferToWavBlob(audioBuffer) {
            const numberOfChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const length = audioBuffer.length;
            
            const arrayBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
            const view = new DataView(arrayBuffer);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * numberOfChannels * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numberOfChannels * 2, true);
            view.setUint16(32, numberOfChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * numberOfChannels * 2, true);
            
            // Convert audio data
            let offset = 44;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const sample = audioBuffer.getChannelData(channel)[i];
                    const intSample = Math.max(-1, Math.min(1, sample)) * 0x7FFF;
                    view.setInt16(offset, intSample, true);
                    offset += 2;
                }
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        // Format time in minutes:seconds
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Open the comprehensive Audio DAW
        function openAudioDAW() {
            // Create DAW modal
            const dawModal = document.createElement('div');
            dawModal.id = 'audioDAWModal';
            dawModal.className = 'fixed inset-0 bg-black bg-opacity-90 flex flex-col z-50';
            dawModal.innerHTML = `
                <div class="flex-1 flex flex-col">
                    <!-- DAW Header -->
                    <div class="bg-gray-900 p-4 border-b border-cyan-500">
                        <div class="flex items-center justify-between">
                            <h2 class="text-xl font-bold text-cyan-400">
                                <i class="fas fa-sliders-h mr-2"></i>Professional Audio DAW
                            </h2>
                            <div class="flex items-center space-x-4">
                                <button onclick="playDAWAudio()" id="dawPlayBtn" class="bg-green-600 hover:bg-green-500 px-4 py-2 rounded">
                                    <i class="fas fa-play"></i> Play
                                </button>
                                <button onclick="stopDAWAudio()" class="bg-red-600 hover:bg-red-500 px-4 py-2 rounded">
                                    <i class="fas fa-stop"></i> Stop
                                </button>
                                <button onclick="exportFinalAudiobook()" class="bg-cyan-600 hover:bg-cyan-500 px-4 py-2 rounded">
                                    <i class="fas fa-download mr-2"></i>Export Final
                                </button>
                                <button onclick="closeAudioDAW()" class="bg-gray-600 hover:bg-gray-500 px-4 py-2 rounded">
                                    <i class="fas fa-times"></i> Close
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- DAW Main Interface -->
                    <div class="flex-1 flex">
                        <!-- Track Controls Panel -->
                        <div class="w-80 bg-gray-800 border-r border-cyan-500 p-4 daw-tracks-container">
                            <h3 class="text-lg font-semibold text-cyan-400 mb-4">
                                <i class="fas fa-mixer mr-2"></i>Mixer Panel
                            </h3>
                            
                            <!-- Narration Track -->
                            <div class="bg-gray-700 rounded-lg p-4 mb-3">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="font-medium text-white">🎙️ Narration</span>
                                    <div class="flex items-center space-x-2">
                                        <div id="narrationLED" class="w-3 h-3 rounded-full bg-gray-500"></div>
                                        <button onclick="muteTrack('narration')" class="text-gray-400 hover:text-white">
                                            <i class="fas fa-volume-mute"></i>
                                        </button>
                                    </div>
                                </div>
                                <div class="flex justify-center">
                                    <div id="narrationFaderContainer" class="daw-fader-container">
                                        <!-- Professional fader will be inserted here by JavaScript -->
                                    </div>
                                </div>
                                <div class="text-xs text-green-400 mt-2" id="narrationStatus">Auto-loaded from generation</div>
                            </div>

                            <!-- Music Track 1 -->
                            <div class="bg-gray-700 rounded-lg p-4 mb-3" data-track="music1">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="font-medium text-white">🎵 Music 1</span>
                                    <div class="flex items-center space-x-2">
                                        <div id="music1LED" class="w-3 h-3 rounded-full bg-gray-500"></div>
                                        <button onclick="muteTrack('music1')" class="text-gray-400 hover:text-white">
                                            <i class="fas fa-volume-mute"></i>
                                        </button>
                                    </div>
                                </div>
                                <div class="flex justify-center">
                                    <div id="music1FaderContainer" class="daw-fader-container">
                                        <!-- Professional fader will be inserted here by JavaScript -->
                                    </div>
                                </div>
                                <div class="mt-2">
                                    <input type="file" accept="audio/*" onchange="loadAudioTrack('music1', this.files[0])" 
                                           class="w-full text-xs bg-gray-600 border border-gray-500 rounded px-2 py-1">
                                    <div class="track-info mt-1 text-xs text-gray-400 min-h-[20px] p-1 border-dashed border border-gray-600 rounded bg-gray-800">
                                        <small>Drop audio here or use file input</small>
                                    </div>
                                </div>
                            </div>

                            <!-- Music Track 2 -->
                            <div class="bg-gray-700 rounded-lg p-4 mb-3" data-track="music2">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="font-medium text-white">🎵 Music 2</span>
                                    <div class="flex items-center space-x-2">
                                        <div id="music2LED" class="w-3 h-3 rounded-full bg-gray-500"></div>
                                        <button onclick="muteTrack('music2')" class="text-gray-400 hover:text-white">
                                            <i class="fas fa-volume-mute"></i>
                                        </button>
                                    </div>
                                </div>
                                <div class="flex justify-center">
                                    <div id="music2FaderContainer" class="daw-fader-container">
                                        <!-- Professional fader will be inserted here by JavaScript -->
                                    </div>
                                </div>
                                <div class="mt-2">
                                    <input type="file" accept="audio/*" onchange="loadAudioTrack('music2', this.files[0])" 
                                           class="w-full text-xs bg-gray-600 border border-gray-500 rounded px-2 py-1">
                                    <div class="track-info mt-1 text-xs text-gray-400 min-h-[20px] p-1 border-dashed border border-gray-600 rounded bg-gray-800">
                                        <small>Drop audio here or use file input</small>
                                    </div>
                                </div>
                            </div>

                            <!-- Sound Effects Track 1 -->
                            <div class="bg-gray-700 rounded-lg p-4 mb-3" data-track="sfx1">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="font-medium text-white">🔊 SFX 1</span>
                                    <div class="flex items-center space-x-2">
                                        <div id="sfx1LED" class="w-3 h-3 rounded-full bg-gray-500"></div>
                                        <button onclick="muteTrack('sfx1')" class="text-gray-400 hover:text-white">
                                            <i class="fas fa-volume-mute"></i>
                                        </button>
                                    </div>
                                </div>
                                <div class="flex justify-center">
                                    <div id="sfx1FaderContainer" class="daw-fader-container">
                                        <!-- Professional fader will be inserted here by JavaScript -->
                                    </div>
                                </div>
                                <div class="mt-2">
                                    <input type="file" accept="audio/*" onchange="loadAudioTrack('sfx1', this.files[0])" 
                                           class="w-full text-xs bg-gray-600 border border-gray-500 rounded px-2 py-1">
                                    <div class="track-info mt-1 text-xs text-gray-400 min-h-[20px] p-1 border-dashed border border-gray-600 rounded bg-gray-800">
                                        <small>Drop audio here or use file input</small>
                                    </div>
                                </div>
                            </div>

                            <!-- Sound Effects Track 2 -->
                            <div class="bg-gray-700 rounded-lg p-4 mb-3" data-track="sfx2">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="font-medium text-white">🔊 SFX 2</span>
                                    <div class="flex items-center space-x-2">
                                        <div id="sfx2LED" class="w-3 h-3 rounded-full bg-gray-500"></div>
                                        <button onclick="muteTrack('sfx2')" class="text-gray-400 hover:text-white">
                                            <i class="fas fa-volume-mute"></i>
                                        </button>
                                    </div>
                                </div>
                                <div class="flex justify-center">
                                    <div id="sfx2FaderContainer" class="daw-fader-container">
                                        <!-- Professional fader will be inserted here by JavaScript -->
                                    </div>
                                </div>
                                <div class="mt-2">
                                    <input type="file" accept="audio/*" onchange="loadAudioTrack('sfx2', this.files[0])" 
                                           class="w-full text-xs bg-gray-600 border border-gray-500 rounded px-2 py-1">
                                    <div class="track-info mt-1 text-xs text-gray-400 min-h-[20px] p-1 border-dashed border border-gray-600 rounded bg-gray-800">
                                        <small>Drop audio here or use file input</small>
                                    </div>
                                </div>
                            </div>

                            <!-- Master Controls -->
                            <div class="bg-cyan-900 rounded-lg p-4">
                                <h4 class="font-medium text-cyan-400 mb-3">🎛️ Master Output</h4>
                                <div class="flex justify-center">
                                    <div id="masterFaderContainer" class="daw-fader-container">
                                        <!-- Professional master fader will be inserted here by JavaScript -->
                                    </div>
                                </div>
                                <div class="mt-3">
                                    <button onclick="normalizeAllTracks()" class="w-full bg-cyan-700 hover:bg-cyan-600 px-3 py-1 rounded text-xs">
                                        🔊 Normalize Audio
                                    </button>
                                </div>
                                <div class="mt-3 text-xs text-gray-400">
                                    Parts: <span id="narrationParts">0</span> | Total: <span id="totalDurationDisplay">00:00</span>
                                </div>
                                <div class="mt-3 grid grid-cols-5 gap-1">
                                    <div id="masterMeter1" class="h-2 bg-gray-600 rounded"></div>
                                    <div id="masterMeter2" class="h-2 bg-gray-600 rounded"></div>
                                    <div id="masterMeter3" class="h-2 bg-gray-600 rounded"></div>
                                    <div id="masterMeter4" class="h-2 bg-gray-600 rounded"></div>
                                    <div id="masterMeter5" class="h-2 bg-gray-600 rounded"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Timeline Area -->
                        <div class="flex-1 flex flex-col">
                            <!-- Timeline Header -->
                            <div class="bg-gray-800 p-3 border-b border-gray-600">
                                <div class="flex items-center justify-between">
                                    <div class="text-lg font-bold text-cyan-400">
                                        <span id="timelinePosition">00:00</span> / <span id="timelineDuration">00:00</span>
                                    </div>
                                    <div class="flex items-center space-x-3">
                                        <div class="text-xs text-gray-400">
                                            Zoom: <span id="zoomLevel">100%</span>
                                        </div>
                                        <button onclick="seekToStart()" class="text-gray-400 hover:text-cyan-400 p-1" title="Go to start">
                                            <i class="fas fa-step-backward"></i>
                                        </button>
                                        <button onclick="zoomTimelineOut()" class="text-gray-400 hover:text-cyan-400 p-1" title="Zoom out">
                                            <i class="fas fa-search-minus"></i>
                                        </button>
                                        <button onclick="zoomTimelineIn()" class="text-gray-400 hover:text-cyan-400 p-1" title="Zoom in">
                                            <i class="fas fa-search-plus"></i>
                                        </button>
                                        <button onclick="fitToView()" class="text-gray-400 hover:text-cyan-400 p-1" title="Fit to view">
                                            <i class="fas fa-expand-arrows-alt"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Canvas Timeline -->
                            <div class="flex-1 relative bg-gray-900 min-h-96">
                                <canvas id="audioTimeline" class="w-full h-full cursor-crosshair" 
                                        onmousedown="startTimelineDrag(event)" 
                                        onmousemove="handleTimelineDrag(event)" 
                                        onmouseup="stopTimelineDrag(event)"
                                        onwheel="handleTimelineZoom(event)">
                                </canvas>
                                <!-- Playhead -->
                                <div id="playhead" class="absolute top-0 w-0.5 bg-cyan-400 opacity-80 pointer-events-none" 
                                     style="height: 100%; left: 0px; transition: left 0.1s ease;"></div>
                                <!-- Track Drop Zones -->
                                <div id="trackDropZones" class="absolute inset-0 pointer-events-none">
                                    <!-- Will be populated dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Footer -->
                    <div class="bg-gray-900 p-3 border-t border-cyan-500">
                        <div class="flex items-center justify-between text-sm text-gray-400">
                            <div>🎵 Drag audio files onto tracks | 🎚️ Adjust levels | ⏯️ Click timeline to seek | 📤 Export final mix</div>
                            <div class="flex items-center space-x-4">
                                <div>Status: <span id="dawStatus" class="text-cyan-400">Ready</span></div>
                                <div>BPM: <span class="text-green-400">120</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(dawModal);
            initializeAudioDAW();
        }

        // Professional DAW Fader Functions
        
        // Convert percentage to dB scale (professional audio scale)
        function percentageToDb(percentage) {
            if (percentage === 0) return -Infinity;
            // 100% = 0dB, 150% = +10dB, 50% = -20dB
            const normalizedValue = percentage / 100;
            if (normalizedValue >= 1) {
                return 20 * Math.log10(normalizedValue); // Above 0dB
            } else {
                return 20 * Math.log10(normalizedValue); // Below 0dB
            }
        }

        // Convert dB to percentage
        function dbToPercentage(db) {
            if (db === -Infinity) return 0;
            return Math.pow(10, db / 20) * 100;
        }

        // Create professional fader element
        function createProfessionalFader(trackName, initialValue, onchange) {
            const container = document.createElement('div');
            container.className = 'daw-fader-container';
            
            // Create scale labels
            const scaleLabels = ['+10', '+5', '0', '-5', '-10', '-20', '-30', '-∞'];
            const scaleValues = [10, 5, 0, -5, -10, -20, -30, -Infinity];
            
            container.innerHTML = `
                <div class="daw-fader-label">${trackName.toUpperCase()}</div>
                <div class="daw-led inactive" id="${trackName}LED"></div>
                <div class="daw-fader-track" id="${trackName}FaderTrack">
                    <div class="daw-fader-handle" id="${trackName}FaderHandle"></div>
                    <div class="daw-fader-scale">
                        ${scaleLabels.map(label => 
                            `<div class="daw-fader-scale-mark major">${label}</div>`
                        ).join('')}
                    </div>
                </div>
                <div class="daw-fader-value" id="${trackName}FaderValue">${initialValue}%</div>
                <input type="range" class="daw-fader-input" id="${trackName}Volume" 
                       min="0" max="150" value="${initialValue}" 
                       onchange="${onchange}('${trackName}', this.value)">
            `;

            // Set up fader interaction
            setupFaderInteraction(trackName, initialValue);
            
            return container;
        }

        // Setup mouse interaction for professional fader
        function setupFaderInteraction(trackName, initialValue) {
            setTimeout(() => {
                const track = document.getElementById(trackName + 'FaderTrack');
                const handle = document.getElementById(trackName + 'FaderHandle');
                const valueDisplay = document.getElementById(trackName + 'FaderValue');
                const hiddenInput = document.getElementById(trackName + 'Volume');
                
                if (!track || !handle) return;

                let isDragging = false;
                let trackRect;

                // Position handle based on initial value
                updateFaderPosition(trackName, initialValue);

                const startDrag = (e) => {
                    e.preventDefault();
                    isDragging = true;
                    trackRect = track.getBoundingClientRect();
                    document.addEventListener('mousemove', drag);
                    document.addEventListener('mouseup', stopDrag);
                    handle.style.cursor = 'grabbing';
                };

                const drag = (e) => {
                    if (!isDragging) return;
                    
                    const y = e.clientY - trackRect.top;
                    const trackHeight = trackRect.height;
                    const percentage = Math.max(0, Math.min(150, 150 * (1 - y / trackHeight)));
                    
                    // Update hidden input
                    hiddenInput.value = percentage;
                    
                    // Update visual position
                    updateFaderPosition(trackName, percentage);
                    
                    // Update value display
                    const db = percentageToDb(percentage);
                    valueDisplay.textContent = db === -Infinity ? '-∞ dB' : `${db.toFixed(1)} dB`;
                    
                    // Call the onchange function
                    if (trackName === 'master') {
                        updateMasterVolume(percentage);
                    } else {
                        updateTrackVolume(trackName, percentage);
                    }
                };

                const stopDrag = () => {
                    isDragging = false;
                    handle.style.cursor = 'pointer';
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('mouseup', stopDrag);
                };

                // Mouse events
                handle.addEventListener('mousedown', startDrag);
                
                // Click on track to jump to position
                track.addEventListener('click', (e) => {
                    if (e.target === handle) return;
                    
                    trackRect = track.getBoundingClientRect();
                    const y = e.clientY - trackRect.top;
                    const trackHeight = trackRect.height;
                    const percentage = Math.max(0, Math.min(150, 150 * (1 - y / trackHeight)));
                    
                    hiddenInput.value = percentage;
                    updateFaderPosition(trackName, percentage);
                    
                    const db = percentageToDb(percentage);
                    valueDisplay.textContent = db === -Infinity ? '-∞ dB' : `${db.toFixed(1)} dB`;
                    
                    if (trackName === 'master') {
                        updateMasterVolume(percentage);
                    } else {
                        updateTrackVolume(trackName, percentage);
                    }
                });
            }, 100);
        }

        // Update fader visual position
        function updateFaderPosition(trackName, percentage) {
            const handle = document.getElementById(trackName + 'FaderHandle');
            const valueDisplay = document.getElementById(trackName + 'FaderValue');
            
            if (handle) {
                // Calculate position (inverted - 0% at bottom, 150% at top)
                const position = (1 - percentage / 150) * 224; // 224px = 240px track height - 16px handle height
                handle.style.top = Math.max(0, Math.min(224, position)) + 'px';
            }
            
            if (valueDisplay) {
                const db = percentageToDb(percentage);
                valueDisplay.textContent = db === -Infinity ? '-∞ dB' : `${db.toFixed(1)} dB`;
            }
        }

        // Update LED indicators based on audio activity
        function updateLEDIndicator(trackName, isActive) {
            const led = document.getElementById(trackName + 'LED');
            if (led) {
                led.className = isActive ? 'daw-led active' : 'daw-led inactive';
            }
        }

        // Create all professional faders
        function createAllProfessionalFaders() {
            console.log('🎚️ Creating professional DAW faders...');
            
            // Fader configurations: [trackName, containerId, initialValue, label]
            const faderConfigs = [
                ['narration', 'narrationFaderContainer', 120, 'NARR'],
                ['music1', 'music1FaderContainer', 60, 'MUS1'],
                ['music2', 'music2FaderContainer', 60, 'MUS2'],
                ['sfx1', 'sfx1FaderContainer', 80, 'SFX1'],
                ['sfx2', 'sfx2FaderContainer', 80, 'SFX2'],
                ['master', 'masterFaderContainer', 130, 'MSTR']
            ];

            faderConfigs.forEach(([trackName, containerId, initialValue, label]) => {
                const container = document.getElementById(containerId);
                if (container) {
                    container.innerHTML = createProfessionalFaderHTML(trackName, initialValue, label);
                    setupFaderInteraction(trackName, initialValue);
                }
            });

            console.log('✅ Professional faders created successfully');
        }

        // Create professional fader HTML structure
        function createProfessionalFaderHTML(trackName, initialValue, label) {
            const scaleLabels = ['+10', '+5', '0', '-5', '-10', '-20', '-30', '-∞'];
            
            return `
                <div class="daw-fader-label">${label}</div>
                <div class="daw-led inactive" id="${trackName}LED"></div>
                <div class="daw-fader-track" id="${trackName}FaderTrack">
                    <div class="daw-fader-handle" id="${trackName}FaderHandle"></div>
                    <div class="daw-fader-scale">
                        ${scaleLabels.map((label, index) => 
                            `<div class="daw-fader-scale-mark major">${label}</div>`
                        ).join('')}
                    </div>
                </div>
                <div class="daw-fader-value" id="${trackName}FaderValue">${initialValue}%</div>
                <input type="range" class="daw-fader-input" id="${trackName}Volume" 
                       min="0" max="150" value="${initialValue}">
            `;
        }

        // Initialize the Enhanced Audio DAW
        function initializeAudioDAW() {
            console.log('🎚️ Initializing Enhanced Audio DAW...');
            
            // Initialize Web Audio Context with higher sample rate for quality
            if (!audioDAW.context) {
                audioDAW.context = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 48000
                });
            }

            // Resume context if suspended (browser policy)
            if (audioDAW.context.state === 'suspended') {
                audioDAW.context.resume();
            }

            // Initialize enhanced track system with 5 tracks total
            audioDAW.tracks = {
                narration: { 
                    buffer: null, 
                    buffers: [], // For multi-part support
                    source: null, 
                    gainNode: null, 
                    volume: 1.2,  // Increased default volume
                    muted: false, 
                    color: '#22d3ee',
                    type: 'narration'
                },
                music1: { 
                    buffer: null, 
                    source: null, 
                    gainNode: null, 
                    volume: 0.6, 
                    muted: false, 
                    color: '#fb7185',
                    type: 'music',
                    startTime: 0,
                    trimStart: 0,
                    trimEnd: null
                },
                music2: { 
                    buffer: null, 
                    source: null, 
                    gainNode: null, 
                    volume: 0.6, 
                    muted: false, 
                    color: '#a78bfa',
                    type: 'music',
                    startTime: 0,
                    trimStart: 0,
                    trimEnd: null
                },
                sfx1: { 
                    buffer: null, 
                    source: null, 
                    gainNode: null, 
                    volume: 0.8, 
                    muted: false, 
                    color: '#34d399',
                    type: 'sfx',
                    startTime: 0,
                    trimStart: 0,
                    trimEnd: null
                },
                sfx2: { 
                    buffer: null, 
                    source: null, 
                    gainNode: null, 
                    volume: 0.8, 
                    muted: false, 
                    color: '#fbbf24',
                    type: 'sfx',
                    startTime: 0,
                    trimStart: 0,
                    trimEnd: null
                }
            };

            // Initialize canvas with proper sizing
            const canvas = document.getElementById('audioTimeline');
            audioDAW.canvas = canvas;
            audioDAW.ctx = canvas.getContext('2d');
            
            // Set high-DPI canvas
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            audioDAW.ctx.scale(dpr, dpr);
            audioDAW.timelineWidth = rect.width;

            // Create master gain node with boost
            audioDAW.masterGain = audioDAW.context.createGain();
            audioDAW.masterGain.gain.value = 1.3; // 30% boost for louder output
            
            // Add compressor for consistent levels
            const compressor = audioDAW.context.createDynamicsCompressor();
            compressor.threshold.setValueAtTime(-24, audioDAW.context.currentTime);
            compressor.knee.setValueAtTime(30, audioDAW.context.currentTime);
            compressor.ratio.setValueAtTime(12, audioDAW.context.currentTime);
            compressor.attack.setValueAtTime(0.003, audioDAW.context.currentTime);
            compressor.release.setValueAtTime(0.25, audioDAW.context.currentTime);
            
            audioDAW.masterGain.connect(compressor);
            compressor.connect(audioDAW.context.destination);

            // Create enhanced gain nodes for each track
            Object.keys(audioDAW.tracks).forEach(trackName => {
                const track = audioDAW.tracks[trackName];
                track.gainNode = audioDAW.context.createGain();
                track.gainNode.connect(audioDAW.masterGain);
                track.gainNode.gain.value = track.volume;
            });

            // Auto-load multi-part narration if available
            loadMultiPartNarration();
            
            // Initialize timeline
            drawEnhancedTimeline();
            
            // Initialize enhanced interactions
            initializeEnhancedInteractions();
            
            // Setup drag and drop functionality
            setupDragAndDrop();
            
            // Create professional faders
            createAllProfessionalFaders();
            
            // Update UI elements
            updateTimelinePosition();
            
            document.getElementById('dawStatus').textContent = 'Enhanced DAW Ready - Drag audio to tracks';
            console.log('✅ Enhanced Audio DAW initialized successfully');
        }

        // Auto-load multi-part narration into DAW
        async function loadMultiPartNarration() {
            const audioElements = document.querySelectorAll('#narrationResults audio');
            if (audioElements.length === 0) {
                document.getElementById('dawStatus').textContent = 'No narration found - Upload files';
                return;
            }
            
            try {
                document.getElementById('dawStatus').textContent = `Loading ${audioElements.length} narration part(s)...`;
                console.log(`🎵 Loading ${audioElements.length} narration parts`);
                
                const buffers = [];
                let totalDuration = 0;
                
                // Load all narration parts sequentially
                for (let i = 0; i < audioElements.length; i++) {
                    const audioElement = audioElements[i];
                    const audioUrl = audioElement.querySelector('source').src;
                    
                    document.getElementById('dawStatus').textContent = `Loading part ${i + 1}/${audioElements.length}...`;
                    
                    try {
                        const response = await fetch(audioUrl);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await audioDAW.context.decodeAudioData(arrayBuffer);
                        
                        buffers.push({
                            buffer: audioBuffer,
                            startTime: totalDuration,
                            partNumber: i + 1
                        });
                        
                        totalDuration += audioBuffer.duration;
                        console.log(`✅ Part ${i + 1} loaded: ${formatTime(audioBuffer.duration)}`);
                        
                    } catch (partError) {
                        console.error(`❌ Failed to load part ${i + 1}:`, partError);
                        continue;
                    }
                }
                
                if (buffers.length > 0) {
                    // Store multi-part buffers
                    audioDAW.tracks.narration.buffers = buffers;
                    audioDAW.totalDuration = totalDuration;
                    
                    // Update UI
                    document.getElementById('narrationParts').textContent = buffers.length;
                    document.getElementById('totalDurationDisplay').textContent = formatTime(totalDuration);
                    document.getElementById('timelineDuration').textContent = formatTime(totalDuration);
                    document.getElementById('narrationStatus').textContent = 
                        `${buffers.length} parts loaded (${formatTime(totalDuration)})`;
                    
                    // Redraw timeline
                    drawEnhancedTimeline();
                    
                    document.getElementById('dawStatus').textContent = 
                        `✅ ${buffers.length} parts loaded (${formatTime(totalDuration)})`;
                    
                    console.log(`✅ Multi-part narration loaded: ${buffers.length} parts, ${formatTime(totalDuration)} total`);
                } else {
                    throw new Error('No audio parts could be loaded');
                }
                
            } catch (error) {
                console.error('❌ Failed to load multi-part narration:', error);
                document.getElementById('dawStatus').textContent = 'Failed to load narration';
            }
        }

        // Load audio track from file upload
        async function loadAudioTrack(trackName, file) {
            if (!file) return;
            
            try {
                document.getElementById('dawStatus').textContent = `Loading ${trackName}...`;
                
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioDAW.context.decodeAudioData(arrayBuffer);
                
                audioDAW.tracks[trackName].buffer = audioBuffer;
                drawTimeline();
                
                document.getElementById('dawStatus').textContent = `${trackName} loaded (${formatTime(audioBuffer.duration)})`;
                showNotification(`✅ ${trackName.charAt(0).toUpperCase() + trackName.slice(1)} track loaded successfully`, 'success');
                
            } catch (error) {
                console.error(`Failed to load ${trackName}:`, error);
                document.getElementById('dawStatus').textContent = `Failed to load ${trackName}`;
                showNotification(`Failed to load ${trackName}: ${error.message}`, 'error');
            }
        }

        // Update track volume
        function updateTrackVolume(trackName, value) {
            const volume = parseInt(value) / 100;
            const track = audioDAW.tracks[trackName];
            
            if (track && track.gainNode) {
                track.volume = volume;
                track.gainNode.gain.value = track.muted ? 0 : volume;
            }
            
            // Update legacy label (if exists)
            const label = document.getElementById(`${trackName}VolumeLabel`);
            if (label) {
                label.textContent = `${value}%`;
            }
            
            // Update professional fader position and value
            updateFaderPosition(trackName, parseInt(value));
            
            // Update LED indicator
            updateLEDIndicator(trackName, volume > 0 && !track.muted);
        }

        // Enhanced master volume control with louder output
        function updateMasterVolume(value) {
            const volume = parseInt(value) / 100;
            
            if (audioDAW.masterGain) {
                // Apply volume with gentle compression curve for louder, cleaner output
                const enhancedVolume = Math.min(volume * 1.2, 1.8); // Up to 180% boost
                audioDAW.masterGain.gain.setValueAtTime(enhancedVolume, audioDAW.context.currentTime);
            }
            
            // Update legacy label (if exists)
            const label = document.getElementById('masterVolumeLabel');
            if (label) {
                label.textContent = `${value}%`;
            }
            
            // Update professional master fader
            updateFaderPosition('master', parseInt(value));
            
            // Update meters and LED
            updateMasterMeters(volume);
            updateLEDIndicator('master', volume > 0);
        }
        
        // Update master level meters
        function updateMasterMeters(level) {
            const meters = ['masterMeter1', 'masterMeter2', 'masterMeter3', 'masterMeter4', 'masterMeter5'];
            const threshold = [0.2, 0.4, 0.6, 0.8, 1.0];
            
            meters.forEach((meterId, index) => {
                const meter = document.getElementById(meterId);
                if (meter) {
                    if (level >= threshold[index]) {
                        if (index < 3) meter.className = 'h-2 bg-green-500 rounded';
                        else if (index < 4) meter.className = 'h-2 bg-yellow-500 rounded';
                        else meter.className = 'h-2 bg-red-500 rounded';
                    } else {
                        meter.className = 'h-2 bg-gray-600 rounded';
                    }
                }
            });
        }
        
        // Normalize all track levels for optimal output
        function normalizeAllTracks() {
            console.log('🔊 Normalizing all track levels...');
            
            // Set recommended levels for each track type
            const recommendedLevels = {
                narration: 120,
                music1: 60,
                music2: 60, 
                sfx1: 80,
                sfx2: 80
            };
            
            Object.keys(recommendedLevels).forEach(trackName => {
                const slider = document.getElementById(`${trackName}Volume`);
                if (slider) {
                    slider.value = recommendedLevels[trackName];
                    updateTrackVolume(trackName, recommendedLevels[trackName]);
                }
            });
            
            // Set master to optimal level
            const masterSlider = document.getElementById('masterVolume');
            if (masterSlider) {
                masterSlider.value = 130;
                updateMasterVolume(130);
            }
            
            showNotification('✅ All track levels normalized for optimal output', 'success');
        }

        // Mute/unmute track
        function muteTrack(trackName) {
            const track = audioDAW.tracks[trackName];
            if (track && track.gainNode) {
                track.muted = !track.muted;
                track.gainNode.gain.value = track.muted ? 0 : track.volume;
                
                // Update LED indicator
                updateLEDIndicator(trackName, track.muted ? 0 : track.volume);
            }
        }

        // Update LED indicators
        function updateLEDIndicator(trackName, volume) {
            const led = document.getElementById(`${trackName}LED`);
            if (led) {
                if (volume > 0.7) {
                    led.className = 'w-3 h-3 rounded-full bg-green-400 animate-pulse';
                } else if (volume > 0.3) {
                    led.className = 'w-3 h-3 rounded-full bg-yellow-400';
                } else if (volume > 0) {
                    led.className = 'w-3 h-3 rounded-full bg-red-400';
                } else {
                    led.className = 'w-3 h-3 rounded-full bg-gray-500';
                }
            }
        }

        // Update master meter
        function updateMasterMeter(volume) {
            for (let i = 1; i <= 5; i++) {
                const meter = document.getElementById(`masterMeter${i}`);
                if (meter) {
                    if (volume >= (i / 5)) {
                        if (i >= 4) {
                            meter.className = 'h-2 bg-red-500 rounded animate-pulse';
                        } else if (i >= 3) {
                            meter.className = 'h-2 bg-yellow-500 rounded';
                        } else {
                            meter.className = 'h-2 bg-green-500 rounded';
                        }
                    } else {
                        meter.className = 'h-2 bg-gray-600 rounded';
                    }
                }
            }
        }

        // Enhanced DAW audio playback with multi-part support
        async function playDAWAudio() {
            if (audioDAW.isPlaying) return;
            
            try {
                if (audioDAW.context.state === 'suspended') {
                    await audioDAW.context.resume();
                }
                
                audioDAW.isPlaying = true;
                audioDAW.playbackStartTime = audioDAW.context.currentTime - audioDAW.currentTime;
                
                const playBtn = document.getElementById('dawPlayBtn');
                if (playBtn) {
                    playBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
                    playBtn.onclick = pauseDAWAudio;
                }
                
                console.log(`🎵 Starting playback from ${formatTime(audioDAW.currentTime)}`);
                
                // Handle multi-part narration
                if (audioDAW.tracks.narration.buffers && audioDAW.tracks.narration.buffers.length > 0) {
                    playMultiPartNarration();
                } else if (audioDAW.tracks.narration.buffer) {
                    // Single narration file
                    playTrackFromTime('narration', audioDAW.currentTime);
                }
                
                // Play other tracks (music, sfx)
                ['music1', 'music2', 'sfx1', 'sfx2'].forEach(trackName => {
                    const track = audioDAW.tracks[trackName];
                    if (track.buffer && track.gainNode) {
                        const trackStartTime = track.startTime || 0;
                        if (audioDAW.currentTime >= trackStartTime) {
                            const offset = audioDAW.currentTime - trackStartTime;
                            if (offset < track.buffer.duration) {
                                playTrackFromTime(trackName, offset);
                            }
                        }
                    }
                });
                
                document.getElementById('dawStatus').textContent = 'Playing...';
                
                // Start timeline animation
                startTimelineAnimation();
                
            } catch (error) {
                console.error('❌ Playback error:', error);
                stopDAWAudio();
                showNotification(`Playback error: ${error.message}`, 'error');
            }
        }
        
        // Play multi-part narration seamlessly
        function playMultiPartNarration() {
            const buffers = audioDAW.tracks.narration.buffers;
            const currentTime = audioDAW.currentTime;
            
            buffers.forEach((part, index) => {
                const partStartTime = part.startTime;
                const partEndTime = part.startTime + part.buffer.duration;
                
                // Check if this part should be playing at current time
                if (currentTime >= partStartTime && currentTime < partEndTime) {
                    const offset = currentTime - partStartTime;
                    const delay = 0; // Start immediately
                    
                    console.log(`🎵 Playing part ${part.partNumber} from ${formatTime(offset)}`);
                    
                    // Create source for this part
                    const source = audioDAW.context.createBufferSource();
                    source.buffer = part.buffer;
                    source.connect(audioDAW.tracks.narration.gainNode);
                    source.start(audioDAW.context.currentTime + delay, offset);
                    
                    // Store source for stopping later
                    if (!audioDAW.tracks.narration.sources) {
                        audioDAW.tracks.narration.sources = [];
                    }
                    audioDAW.tracks.narration.sources.push(source);
                } else if (currentTime < partStartTime) {
                    // Schedule future parts
                    const delay = partStartTime - currentTime;
                    
                    console.log(`🕰️ Scheduling part ${part.partNumber} in ${formatTime(delay)}`);
                    
                    const source = audioDAW.context.createBufferSource();
                    source.buffer = part.buffer;
                    source.connect(audioDAW.tracks.narration.gainNode);
                    source.start(audioDAW.context.currentTime + delay, 0);
                    
                    if (!audioDAW.tracks.narration.sources) {
                        audioDAW.tracks.narration.sources = [];
                    }
                    audioDAW.tracks.narration.sources.push(source);
                }
            });
        }
        
        // Play individual track from specific time
        function playTrackFromTime(trackName, offset) {
            const track = audioDAW.tracks[trackName];
            if (!track.buffer || !track.gainNode) return;
            
            try {
                track.source = audioDAW.context.createBufferSource();
                track.source.buffer = track.buffer;
                track.source.connect(track.gainNode);
                
                const clampedOffset = Math.max(0, Math.min(offset, track.buffer.duration));
                track.source.start(audioDAW.context.currentTime, clampedOffset);
                
                console.log(`🎵 Playing ${trackName} from ${formatTime(clampedOffset)}`);
            } catch (error) {
                console.error(`❌ Failed to play ${trackName}:`, error);
            }
        }

        // Enhanced pause with position preservation
        function pauseDAWAudio() {
            if (!audioDAW.isPlaying) return;
            
            // Calculate current playback position
            if (audioDAW.playbackStartTime) {
                const elapsedTime = audioDAW.context.currentTime - audioDAW.playbackStartTime;
                audioDAW.currentTime = Math.min(elapsedTime, audioDAW.totalDuration || 0);
            }
            
            // Stop all sources
            stopAllAudioSources();
            
            audioDAW.isPlaying = false;
            
            const playBtn = document.getElementById('dawPlayBtn');
            if (playBtn) {
                playBtn.innerHTML = '<i class="fas fa-play"></i> Play';
                playBtn.onclick = playDAWAudio;
            }
            
            // Update timeline position
            updateTimelinePosition();
            drawEnhancedTimeline();
            
            document.getElementById('dawStatus').textContent = `Paused at ${formatTime(audioDAW.currentTime)}`;
            
            // Cancel animation
            if (audioDAW.animationId) {
                cancelAnimationFrame(audioDAW.animationId);
                audioDAW.animationId = null;
            }
        }

        // Enhanced stop function
        function stopDAWAudio() {
            audioDAW.isPlaying = false;
            audioDAW.currentTime = 0;
            audioDAW.playbackStartTime = 0;
            
            // Stop all audio sources
            stopAllAudioSources();
            
            // Stop all sources
            Object.keys(audioDAW.tracks).forEach(trackName => {
                const track = audioDAW.tracks[trackName];
                if (track.source) {
                    try {
                        track.source.stop();
                    } catch (e) {}
                    track.source = null;
                }
            });
            
            const playBtn = document.getElementById('dawPlayBtn');
            if (playBtn) {
                playBtn.innerHTML = '<i class="fas fa-play"></i> Play';
                playBtn.onclick = playDAWAudio;
            }
            
            document.getElementById('dawStatus').textContent = 'Stopped';
            
            // Cancel animation
            if (audioDAW.animationId) {
                cancelAnimationFrame(audioDAW.animationId);
                audioDAW.animationId = null;
            }
            
            drawEnhancedTimeline();
        }

        // Stop all audio sources helper function
        function stopAllAudioSources() {
            Object.keys(audioDAW.tracks).forEach(trackName => {
                const track = audioDAW.tracks[trackName];
                if (track.source) {
                    try {
                        track.source.stop();
                    } catch (e) {
                        console.warn(`Error stopping ${trackName}:`, e);
                    }
                    track.source = null;
                }
            });
        }

        // Start timeline animation during playback
        function startTimelineAnimation() {
            if (audioDAW.animationId) {
                cancelAnimationFrame(audioDAW.animationId);
            }
            
            const animate = () => {
                if (audioDAW.isPlaying) {
                    updateCurrentTime();
                    drawEnhancedTimeline();
                    audioDAW.animationId = requestAnimationFrame(animate);
                }
            };
            
            audioDAW.animationId = requestAnimationFrame(animate);
        }

        // Get maximum duration across all tracks
        function getMaxTrackDuration() {
            let maxDuration = 0;
            
            // Check multi-part narration total
            if (audioDAW.totalDuration > 0) {
                maxDuration = Math.max(maxDuration, audioDAW.totalDuration);
            }
            
            // Check other track durations
            Object.keys(audioDAW.tracks).forEach(trackName => {
                const track = audioDAW.tracks[trackName];
                if (track.buffer && track.buffer.duration) {
                    maxDuration = Math.max(maxDuration, track.buffer.duration);
                }
            });
            
            return maxDuration || 10; // Minimum 10 seconds for empty tracks
        }

        // Update current playback time
        function updateCurrentTime() {
            if (audioDAW.isPlaying && audioDAW.playbackStartTime > 0) {
                const elapsed = (audioDAW.context.currentTime - audioDAW.playbackStartTime) / 1000;
                audioDAW.currentTime = elapsed;
                
                // Update status display
                const status = document.getElementById('dawStatus');
                if (status) {
                    const totalDuration = getMaxTrackDuration();
                    status.textContent = `Playing: ${formatTime(audioDAW.currentTime)} / ${formatTime(totalDuration)}`;
                }
            }
        }

        // Animate timeline during playback (legacy compatibility)
        function animateTimeline() {
            if (!audioDAW.isPlaying) return;
            
            drawEnhancedTimeline();
            requestAnimationFrame(animateTimeline);
        }

        // Enhanced timeline drawing with multi-part support
        function drawEnhancedTimeline() {
            if (!audioDAW.ctx || !audioDAW.canvas) return;
            
            const canvas = audioDAW.canvas;
            const ctx = audioDAW.ctx;
            const width = audioDAW.timelineWidth || canvas.offsetWidth;
            const height = canvas.offsetHeight;
            
            // Clear canvas with dark background
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, width, height);
            
            const totalDuration = audioDAW.totalDuration || getMaxTrackDuration();
            if (totalDuration === 0) return;
            
            // Calculate zoom and offset
            const pixelsPerSecond = (width * audioDAW.zoomLevel) / totalDuration;
            
            // Draw time grid
            drawTimeGrid(ctx, width, height, totalDuration, pixelsPerSecond);
            
            // Draw track lanes (5 tracks total)
            const trackNames = ['narration', 'music1', 'music2', 'sfx1', 'sfx2'];
            const trackHeight = (height - 40) / trackNames.length; // Leave space for time ruler
            
            trackNames.forEach((trackName, index) => {
                const yPos = 30 + (index * trackHeight);
                drawTrackLane(ctx, trackName, 0, yPos, width, trackHeight, pixelsPerSecond);
            });
            
            // Draw playback position
            if (totalDuration > 0) {
                const playheadX = (audioDAW.currentTime / totalDuration) * width;
                drawPlayhead(ctx, playheadX, 0, height);
                updatePlayheadPosition(playheadX);
            }
        }
        
        // Draw time grid and rulers
        function drawTimeGrid(ctx, width, height, totalDuration, pixelsPerSecond) {
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;
            ctx.fillStyle = '#9ca3af';
            ctx.font = '11px Arial';
            
            // Calculate grid interval (1 second, 5 seconds, 10 seconds, etc.)
            const intervals = [1, 5, 10, 30, 60, 300]; // seconds
            let gridInterval = 1;
            
            for (let interval of intervals) {
                if (pixelsPerSecond * interval > 50) { // At least 50px between grid lines
                    gridInterval = interval;
                    break;
                }
            }
            
            // Draw vertical grid lines and time labels
            for (let time = 0; time <= totalDuration; time += gridInterval) {
                const x = (time / totalDuration) * width;
                
                // Vertical grid line
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.moveTo(x, 30);
                ctx.lineTo(x, height);
                ctx.stroke();
                
                // Time label
                ctx.globalAlpha = 1;
                ctx.fillText(formatTime(time), x + 2, 25);
            }
        }
        
        // Draw individual track lane
        function drawTrackLane(ctx, trackName, x, y, width, height, pixelsPerSecond) {
            const track = audioDAW.tracks[trackName];
            
            // Draw track background
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(x, y, width, height);
            
            // Draw track border
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, width, height);
            
            // Draw track label
            ctx.fillStyle = '#d1d5db';
            ctx.font = '12px Arial';
            ctx.fillText(trackName.toUpperCase(), x + 5, y + 15);
            
            // Draw audio content
            if (trackName === 'narration' && audioDAW.tracks.narration.buffers) {
                // Multi-part narration
                drawMultiPartNarration(ctx, x, y, width, height, pixelsPerSecond);
            } else if (track.buffer) {
                // Single audio file
                const startX = x + (track.startTime || 0) * pixelsPerSecond;
                const audioWidth = (track.buffer.duration * pixelsPerSecond);
                drawAudioBlock(ctx, track, startX, y + 20, audioWidth, height - 40);
            }
        }
        
        // Draw multi-part narration blocks
        function drawMultiPartNarration(ctx, x, y, width, height, pixelsPerSecond) {
            const buffers = audioDAW.tracks.narration.buffers;
            if (!buffers) return;
            
            buffers.forEach((part, index) => {
                const startX = x + (part.startTime * pixelsPerSecond);
                const partWidth = part.buffer.duration * pixelsPerSecond;
                
                // Draw part background
                ctx.fillStyle = index % 2 === 0 ? '#0d9488' : '#059669';
                ctx.fillRect(startX, y + 20, partWidth, height - 40);
                
                // Draw part border
                ctx.strokeStyle = '#22d3ee';
                ctx.lineWidth = 2;
                ctx.strokeRect(startX, y + 20, partWidth, height - 40);
                
                // Draw part label
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 10px Arial';
                ctx.fillText(`Part ${part.partNumber}`, startX + 5, y + 35);
                ctx.font = '9px Arial';
                ctx.fillText(formatTime(part.buffer.duration), startX + 5, y + 48);
                
                // Draw simple waveform
                if (partWidth > 50) {
                    drawSimpleWaveform(ctx, part.buffer, startX + 2, y + 52, partWidth - 4, height - 60, '#86efac');
                }
            });
        }
        
        // Draw audio block for music/sfx tracks
        function drawAudioBlock(ctx, track, x, y, width, height) {
            // Draw audio background
            ctx.fillStyle = track.color || '#4b5563';
            ctx.globalAlpha = 0.7;
            ctx.fillRect(x, y, width, height);
            
            // Draw audio border
            ctx.globalAlpha = 1;
            ctx.strokeStyle = track.color || '#6b7280';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
            
            // Draw waveform if block is large enough
            if (width > 50 && track.buffer) {
                drawSimpleWaveform(ctx, track.buffer, x + 2, y + 2, width - 4, height - 4, '#ffffff');
            }
        }
        
        // Draw simplified waveform
        function drawSimpleWaveform(ctx, buffer, x, y, width, height, color) {
            const data = buffer.getChannelData(0);
            const samples = data.length;
            const samplesPerPixel = samples / width;
            const centerY = y + height / 2;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            
            for (let i = 0; i < width; i += 2) {
                const startSample = Math.floor(i * samplesPerPixel);
                const endSample = Math.floor((i + 1) * samplesPerPixel);
                
                let max = 0;
                for (let j = startSample; j < endSample; j++) {
                    max = Math.max(max, Math.abs(data[j]));
                }
                
                const lineHeight = max * (height / 2);
                ctx.moveTo(x + i, centerY - lineHeight);
                ctx.lineTo(x + i, centerY + lineHeight);
            }
            
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        
        // Draw playhead
        function drawPlayhead(ctx, x, y, height) {
            // Playhead line
            ctx.strokeStyle = '#22d3ee';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, height);
            ctx.stroke();
            
            // Playhead handle
            ctx.fillStyle = '#22d3ee';
            ctx.beginPath();
            ctx.arc(x, y + 15, 6, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        // Update DOM playhead position
        function updatePlayheadPosition(x) {
            const playhead = document.getElementById('playhead');
            if (playhead) {
                playhead.style.left = `${x}px`;
            }
        }
        
        // Initialize enhanced interactions
        function initializeEnhancedInteractions() {
            // Canvas mouse events for seeking
            const canvas = audioDAW.canvas;
            if (!canvas) return;
            
            // Prevent context menu
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Add resize handler
            window.addEventListener('resize', () => {
                resizeCanvas();
                drawEnhancedTimeline();
            });
        }
        
        // Handle timeline drag for seeking
        function startTimelineDrag(event) {
            audioDAW.isDragging = true;
            audioDAW.dragStartX = event.offsetX;
            handleTimelineSeek(event);
        }
        
        function handleTimelineDrag(event) {
            if (audioDAW.isDragging) {
                handleTimelineSeek(event);
            }
        }
        
        function stopTimelineDrag(event) {
            audioDAW.isDragging = false;
        }
        
        // Handle timeline seeking
        function handleTimelineSeek(event) {
            const rect = audioDAW.canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const width = rect.width;
            
            const totalDuration = audioDAW.totalDuration || getMaxTrackDuration();
            if (totalDuration > 0) {
                const seekTime = (x / width) * totalDuration;
                audioDAW.currentTime = Math.max(0, Math.min(seekTime, totalDuration));
                
                // Update timeline position display
                updateTimelinePosition();
                
                // Redraw timeline to show new position
                drawEnhancedTimeline();
                
                // If playing, restart from new position
                if (audioDAW.isPlaying) {
                    stopDAWAudio();
                    setTimeout(() => playDAWAudio(), 100);
                }
            }
        }
        
        // Handle timeline zoom
        function handleTimelineZoom(event) {
            event.preventDefault();
            const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
            audioDAW.zoomLevel = Math.max(0.1, Math.min(audioDAW.zoomLevel * zoomFactor, 10));
            
            document.getElementById('zoomLevel').textContent = `${Math.round(audioDAW.zoomLevel * 100)}%`;
            drawEnhancedTimeline();
        }

        // Drag and Drop Audio Asset Functions
        function setupDragAndDrop() {
            // Make audio elements draggable
            const setupDraggableAudio = () => {
                document.querySelectorAll('audio').forEach(audio => {
                    audio.setAttribute('draggable', 'true');
                    audio.addEventListener('dragstart', handleAudioDragStart);
                });
            };

            // Setup drop zones for tracks
            const trackNames = ['music1', 'music2', 'sfx1', 'sfx2'];
            trackNames.forEach(trackName => {
                const trackElement = document.querySelector(`[data-track="${trackName}"]`);
                if (trackElement) {
                    trackElement.addEventListener('dragover', handleDragOver);
                    trackElement.addEventListener('drop', (e) => handleAudioDrop(e, trackName));
                }
            });

            // Setup for timeline canvas
            if (audioDAW.canvas) {
                audioDAW.canvas.addEventListener('dragover', handleDragOver);
                audioDAW.canvas.addEventListener('drop', handleTimelineDrop);
            }

            setupDraggableAudio();
        }

        function handleAudioDragStart(event) {
            const audioSrc = event.target.src || event.target.currentSrc;
            event.dataTransfer.setData('text/plain', audioSrc);
            event.dataTransfer.setData('audio/src', audioSrc);
            
            // Store additional data about the audio
            event.dataTransfer.setData('audio/duration', event.target.duration || '0');
            event.dataTransfer.effectAllowed = 'copy';
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';
        }

        function handleAudioDrop(event, trackName) {
            event.preventDefault();
            const audioSrc = event.dataTransfer.getData('audio/src') || event.dataTransfer.getData('text/plain');
            
            if (audioSrc && trackName) {
                loadAudioToTrack(audioSrc, trackName, 0); // Start at beginning by default
            }
        }

        function handleTimelineDrop(event) {
            event.preventDefault();
            const audioSrc = event.dataTransfer.getData('audio/src') || event.dataTransfer.getData('text/plain');
            
            if (audioSrc) {
                // Calculate drop position on timeline
                const rect = audioDAW.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const width = rect.width;
                const totalDuration = getMaxTrackDuration();
                const dropTime = (x / width) * totalDuration;

                // Determine which track based on Y position
                const y = event.clientY - rect.top;
                const trackHeight = rect.height / 5;
                const trackIndex = Math.floor(y / trackHeight);
                const trackNames = ['narration', 'music1', 'music2', 'sfx1', 'sfx2'];
                
                if (trackIndex >= 1 && trackIndex < trackNames.length) { // Skip narration track
                    const trackName = trackNames[trackIndex];
                    loadAudioToTrack(audioSrc, trackName, dropTime);
                }
            }
        }

        // Load audio file to specific track at specific time
        async function loadAudioToTrack(audioSrc, trackName, startTime = 0) {
            try {
                showLoading(`Loading audio to ${trackName} track...`);
                
                const response = await fetch(audioSrc);
                const audioData = await response.arrayBuffer();
                const audioBuffer = await audioDAW.context.decodeAudioData(audioData);
                
                // Store in track
                if (!audioDAW.tracks[trackName]) {
                    audioDAW.tracks[trackName] = {};
                }
                
                audioDAW.tracks[trackName].buffer = audioBuffer;
                audioDAW.tracks[trackName].startTime = startTime;
                audioDAW.tracks[trackName].duration = audioBuffer.duration;
                
                // Update UI to show loaded audio
                updateTrackUI(trackName, {
                    duration: audioBuffer.duration,
                    startTime: startTime,
                    name: audioSrc.split('/').pop()
                });
                
                // Redraw timeline
                drawEnhancedTimeline();
                
                hideLoading();
                showNotification(`Audio loaded to ${trackName} track at ${formatTime(startTime)}`, 'success');
                
            } catch (error) {
                console.error(`Error loading audio to ${trackName}:`, error);
                hideLoading();
                showNotification(`Failed to load audio to ${trackName} track`, 'error');
            }
        }

        // Update track UI to show loaded content
        function updateTrackUI(trackName, info) {
            const trackElement = document.querySelector(`[data-track="${trackName}"]`);
            if (trackElement) {
                // Update track info display
                const infoElement = trackElement.querySelector('.track-info') || 
                    (() => {
                        const info = document.createElement('div');
                        info.className = 'track-info';
                        trackElement.appendChild(info);
                        return info;
                    })();
                
                infoElement.innerHTML = `
                    <small>${info.name} (${formatTime(info.duration)})</small>
                    <br><small>Start: ${formatTime(info.startTime)}</small>
                    <button onclick="editTrackTiming('${trackName}')" class="btn-small">Edit</button>
                `;
            }
        }

        // Audio Trimming and Positioning Controls
        function editTrackTiming(trackName) {
            const track = audioDAW.tracks[trackName];
            if (!track || !track.buffer) {
                showNotification('No audio loaded in this track', 'warning');
                return;
            }

            // Create modal for editing timing
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <h3>Edit ${trackName.toUpperCase()} Timing</h3>
                    <div class="form-group">
                        <label>Start Time (seconds)</label>
                        <input type="number" id="trackStartTime" value="${track.startTime || 0}" step="0.1" min="0">
                    </div>
                    <div class="form-group">
                        <label>Trim Start (seconds)</label>
                        <input type="number" id="trackTrimStart" value="${track.trimStart || 0}" step="0.1" min="0" max="${track.buffer.duration}">
                    </div>
                    <div class="form-group">
                        <label>Trim End (seconds)</label>
                        <input type="number" id="trackTrimEnd" value="${track.trimEnd || track.buffer.duration}" step="0.1" min="0" max="${track.buffer.duration}">
                    </div>
                    <div class="form-group">
                        <label>Original Duration: ${formatTime(track.buffer.duration)}</label>
                        <label id="trimmedDurationLabel">Trimmed Duration: ${formatTime((track.trimEnd || track.buffer.duration) - (track.trimStart || 0))}</label>
                    </div>
                    <div class="button-group">
                        <button onclick="previewTrackTiming('${trackName}')" class="btn btn-secondary">Preview</button>
                        <button onclick="applyTrackTiming('${trackName}')" class="btn btn-primary">Apply</button>
                        <button onclick="removeTrackAudio('${trackName}')" class="btn btn-danger">Remove</button>
                        <button onclick="closeModal()" class="btn btn-secondary">Cancel</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Update duration when trim values change
            const updateDuration = () => {
                const trimStart = parseFloat(document.getElementById('trackTrimStart').value) || 0;
                const trimEnd = parseFloat(document.getElementById('trackTrimEnd').value) || track.buffer.duration;
                const duration = Math.max(0, trimEnd - trimStart);
                document.getElementById('trimmedDurationLabel').textContent = `Trimmed Duration: ${formatTime(duration)}`;
            };

            document.getElementById('trackTrimStart').addEventListener('input', updateDuration);
            document.getElementById('trackTrimEnd').addEventListener('input', updateDuration);
        }

        function previewTrackTiming(trackName) {
            const track = audioDAW.tracks[trackName];
            if (!track || !track.buffer) return;

            const trimStart = parseFloat(document.getElementById('trackTrimStart').value) || 0;
            const trimEnd = parseFloat(document.getElementById('trackTrimEnd').value) || track.buffer.duration;

            // Stop any current preview
            if (audioDAW.previewSource) {
                audioDAW.previewSource.stop();
                audioDAW.previewSource = null;
            }

            try {
                const source = audioDAW.context.createBufferSource();
                source.buffer = track.buffer;
                
                const gainNode = audioDAW.context.createGain();
                gainNode.gain.value = 0.7; // Preview at lower volume
                
                source.connect(gainNode);
                gainNode.connect(audioDAW.context.destination);
                
                const duration = Math.max(0.1, trimEnd - trimStart);
                source.start(audioDAW.context.currentTime, trimStart, duration);
                
                audioDAW.previewSource = source;
                
                showNotification(`Previewing ${formatTime(duration)} of audio`, 'info');
                
                // Auto-stop preview
                setTimeout(() => {
                    if (audioDAW.previewSource === source) {
                        audioDAW.previewSource = null;
                    }
                }, duration * 1000 + 100);
                
            } catch (error) {
                console.error('Preview error:', error);
                showNotification('Preview failed', 'error');
            }
        }

        function applyTrackTiming(trackName) {
            const track = audioDAW.tracks[trackName];
            if (!track || !track.buffer) return;

            const startTime = parseFloat(document.getElementById('trackStartTime').value) || 0;
            const trimStart = parseFloat(document.getElementById('trackTrimStart').value) || 0;
            const trimEnd = parseFloat(document.getElementById('trackTrimEnd').value) || track.buffer.duration;

            // Validate values
            if (trimStart >= trimEnd) {
                showNotification('Trim start must be less than trim end', 'error');
                return;
            }

            if (trimStart < 0 || trimEnd > track.buffer.duration) {
                showNotification('Trim values must be within audio duration', 'error');
                return;
            }

            // Apply timing settings
            track.startTime = Math.max(0, startTime);
            track.trimStart = trimStart;
            track.trimEnd = trimEnd;
            track.effectiveDuration = trimEnd - trimStart;

            // Update UI
            updateTrackUI(trackName, {
                duration: track.effectiveDuration,
                startTime: track.startTime,
                name: `${trackName} (trimmed)`
            });

            // Redraw timeline
            drawEnhancedTimeline();

            closeModal();
            showNotification(`${trackName} timing updated`, 'success');
        }

        function removeTrackAudio(trackName) {
            if (confirm(`Remove audio from ${trackName} track?`)) {
                // Clear track data
                if (audioDAW.tracks[trackName]) {
                    delete audioDAW.tracks[trackName];
                }

                // Clear UI
                const trackElement = document.querySelector(`[data-track="${trackName}"]`);
                if (trackElement) {
                    const infoElement = trackElement.querySelector('.track-info');
                    if (infoElement) {
                        infoElement.innerHTML = '<small>Drop audio here</small>';
                    }
                }

                // Redraw timeline
                drawEnhancedTimeline();

                closeModal();
                showNotification(`${trackName} audio removed`, 'success');
            }
        }

        function closeModal() {
            const modal = document.querySelector('.modal-overlay');
            if (modal) {
                modal.remove();
            }

            // Stop any preview
            if (audioDAW.previewSource) {
                try {
                    audioDAW.previewSource.stop();
                } catch (e) {}
                audioDAW.previewSource = null;
            }
        }
        
        // Timeline control functions
        function seekToStart() {
            audioDAW.currentTime = 0;
            updateTimelinePosition();
            drawEnhancedTimeline();
            if (audioDAW.isPlaying) {
                stopDAWAudio();
                setTimeout(() => playDAWAudio(), 100);
            }
        }
        
        function zoomTimelineIn() {
            audioDAW.zoomLevel = Math.min(audioDAW.zoomLevel * 1.5, 10);
            document.getElementById('zoomLevel').textContent = `${Math.round(audioDAW.zoomLevel * 100)}%`;
            drawEnhancedTimeline();
        }
        
        function zoomTimelineOut() {
            audioDAW.zoomLevel = Math.max(audioDAW.zoomLevel / 1.5, 0.1);
            document.getElementById('zoomLevel').textContent = `${Math.round(audioDAW.zoomLevel * 100)}%`;
            drawEnhancedTimeline();
        }
        
        function fitToView() {
            audioDAW.zoomLevel = 1;
            document.getElementById('zoomLevel').textContent = '100%';
            drawEnhancedTimeline();
        }
        
        // Update timeline position display
        function updateTimelinePosition() {
            const currentTimeDisplay = document.getElementById('timelinePosition');
            if (currentTimeDisplay) {
                currentTimeDisplay.textContent = formatTime(audioDAW.currentTime);
            }
        }
        
        // Resize canvas maintaining aspect ratio
        function resizeCanvas() {
            const canvas = audioDAW.canvas;
            if (!canvas) return;
            
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            audioDAW.ctx.scale(dpr, dpr);
            audioDAW.timelineWidth = rect.width;
        }

        // Draw waveform visualization
        function drawWaveform(ctx, buffer, x, y, width, height, color) {
            const data = buffer.getChannelData(0);
            const samples = data.length;
            const samplesPerPixel = samples / width;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            for (let i = 0; i < width; i++) {
                const startSample = Math.floor(i * samplesPerPixel);
                const endSample = Math.floor((i + 1) * samplesPerPixel);
                
                let min = 1, max = -1;
                for (let j = startSample; j < endSample && j < samples; j++) {
                    if (data[j] < min) min = data[j];
                    if (data[j] > max) max = data[j];
                }
                
                const minY = y + height/2 + (min * height/4);
                const maxY = y + height/2 + (max * height/4);
                
                ctx.moveTo(x + i, minY);
                ctx.lineTo(x + i, maxY);
            }
            
            ctx.stroke();
        }

        // Get track color for visualization
        function getTrackColor(trackName) {
            const colors = {
                'narration': '#3b82f6', // Blue
                'music': '#10b981',      // Green
                'sfx': '#f59e0b'         // Orange
            };
            return colors[trackName] || '#6b7280';
        }

        // Get maximum duration across all tracks
        function getMaxTrackDuration() {
            return Math.max(...Object.values(audioDAW.tracks)
                .filter(t => t.buffer)
                .map(t => t.buffer.duration), 0);
        }

        // Export final audiobook with metadata
        async function exportFinalAudiobook() {
            try {
                document.getElementById('dawStatus').textContent = 'Exporting final audiobook...';
                showLoading('Creating final audiobook with cover art and metadata...');
                
                // Check if we have audio to export
                const tracksWithAudio = Object.values(audioDAW.tracks).filter(t => t.buffer);
                if (tracksWithAudio.length === 0) {
                    throw new Error('No audio tracks loaded to export');
                }
                
                // Get maximum duration
                const maxDuration = getMaxTrackDuration();
                if (maxDuration === 0) {
                    throw new Error('No valid audio found');
                }
                
                // Create final mix buffer
                const sampleRate = audioDAW.context.sampleRate;
                const totalSamples = Math.floor(maxDuration * sampleRate);
                const finalBuffer = audioDAW.context.createBuffer(2, totalSamples, sampleRate);
                
                // Mix all tracks together
                Object.keys(audioDAW.tracks).forEach(trackName => {
                    const track = audioDAW.tracks[trackName];
                    if (track.buffer && !track.muted) {
                        const volume = track.volume;
                        const channels = Math.min(track.buffer.numberOfChannels, 2);
                        
                        for (let channel = 0; channel < channels; channel++) {
                            const sourceData = track.buffer.getChannelData(channel);
                            const targetData = finalBuffer.getChannelData(channel);
                            
                            for (let i = 0; i < Math.min(sourceData.length, totalSamples); i++) {
                                targetData[i] += sourceData[i] * volume;
                            }
                        }
                    }
                });
                
                // Convert to WAV format
                const wavData = encodeWAV(finalBuffer);
                
                // Create blob and download
                const blob = new Blob([wavData], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                // Create download link with metadata
                const a = document.createElement('a');
                a.href = url;
                a.download = `${storyData.title || 'Audiobook'}_Final_Mix_${new Date().toISOString().slice(0, 10)}.wav`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                URL.revokeObjectURL(url);
                hideLoading();
                
                document.getElementById('dawStatus').textContent = `Exported: ${formatTime(maxDuration)}`;
                showNotification(`✅ Final audiobook exported successfully! Duration: ${formatTime(maxDuration)}`, 'success');
                
                // Generate cover art and enhanced metadata
                setTimeout(() => {
                    generateCoverArt();
                }, 1000);
                
            } catch (error) {
                console.error('Export error:', error);
                hideLoading();
                document.getElementById('dawStatus').textContent = 'Export failed';
                showNotification(`Export failed: ${error.message}`, 'error');
            }
        }

        // Encode audio buffer to WAV format
        function encodeWAV(buffer) {
            const length = buffer.length;
            const channels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const arrayBuffer = new ArrayBuffer(44 + length * channels * 2);
            const view = new DataView(arrayBuffer);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * channels * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, channels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * channels * 2, true);
            view.setUint16(32, channels * 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * channels * 2, true);
            
            // Convert float samples to 16-bit PCM
            const offset = 44;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < channels; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    view.setInt16(offset + (i * channels + channel) * 2, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                }
            }
            
            return arrayBuffer;
        }

        // Generate cover art for the audiobook
        function generateCoverArt() {
            const canvas = document.createElement('canvas');
            canvas.width = 600;
            canvas.height = 600;
            const ctx = canvas.getContext('2d');
            
            // Create gradient background
            const gradient = ctx.createLinearGradient(0, 0, 600, 600);
            gradient.addColorStop(0, '#1e3a8a');
            gradient.addColorStop(0.5, '#3b82f6');
            gradient.addColorStop(1, '#1e40af');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 600, 600);
            
            // Add title
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            const title = storyData.title || 'AI Generated Audiobook';
            ctx.fillText(title, 300, 150);
            
            // Add subtitle
            ctx.font = '24px Arial';
            ctx.fillText('Created with AUTHORR AI', 300, 200);
            
            // Add decorative elements
            ctx.strokeStyle = '#78e3fe';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(300, 350, 150, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Add audio wave decoration
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 100; x < 500; x += 20) {
                const y = 450 + Math.sin(x * 0.05) * 30;
                if (x === 100) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Convert to blob and download
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${storyData.title || 'Audiobook'}_Cover.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('📸 Cover art generated and downloaded!', 'success');
            }, 'image/png');
        }

        // Close DAW modal
        function closeAudioDAW() {
            stopDAWAudio();
            const modal = document.getElementById('audioDAWModal');
            if (modal) {
                modal.remove();
            }
        }

        // Add drag and drop functionality for timeline
        function initializeTimelineDragDrop() {
            const canvas = audioDAW.canvas;
            if (!canvas) return;
            
            let isDragging = false;
            let dragStartX = 0;
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragStartX = e.offsetX;
                canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const maxDuration = getMaxTrackDuration();
                    const newTime = (e.offsetX / canvas.width) * maxDuration;
                    audioDAW.currentTime = Math.max(0, Math.min(newTime, maxDuration));
                    drawTimeline();
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'pointer';
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                canvas.style.cursor = 'pointer';
            });
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadSettings();
            
            // Populate voice options when page loads
            setTimeout(() => {
                populateVoiceOptions();
                updateContentStatus(); // Check content status on load
            }, 1000);
            
            // Add text area listener for character count
            const textArea = document.getElementById('cloneTextInput');
            if (textArea) {
                textArea.addEventListener('input', updateCharCount);
            }
        });

        // Notification System
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg max-w-sm transform transition-all duration-300 translate-x-full`;
            
            // Set colors based on type
            const colors = {
                'success': 'bg-green-600 text-white border-green-500',
                'error': 'bg-red-600 text-white border-red-500',
                'warning': 'bg-yellow-600 text-white border-yellow-500',
                'info': 'bg-blue-600 text-white border-blue-500'
            };
            
            const icons = {
                'success': 'fas fa-check-circle',
                'error': 'fas fa-exclamation-circle',
                'warning': 'fas fa-exclamation-triangle',
                'info': 'fas fa-info-circle'
            };
            
            notification.className += ` ${colors[type] || colors.info}`;
            
            notification.innerHTML = `
                <div class="flex items-center">
                    <i class="${icons[type] || icons.info} mr-3"></i>
                    <div class="flex-1">
                        <p class="text-sm font-medium">${message}</p>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" class="ml-3 text-white hover:text-gray-200">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;
            
            // Add to page
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
                notification.classList.add('translate-x-0');
            }, 100);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 300);
            }, 5000);
        }

        // ============ GENRE SYSTEM ============
        
        let genreConfig = null;
        let currentGenre = 'General';
        let humanTouchData = {
            lines_edited: 0,
            total_lines: 0,
            personal_notes_added: 0,
            voice_direction_chosen: false
        };

        // Load genre configuration
        async function loadGenreConfig() {
            try {
                const response = await fetch('./genre-config.json');
                genreConfig = await response.json();
                console.log('Genre configuration loaded:', Object.keys(genreConfig.genres));
            } catch (error) {
                console.error('Failed to load genre configuration:', error);
                // Fallback - create minimal config
                genreConfig = {
                    default_genre: 'General',
                    tooltip_coachmarks: {},
                    genres: {}
                };
            }
        }

        // Update genre settings when user selects a genre
        function updateGenreSettings() {
            const genreSelect = document.getElementById('storyGenre');
            const tooltipElement = document.getElementById('genreTooltip');
            
            if (!genreSelect || !tooltipElement) {
                console.log('Genre elements not found yet, will retry in 500ms...');
                setTimeout(updateGenreSettings, 500);
                return;
            }
            
            currentGenre = genreSelect.value;
            console.log('Updating genre to:', currentGenre);
            console.log('Genre config available:', !!genreConfig);
            console.log('Available tooltip coachmarks:', genreConfig?.tooltip_coachmarks ? Object.keys(genreConfig.tooltip_coachmarks) : 'none');
            
            // Update tooltip with genre-specific coaching
            if (genreConfig && genreConfig.tooltip_coachmarks && genreConfig.tooltip_coachmarks[currentGenre]) {
                const coaching = genreConfig.tooltip_coachmarks[currentGenre];
                tooltipElement.textContent = `💡 ${coaching}`;
                tooltipElement.title = coaching;
                tooltipElement.classList.remove('text-gray-400');
                tooltipElement.classList.add('text-cyan-300', 'font-medium');
                console.log('✅ Applied tooltip:', coaching);
            } else if (currentGenre === 'General') {
                tooltipElement.textContent = '';
                tooltipElement.title = '';
                console.log('✅ Cleared tooltip for General genre');
            } else {
                // If config isn't loaded yet, try again shortly
                if (!genreConfig) {
                    tooltipElement.textContent = '⏳ Loading genre tips...';
                    console.log('⏳ Genre config not loaded yet, retrying...');
                    setTimeout(updateGenreSettings, 1000);
                    return;
                } else {
                    tooltipElement.textContent = '⚠️ No tips available';
                    tooltipElement.classList.add('text-gray-400');
                    console.log('⚠️ No tooltip available for genre:', currentGenre);
                }
            }
            
            // Update narration guidance
            updateNarrationGuidance();
            
            // Store genre selection
            if (typeof storyData !== 'undefined') {
                storyData.genre = currentGenre;
            }
            
            if (currentGenre !== 'General' && genreConfig?.tooltip_coachmarks?.[currentGenre]) {
                showNotification(`✨ Genre set to ${currentGenre}. Smart coaching active!`, 'success');
            }
        }

        // Update narration guidance based on current genre
        function updateNarrationGuidance() {
            const genreDisplayElement = document.getElementById('currentGenreDisplay');
            const tipsElement = document.getElementById('genreNarrationTips');
            
            if (genreDisplayElement) {
                genreDisplayElement.textContent = currentGenre;
            }
            
            if (tipsElement) {
                const guidance = getNarrationGuidance();
                if (guidance && currentGenre !== 'General') {
                    let tipsHTML = '<div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2">';
                    
                    if (guidance.voice_tone) {
                        tipsHTML += `<div><strong>Voice Tone:</strong> ${guidance.voice_tone}</div>`;
                    }
                    if (guidance.pauses) {
                        tipsHTML += `<div><strong>Pacing:</strong> ${guidance.pauses}</div>`;
                    }
                    if (guidance.effects) {
                        tipsHTML += `<div><strong>Effects:</strong> ${guidance.effects}</div>`;
                    }
                    if (guidance.background) {
                        tipsHTML += `<div><strong>Background:</strong> ${guidance.background}</div>`;
                    }
                    if (guidance.tip) {
                        tipsHTML += `<div><strong>Pro Tip:</strong> ${guidance.tip}</div>`;
                    }
                    if (guidance.recording_tip) {
                        tipsHTML += `<div><strong>Recording:</strong> ${guidance.recording_tip}</div>`;
                    }
                    
                    tipsHTML += '</div>';
                    tipsElement.innerHTML = tipsHTML;
                } else {
                    tipsElement.innerHTML = 'Select a specific genre in the Workspace to get tailored narration guidance for your story type.';
                }
            }
        }

        // Get genre-specific tool configuration
        function getGenreToolConfig(toolName) {
            if (!genreConfig || currentGenre === 'General' || !genreConfig.genres[currentGenre]) {
                return null;
            }
            
            const genreData = genreConfig.genres[currentGenre];
            return genreData.tool_customizations && genreData.tool_customizations[toolName] || null;
        }

        // Get genre-specific prompts for tools
        function getGenrePrompt(toolName, defaultPrompt) {
            const toolConfig = getGenreToolConfig(toolName);
            
            if (!toolConfig) return defaultPrompt;
            
            // Handle different types of genre customizations
            if (toolConfig.prompt) {
                return toolConfig.prompt;
            }
            
            if (toolConfig.override_prompt) {
                return toolConfig.override_prompt;
            }
            
            if (toolConfig.suggestion_prompt) {
                return toolConfig.suggestion_prompt;
            }
            
            // Add genre-specific context to default prompt
            const genreData = genreConfig.genres[currentGenre];
            if (genreData && genreData.chapter_writing_rules) {
                const rules = genreData.chapter_writing_rules;
                let genreContext = `\\n\\n**Genre: ${currentGenre} - Writing Guidelines:**\\n`;
                genreContext += `- Point of View: ${rules.point_of_view}\\n`;
                genreContext += `- Focus on: ${rules.focus.join(', ')}\\n`;
                genreContext += `- Avoid: ${rules.avoid.join(', ')}\\n`;
                
                if (toolConfig.default_tone) {
                    genreContext += `- Tone: ${toolConfig.default_tone}\\n`;
                }
                if (toolConfig.pace) {
                    genreContext += `- Pacing: ${toolConfig.pace}\\n`;
                }
                
                return defaultPrompt + genreContext;
            }
            
            return defaultPrompt;
        }

        // Calculate human touch score
        function calculateHumanTouchScore() {
            if (!genreConfig) return 0;
            
            const formula = genreConfig.human_touch_score_formula;
            const data = humanTouchData;
            
            // Parse and evaluate the formula
            // ((lines_edited / total_lines) * 0.4) + ((personal_notes_added > 0 ? 0.3 : 0) + (voice_direction_chosen ? 0.3 : 0))
            
            const linesRatio = data.total_lines > 0 ? data.lines_edited / data.total_lines : 0;
            const notesBonus = data.personal_notes_added > 0 ? 0.3 : 0;
            const voiceBonus = data.voice_direction_chosen ? 0.3 : 0;
            
            const score = (linesRatio * 0.4) + notesBonus + voiceBonus;
            return Math.min(Math.round(score * 100), 100); // Cap at 100%
        }

        // Update human touch score display
        function updateHumanTouchScore() {
            const score = calculateHumanTouchScore();
            const scoreElements = document.querySelectorAll('.human-touch-score');
            
            scoreElements.forEach(element => {
                element.textContent = `${score}%`;
                
                // Color coding
                if (score >= 70) {
                    element.className = 'human-touch-score text-green-400 font-semibold';
                } else if (score >= 40) {
                    element.className = 'human-touch-score text-yellow-400 font-semibold';
                } else {
                    element.className = 'human-touch-score text-red-400 font-semibold';
                }
            });
        }

        // Track human touch interactions
        function trackHumanTouch(type, value = 1) {
            switch(type) {
                case 'lines_edited':
                    humanTouchData.lines_edited += value;
                    break;
                case 'total_lines':
                    humanTouchData.total_lines = value;
                    break;
                case 'personal_notes':
                    humanTouchData.personal_notes_added += value;
                    break;
                case 'voice_direction':
                    humanTouchData.voice_direction_chosen = true;
                    break;
            }
            
            updateHumanTouchScore();
        }

        // Get narration guidance for current genre
        function getNarrationGuidance() {
            if (!genreConfig || currentGenre === 'General' || !genreConfig.genres[currentGenre]) {
                return null;
            }
            
            return genreConfig.genres[currentGenre].narration_prep || null;
        }

        // Initialize genre system
        async function initializeGenreSystem() {
            console.log('🔧 Initializing genre system...');
            try {
                await loadGenreConfig();
                console.log('✅ Genre config loaded successfully');
                
                // Wait a bit for DOM elements to be ready
                setTimeout(() => {
                    updateGenreSettings(); // Set initial genre
                    updateHumanTouchScore(); // Initialize score display
                    console.log('✅ Genre system initialized');
                }, 100);
                
            } catch (error) {
                console.error('❌ Failed to initialize genre system:', error);
                // Retry once after a delay
                setTimeout(async () => {
                    try {
                        await loadGenreConfig();
                        updateGenreSettings();
                        updateHumanTouchScore();
                        console.log('✅ Genre system initialized on retry');
                    } catch (retryError) {
                        console.error('❌ Genre system retry failed:', retryError);
                    }
                }, 2000);
            }
        }

        // Initialize on page load - ensure this runs after other DOM setup
        document.addEventListener('DOMContentLoaded', () => {
            // Give other initializers time to complete first
            setTimeout(initializeGenreSystem, 200);
        });
        
    </script>
</body>
</html>
